const cds = require('../index')
const cdsv = require('@sap/cds-compiler')
const configuredSqlMapping = (o = {}) => o.sql || o.sql_mapping || cds.env.data.sql_mapping

const conf = cds.env && cds.env.cdsv || {}
const _ = o => Object.assign (o||{},conf)

module.exports = {
  parse: (...args) => _csn4 (cdsv.compileSources (...args)),
  parseToCqn: cdsv.parseToCqn,
  parseToExpr: cdsv.parseToExpr,
  collectSources: (...args) => cdsv.collectSources(...args),
  compile: (...args) => cdsv.compile(...args) .then (_csn4),
  forOData: (csn,o) => _csn4x(csn,o,'odata'),
  forSql: (csn,o) => _csn4x(csn,_(o),'sql'),
  toHana: (csn,o) => cdsv.toHana(_xsn4(csn),o),
  toCdl: (csn,o) => cdsv.toCdl(_xsn4(csn),o),
  toSql: (csn,o) => cdsv.toSql(_xsn4(csn),_(o)),
  toSwagger: (csn,o) => cdsv.toSwagger (_xsn4(csn),o),
  toOdata: (csn,o) => cdsv.toOdata (_xsn4(csn),o),
  sqlNamingOptions
}

function _csn4x (csn, o = {}, target = 'odata') {
  o.names = sqlNamingOptions(o)
  o.csn = true
  const compiled = cdsv[(target === 'sql') ? 'toSql' : 'toOdata'](_xsn4(csn), o)
  const xsn = _csn4(compiled._augmentedCsn, 'forOData')
  xsn['@sql_mapping'] = configuredSqlMapping(o)
  return xsn
}

/** Returns a given model as plain csn.
 * The original augmented model is stored in the hidden
 * property [_x]
 */
function _csn4 (model, forOData) {
  if (!model.messages) return model
  if (!forOData && model._csn)  return model._csn
  let xsn = model,  csn = cds.env.build.new_csn ? cdsv.compactModel (xsn) : cdsv.toCsn (xsn)
  // FIXME: That's just ugly, bad and awfully slow, and the last one is likely critical
  // csn = JSON.parse (JSON.stringify (csn, (key, value) => {
  //   if (key === 'indexNo') return
  //   if (key === 'origin') return
  //     // if (key === 'foreignKeys') return
  //   return value
  // }))
  for (let s in xsn.sources) {
    if (xsn.sources[s].namespace)
      csn.namespace = xsn.sources[s].namespace.path.map(x => x.id).join('.')
    break //> only the first one
  }
  // keep _source in csn as non-enumerable property
  Object.defineProperty (csn, '_sources', {value: Object.keys (xsn.sources) })
  // keep _locations in csn as non-enumerable properties
  for (let d in csn.definitions) {
    if (!csn.definitions[d]['@source'] && csn.definitions[d].kind === 'service')  csn.definitions[d]['@source'] = xsn.definitions[d].location.filename
    Object.defineProperty (csn.definitions[d], '_location', {value: xsn.definitions[d].location })
  }
  // keep the _xsn twin  non-enumerable properties
  Object.defineProperty (csn, '_xsn', {value:xsn, configurable:1, writable:1 })
  // cache _csn to _xsn only in normalized models, i.e. not the flattened Odata csn
  forOData || Object.defineProperty (xsn, '_csn', {value:csn, configurable:1, writable:1 })
  return csn
}

/** Returns a given model as an augmented one.
 * This is necessary because severel cdsv operations seem to always expect
 * augmented models created from own parser and don't work with plain CSNs
 * from other sources??
 */
function _xsn4 (model) {
  if (model._parsed)  model = model._parsed
  if (model.messages) return model   // it is already an augmented one
  if (model._xsn) return model._xsn   // came from cdsv before
  // doesn't stem from cdsv... (yes, this is all pretty crazy)
  let csn=model, xsn = cdsv.compileSources({'.json': JSON.stringify(csn, (k, v) => {
    if (k === 'namespace') return
    return v
  })})
  Object.defineProperty (csn, '_xsn', {value:xsn})
  Object.defineProperty (xsn, '_csn', {value:csn})
  return xsn
}

function sqlNamingOptions(options) {
  const configured = configuredSqlMapping(options)
  return { slugified: 'flat', plain: 'flat', quoted: 'deep', }[ configured ] || configured
}


// Add .toString() support to cdsv's composite errors class
const { CompilationError } = require('@sap/cds-compiler/lib/base/messages')
Object.defineProperties(CompilationError.prototype, {
  name: { get: function () { return 'cds.compile failed' } },
  message: { get: function () {
    return this.errors && this.errors.reduce((p,msg) => p +
      (' at '+msg).replace (': Error: ',': ')
      .replace ('Extraneous input','invalid token')
      .replace(/ expecting {(<EOF>, )?([^}]*)}/, (str,_,p1) => {
        return ` - expected one of `+ p1.toLowerCase() + '.'
      })
     + '\n', '\n')
  }}
})
