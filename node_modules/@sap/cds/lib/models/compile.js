const cdsv = require('./cdsv')
const cds = require('../index')

const YAML = { stringify: (...args) => (YAML.stringify = require('./2yaml'))(...args) }


// Fluent API, i.e. compile(csn).to('yml') --> see also: https://bit.ly/capire/APIs#cds-compile)
const compile = (csn) => ({
  for:(x,o) => _fluent (compile_for,x, csn,o),
  to:(x,o) => _fluent (compile_to,x, csn,o),
})

function _fluent (compile_, to_or_for, csn, o) {
    let fn = compile_[to_or_for];  if (!fn)  throw new TypeError (`cds.compile.for.${to_or_for} is not defined`)
    if (typeof csn === 'string')  csn = cds.parse (csn)
    return fn (csn,o)
}


// Dedicated API, i.e. compile.for.sql('csn')
const compile_for = {
  odata: (csn, o) => cdsv.forOData(csn, o),
  sql: (csn, o) => cdsv.forSql(csn, o)
}


// Dedicated API, i.e. compile.to.yml('csn')
const compile_to = {
  json: x => JSON.stringify(x,null,'    '),
  yaml: YAML.stringify,
  yml: YAML.stringify,
  sql: (csn,o={}) => _2sqlOut(cdsv.toSql(_skipUnused(csn),o).sql,o),
  cdl: (csn,o={}) => _2structuredOut(cdsv.toCdl(csn,o),'.cds'),
  hana: (csn,o={}) => _many  (cdsv.toHana(_skipUnused(csn),toHanaOptions(o)).hdbcds, o, '.hdbcds'),
  edm: (csn,o={}) => _2odata (csn,o, 'metadata_json'),
  edmx: (csn,o={}) => _2odata (csn,o, {off: 'metadata', only: 'annotations'}[o.annos] || 'combined'),
  annos: (csn,o={}) => _2odata (csn,o, 'annotations'),
  swgr: (csn,o={}) => _many  (cdsv.toSwagger(csn,o).services, o, '.swgr.json'),
  // swgr: (csn,o={}) => { let x = cdsv.toSwagger(csn,o); return o.as ? compile.to[o.as=='str'?'yml':o.as](x) : x },
}

function _skipUnused (csn) {
  const m = cds.linked (csn)
  m.foreach (e => e instanceof cds.entity && !e.abstract && e['@cds.persistence.skip']=='if-unused', e => {
    let refs = 0;  m.foreach (a => a._target === e, (ref, [parent]) => {
      if (parent instanceof cds.entity)  ++refs
    })
    if (!refs) {
      delete csn.definitions [e.name]
      if (csn._xsn)  delete csn._xsn.definitions [e.name]
    }
  })
  return csn
}

const suffixes = {
  cdl: '.cds',
  yaml: '.yml',
  annos: '.annotations.xml',
  edmx: '.edm.xml',
  edm: '.edm.json',
  swgr: '.swgr.yml',
  hana: '.hdbcds',
}

function _many (hdbcds, o={}, _ext='.hdbcds') {
  const resultSize = Object.keys(hdbcds).length
  const generator = (function* () { //NOSONAR
    for (let name in hdbcds) {
      const filename = name.replace(/[.:/\\]/g, '_')
      yield [hdbcds[name], { name: filename, suffix: _ext }]
    }
    // Add an .hdinamespace file that prevents the gen/ dir to be appended as a namespace segment.
    // This would happen if the src/ dir above adds an .hdinamespace with 'subfolder:append'.  See issue #64.
    if (o.extraArtifacts && resultSize > 0) {
      yield [{ name: '', subfolder: 'ignore' }, { name: '.hdinamespace', suffix: '' }]
    }
  })()
  return generator
}

function _2structuredOut(result, suffix) {
  const generator = (function* () { //NOSONAR
    for (let name in result) {
      const filename = name.replace(/[.:/\\]/g, '_')
      yield [result[name], { name: filename, suffix }]
    }
  })()
  return generator
}

function _2sqlOut (obj, o) {
  const arr = []
  for (const key of Object.keys(obj)) {
    arr.push(obj[key].replace(/(;)$/, ''))
  }
  return (o.as === 'str') ? arr.reduce((p,n)=> p+n+'; \n\n','\n') : arr
}

/** Extracts requested outcomes from the all-in-one results obtained from cdsv.
 * E.g. for
 *
 * > _compile.to.edmx(csn,{service:'**A**','metadata'})_
 *
 * cdsv would return the like of
 * _{ **A**: { metadata:{...}, annotations:{...} }, **B**: {...}, ... }_
 *
 * Which we would return as
 * _{ **A**: {...} }_
 */
function _2odata (csn,o={}, requested) {
  if (!o.version && requested === 'edmx')  o.version = cds.env.odata.version
  o.json = (o.version !== 'v2');
  o.xml = o.combined = o.separate = true
  // REVISIT: Warum akzeptiert toOdataOutput kein zuvor erzeugtes Ergebnis von transform4OData?
  let allin1 = csn._odata; if (!allin1)  Object.defineProperty (csn, '_odata', {value:
    allin1 = cdsv.toOdata(csn, o),
    configurable:1, writable:1
  })
  if (!allin1 || !allin1.services)  throw new Error('No service definitions found')
  if (requested === 'csn')  return allin1.csn
  let services = allin1.services
  if (o.service === 'all')  return (function*(){ //NOSONAR
    for (let name in services)  yield [ _selectOutput (services[name][requested]), {name} ]
  })()
  if (!o.service) {
    let chosen = cds.reflect(csn).find (s => s['@cds.chosen.service'])
    if (chosen)  o.service = chosen.name
  }
  if (o.service) {
    for (let each in services) if (each.indexOf(o.service) >= 0)  return _selectOutput (services[each][requested])
    throw new Error (
      `[cds.compile.to.${requested}] - didn't find service definition matching ${o.service}`
    )
  }
  if (Object.keys(services).length > 1)  throw new Error (_choose_one())
  for (let each in services)   return _selectOutput(services[each][requested])

  function _selectOutput (out) {
    if (requested === 'metadata_json' && o.as === 'str')  return JSON.stringify(out)
    return out
  }

  function _choose_one(){
    return `[cds.compile.to.${requested}] - multiple service definitions in model:

    ${Object.keys(services).join('\n    ')}

  please choose one or all using --service all | <one of above> from the CLI
  or { service:'all' | <...> } from the API respectively.
  `
  }
}

function toHanaOptions(options) {
  const names = cdsv.sqlNamingOptions(options)
  return Object.assign({ toHana:{ names, associations: 'assocs' } }, options)
}


module.exports = Object.assign (compile, { to: compile_to, for: compile_for, suffixes })
