const cds = require ('../index')
const path = require ('path')
const fs = require ('fs')
const CSV = require ('../utils/csv')
const Properties = require('../utils/properties')

const conf = cds.env && cds.env.i18n || {}
const DefaultLanguage = conf.default_language || 'en'
const FallbackBundle = conf.fallback_bundle || ''
const I18nFolders = conf.folders || [ '_i18n', 'i18n' ]
const I18nFile = conf.file || 'i18n'
const CachedFolders = {}


module.exports = Object.assign (localize, {
  bundles4, folders4, folder4
})

const _been_here = Symbol('been here')
const debug = fn => process.env.DEBUG_I18N ? fn(console.warn) : ''

function* localize (model, /*with:*/ languages) {
  const all=[], _localize = (d,_) => { // eslint-disable-line
    if (d[_been_here])  return;  else d[_been_here] = true
    for (let p in d) {  // if (p[0] !== '@')  continue
      let v = d[p];  if (!v)  continue
      if (v.value) v = v.value  // FIXME 'augmented' CSN
      if (typeof v === 'object') { _localize(v); continue }
      if (typeof v !== 'string')  continue
      if (/{b?i18n>([^}]+)}/.test(v)) {
        const key = RegExp.$1,  left = RegExp.leftContext.trim(),  right = RegExp.rightContext.trim()
        all.push ((bundle) => {
          // FIXME 'augmented' CSN
          if (d[p].value)  d[p].value = bundle[key] || left || right || key
          else d[p] = bundle[key] || left || right || key
        })
      }
    }
  }
  cds.reflect(model) .foreach (_localize)

  // FIXME 'augmented' CSN
  if (model._xsn)  cds.reflect(model._xsn) .foreach (_localize)
  //   FIXME 2: The alternative below does not work as cdsv still
  //   refuses to process its own CSN output
  // delete model._xsn

  let bundlesSeen = 0
  let bundles = bundles4 (model, languages)
  for (let [lang,bundle] of bundles) {
    bundlesSeen++
    delete model._odata
    all.forEach (loc => loc (bundle))
    Object.defineProperty (model, '_bundle', {value: bundle, writable:true}) // for tests
    yield [model,{lang}]
  }

  // yield default model in case there was no bundles. Callers don't need to worry then.
  if (!bundlesSeen)  yield [model, { lang: '' }]
}

/**
 * Returns all property bundles, i.e. one for each available translation language,
 * for the given model.
 */
function* bundles4 (model, languages) {

  let folders = folders4 (model)
  if (folders.length === 0)  return //> no folders, hence no bundles found at all

  // if no languages are specified, use all available
  if (!languages || languages === '*' || languages === 'all') {
    // find all languages in all folders
    const files = folders
      .map (folder => fs.readdirSync(folder) .filter (e => e.startsWith(I18nFile)))
      .reduce ((files, file) => files.concat(file)) // flatten
    if (files.length === 0) {
      debug(log => log('No languages for folders:', folders))
      return {}
    }

    if (files[0].endsWith('.csv')) { // TODO search all folders
      // it's as .csv files...
      languages = CSV.read (path.join(folders[0],files[0]))[0].slice(1)
    } else {
      // it's as individual .properties files
      languages = files.map (f => f.slice (5,-11))
    }
  }

  // if languages are specified as string, split them into an array
  else if (typeof languages === 'string') {
    languages = languages.split(',')
  }
  languages = new Set(languages) // uniq langs
  debug(log => log('Languages:', languages))

  for (let lang of languages) {
    let bundle = _bundle4 (lang, folders)
    if (bundle) {
      debug(log => log(bundle.toString()))
      yield [ lang, bundle ]
    }
  }
}

/**
 * Returns the effective bundle stack for the given language and model folders.
 * Expected bundle stack for languages en and '' + 2 model layers:
    [en]   model/_i18n
      []   model/_i18n
        [en]   model/node_modules/reuse-model/_i18n
          []   model/node_modules/reuse-model/_i18n
 */
function _bundle4 (lang, folders) {
  let bundle = null
  let _folders = [...folders].reverse() // reverse folders to get reuse models first
  for (let each of _folders) {
    let current = loadBundleFrom (each, lang);  if (!current) continue
    if (lang !== FallbackBundle) {
      let b = loadBundleFrom (each, FallbackBundle);  if (!b) continue
      b.__proto__ = bundle  // put recent below fallback bundle
      bundle = b  // put fallback bundle below current one
    }
    if (lang !== DefaultLanguage) {
      let b = loadBundleFrom (each, DefaultLanguage);  if (!b) continue
      b.__proto__ = bundle  // put recent below default bundle
      bundle = b  // put default bundle below current one
    }
    current.__proto__ = bundle
    bundle = current
  }
  return bundle
}

/**
 * Returns an array of all existing _i18n folders for the models
 * that are merged into the given one..
 */
function folders4 (model) {
  // Order of model._sources is expected to be sorted along usage levels, e.g.
  //   foo/bar.cds
  //   foo/node_modules/reuse-level-1/model.cds
  //   foo/node_modules/reuse-level-2/model.cds
  if (!model._sources)  return []
  const folders=[];  for (let src of model._sources) {
    let folder = folder4 (src)
    if (!folder || folders.indexOf(folder) >= 0)  continue
    folders.push(folder)  // use an array here to not screw up the folder order
  }
  return folders
}

/**
 * Returns a the location of an existing _i18n folder next to or in the
 * folder hierarchy above the given path, if any.
 */
function folder4 (loc) {
  // already cached from a former lookup?
  if (loc in CachedFolders)  return CachedFolders [loc]
  // check whether a <loc>/_i18n extists
  for (let i18n of I18nFolders) if (fs.existsSync (path.join (loc, i18n))) {
    return CachedFolders[loc] = path.join (loc, i18n)
  }
  //> no --> search up the folder hierarchy
  let next = path.dirname(loc)
  return CachedFolders[loc] = !next || next === loc  ?  null  :  folder4(next)
}

const _lang = Symbol('lang')
const _dir = Symbol('dir')
function loadBundleFrom (folder, lang) {
  let langSuffix = lang === '' ? '' : '_' + lang
  let file = path.join (folder, I18nFile)
  let bundle = (
    // prefer .properties...
    Properties.read(file + langSuffix.replace('-','_')) ||  // e.g. en-UK --> en_UK
    Properties.read(file + langSuffix.match(/\w+/)) ||  // e.g. en_UK --> en
    Properties.read(file) ||  // // e.g. en_UK --> dev default bundle
    // ... if absent look for .csv files:
    loadFromCSV (file, lang)
  )
  if (bundle) {
    bundle[_lang] = lang
    bundle[_dir] = folder
    bundle.toString = (indent) => bundleToString(bundle, indent)
  }
  return bundle
}


function loadFromCSV (res, lang=DefaultLanguage) {
  let csv = CSV.read(res+'.csv'); if (!csv) return
  let [header, ...rows] = csv
  if (lang === '*') return header.slice(1).reduce ((all,lang,i) => {
    all[lang] = _bundle(i); return all
  },{})
  let col = header.indexOf (lang)
  if (col < 0)  col = header.indexOf ((lang.match(/\w+/)||[])[0])
  if (col > 0) return _bundle (col)
  function _bundle (col) {
    return rows.reduce ((all,row) => {
      if (row[col])  all[row[0]] = row[col]
      return all
    },{})
  }
}

function bundleToString(b, indent='') {
  let str = `\x1b[1m${indent}[${b[_lang]}]   ${path.relative(process.cwd(), b[_dir] || 'unknown')}\x1b[0m`
  Object.keys(b).filter(k => typeof b[k] === 'string').forEach(k => str += `\n  ${indent}\x1b[33m${k}\x1b[0m: ${b[k]}`)
  let proto = Object.getPrototypeOf(b)
  if (proto && proto[_lang] !== undefined)  str += ('\n' + bundleToString(proto, indent += '  '))
  return str
}


if (!module.parent) {
    process.chdir ('/SAP/cap/projects/ConsentManagementDev/model')
    require ('../../bin/compile') ([
        'service.annotationsConsentTemplate.cds',
        'consentTemplateService.cds',
        'ConsentTemplateModel.cds',
        'ConsentPurposeModel.cds',
        'ConsentModel.cds',
        'ConsentUtil.cds',
        'MiscModel.cds',
    ], {
        to: 'edmx',
        service: 'all',
        lang: 'all',
        dest: '_out'
    })
}

/* eslint no-console:off */