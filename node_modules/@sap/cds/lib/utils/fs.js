const path = require ('path')
const fs = require ('fs')

module.exports = {__proto__:fs,
    path, mkdirp, rimraf, rimrafSync, isdir, isfile, find, copy,
}


const rw = fs.constants.R_OK | fs.constants.W_OK

const copyFile = fs.copyFile || function (src, dst, callback) {
  const wr = fs.createWriteStream(dst) .on ('error',_cleanup) .on ('finish',_done)
  const rd = fs.createReadStream(src) .on ('error',_cleanup) .pipe (wr)
  function _cleanup(e) { rd.destroy(); wr.end(); callback(e) }
  function _done() { callback (undefined,dst) }
}


function mkdirp (p, done) {
	if (p)  fs.access (p, rw, _absent => {
		if (_absent)  mkdirp (path.dirname(p), ()=> fs.mkdir(p, ()=>done(p)))
		else  done(p)
	})
	else  done(p)
}

function copy (src, dst, _mkdirp) { return new Promise ((_done,_failed)=>{
    _mkdirp ?  mkdirp (path.dirname(dst), _copy) : _copy()
    function _copy() {
        if (isdir(src)) {
            if (!isdir(dst))  fs.mkdirSync (dst)
            return Promise.all (fs.readdirSync(src) .map (
                each => copy (path.join (src,each), path.join (dst,each)
            ))) .then (_done)
        }
        else {
            return copyFile (src, dst, e => e ? _failed(e) : _done())
        }
    }
})}

function rimraf (dir,ignore) { return new Promise ((_resolved,_error)=> {
    fs.readdir (dir, (e,files) => { if (e) return ignore ? _resolved() : _error(e)
        let n = files.length
        for (let each of files) {
            let child = path.join (dir,each)
            fs.lstat (child,(e,f)=>{ if(e) return _error(e)
                if (f.isDirectory())  rimraf(child).then (()=> --n || _rmdir())
                else  fs.unlink (child, (e) => e ? _error(e) : --n || _rmdir())
            })
        }
    })
    function _rmdir(){ fs.rmdir (dir, (e) => e ? _error(e) : _resolved()) }
})}

function rimrafSync (dir) {
    for (let each of fs.readdirSync(dir)) {
        let child = path.join (dir,each)
        if (isdir(child))  rimrafSync(child);
        else  fs.unlinkSync(child);
    }
    fs.rmdirSync(dir)
}

function isdir (x) {
    try {
        let ls = fs.lstatSync(x)
        return ls.isDirectory() && x || ls.isSymbolicLink() && isdir (
            path.join(x,'..',fs.readlinkSync(x))
        )
    } catch(e){/* ignore */}
}

function isfile (x) {
    try {
        let ls = fs.lstatSync(x)
        return ls.isFile() && x || ls.isSymbolicLink() && isfile (
            path.join(x,'..',fs.readlinkSync(x))
        )
    } catch(e){/* ignore */}
}

function find (base, patterns='*', filter=()=>true) {
    const files=[];  base = path.resolve(base)
    if (typeof patterns === 'string')  patterns = patterns.split(',')
    if (typeof filter === 'string')  filter = this[filter]
    patterns.forEach (pattern => {
        const star = pattern.indexOf('*')
        if (star >= 0) {
            const head = pattern.slice(0,star).replace(/[^/\\]*$/,'')
            const dir = path.join (base,head)
            if (isdir(dir)) {
                const [,suffix,tail] = /([^/\\]*)?(?:.(.*))?/.exec (pattern.slice(star+1))
                const prefix = pattern.slice(head.length,star)
                let entries = fs.readdirSync(dir) //.filter (_filter)
                if (prefix)  entries = entries.filter (e => e.startsWith(prefix));  if (!entries.length) return
                if (suffix)  entries = entries.filter (e => e.endsWith(suffix));  if (!entries.length) return
                let paths = entries.map (e=>path.join(dir,e))
                if (filter)  paths = paths.filter (filter);  if (!paths.length) return
                if (tail)  for (let _files of paths.map (e=>find (e,tail,filter)))  files.push (..._files)
                else  files.push (...paths)
            }
        } else {
            const file = path.join (base, pattern)
            if (fs.existsSync(file))  files.push (file)
        }
    })
    return files
}


if (!module.parent) {
    const [base,pattern,filter] = process.argv.slice(2)
    console.time('') // eslint-disable-line
    let found = module.exports.find (base,pattern,filter)
    console.timeEnd('') // eslint-disable-line
    console.log (found) // eslint-disable-line
}