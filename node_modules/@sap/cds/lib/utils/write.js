const fs = require('./fs'), {path}=fs

const write = module.exports = Object.assign (

	/** write (output) .to (filename) */
	(output) => ({ to: (dest, name, suffix, callback) => {

		let options = {}
		if (typeof name === 'function')  [name,suffix,callback] = [undefined,undefined,name]
		else if (typeof name === 'object')  options = name
		else if (typeof suffix === 'function')  [suffix,callback] = [undefined,suffix]

		// our inner writer function
		return (function _write (output, _etc) {

			// if the obtained output is a generator --> write each...
			if (output && output.next && output[Symbol.iterator]) {
				let all=[]; for (let [x,_etc] of output)  all.push (_write(x,_etc))
				return Promise.all(all)
			}
			// instead of a generator, output could be a single [out,etc] entry
			else if (Array.isArray(output) && output.length === 2 && output[0] && output[1]) {
				return _write(output[0], Object.assign(output[1], _etc))
			}

			// write to logger if no destination is given
			if (!dest || typeof dest === 'function') { // .write.to(console.log)
				const logger = dest || console.log
				if (_etc && !options.skipSeparator) { // separator if we are called with a multi-output
					logger ('-----', _etc, '-----')
				}
				return logger (output)
			}

			// construct the filename
			let file = dest, etc = _etc || {}
			if (etc.name)  file = path.join (file, etc.name) //.replace (/[:/\\]/g, '_') )
			else if (name)  file = path.join (file, name) //.replace (/[:/\\]/g, '_') )
			if (etc.lang)  file += '_'+ etc.lang
			if (etc.suffix !== undefined)  file += etc.suffix
			else if (suffix)  file += suffix
			else if (!/\.\w+$/.test(file))  file += '.json'

			// prepare the output string
			if (typeof output !== 'string')  output = JSON.stringify(output, null, 2)

			// and write it to the target destination, potentially creating folders
			return new Promise ((resolve, reject) => {
				fs.mkdirp (path.dirname(file), ()=> fs.writeFile (
					file, output, e => e ? reject(e) : resolve(file)
				))
			}) .then (callback)

		})(output)

	}}),

	{
		/** write.to (dest, src, ext) */
		to: (dest, name, ext, callback) => output => write (output) .to (dest,name,ext,callback)
	}
)




/* eslint no-console:off */