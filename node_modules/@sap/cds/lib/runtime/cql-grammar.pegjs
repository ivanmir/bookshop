{
  const $ = Object.assign
  function _join (join, left) {
    join.args[0] = left
    if (join.on && join.on.using) {
      const right = join.args[1],  s = left.as || left.ref[0],  r = right.as || right.ref[0],  _on=[]
      for (let c of join.on.using) 
        _on.push ( 'and', {ref:[ s, ...c.ref ]}, '=', {ref:[ r, ...c.ref ]} )
      join.on = _on.slice(1)
    }
    return join
  }
}

//--------------------------------------------------------------------------
// Start rules

  TEST = CQL / XPR
  CQL = o q:SELECT o {return q}
  XPR = o x:expr o {return x}


//--------------------------------------------------------------------------
// Queries

 
  SELECT
    = q:("SELECT"i !alpha {return {}})  (_"ALL"i/_"DISTINCT"i {q.distinct=true})? 
    (_ c:columns { q.columns=c })?  //> std sql projection clause
    (_"FROM"i_ s:source { q.from=s }) ( j:JOIN { q.from = _join(j,q.from) })*
    ( OPEN c:columns? CLOSE {q.columns=c})?  //> postfix projection clause
    (_"EXCLUDING"i OPEN ( x:qname {q.excluding=[x]} )( comma x:qname {q.excluding.push(x)} )* CLOSE )?
    (_"WHERE"i_ x:_xpr {q.where=x})?
    (_"GROUP BY"i_ ( x:expr {q.groupBy=[x]} )( comma x:expr {q.groupBy.push(x)} )* )?
    (_"HAVING"i_ x:_xpr {q.having=x})?
    (_"ORDER BY"i_ ( x:obyx {q.orderBy=[x]} )( comma x:obyx {q.orderBy.push(x)} )* )?
    (_"LIMIT"i_ ( x:expr {q.limit={rows:x}} ) ((_"OFFSET"i_/comma) x:expr {q.limit.offset=x})? )?
    {return {SELECT:q}}


  source = s:( subselect  /  ref:( head:qseg {return [head]} ) 
      ( colon ( s:pseg {ref.push(s)} ) 
        ( dot s:pseg {ref.push(s)} )*
      )? {return {ref}}
    ) (a:alias {s.as=a})? 
    {return s}


	JOIN 
    = join:(
      _"RIGHT"i (_"OUTER"i)? {return {join:'right'}}
      / _"LEFT"i (_"OUTER"i)? {return {join:'left'}}
      / _"FULL"i ("OUTER"i)? {return {join:'full'}}
      / _"OUTER"i {return {join:'full'}}
      / _"CROSS"i {return {join:'cross'}}
      / _"NATURAL"i {return {join:'natural'}}
      / (_"INNER"i  / "") {return {join:'inner'}}
    ) _"JOIN"i_ s:(s:source { join.args=[,s]; return s }) (
      _"USING"i_ cols:positional_args { join.on = {using:cols}} 
      / _"ON"i_ _xpr:_xpr { join.on=_xpr }
    )? {return join}
    / comma s:source {return { join:'cross', args:[,s] }}

  columns 
    = cols:(c:column {return[c]}) tail:(comma c:column {cols.push(c)})* 
    {return cols} 

	column 
    = "*" / !("FROM"i_) c:(
      "CAST"i LEFT x:expr _"AS"i_ (t:xref {x.cast={type:t}}) RIGHT (a:alias {x.as=a})? {return x} 
      / ref:path ".*" {return { ref, inline:['*'] }}
      / ref:path as:alias? i:dot? OPEN p:columns CLOSE  { return $({ ref, [i?'inline':'expand']:p }, as && {as}) }
      / x:expr (a:alias {x.as=a})? ( colon t:(redirected/xref) {x.cast={type:t}})? {return x}
    ){return c}

  obyx  = x:expr 
    (_ ad:("ASC"i / "DESC"i) {x.sort=ad.toLowerCase()} )? 
    (_"NULLS"i_ fl:("FIRST"i / "LAST"i) {x.nulls=fl.toLowerCase()} )? 
    {return x}

	alias "" = (as/_) !SQL_keyword n:name {return n}
	subselect = LEFT q:SELECT RIGHT {return q}
	redirected "" = "redirected to"_ t:qname {return {target:t}}


//--------------------------------------------------------------------------
// Expressions

  expr_or_literal  // returns values as literals and others as {xpr|ref|...}
    = x:expr { return x.val === undefined  ?  x  :  x.val }

  expr  // returns one of {val:...}, {ref:...} or {xpr:...}
    = xpr:_xpr { return xpr.length==1 ? xpr[0] : {xpr} }

    _xpr  //> internal rule to construct expressions as an array of operators and operands
      = CASE / LEFT _xpr:_xpr RIGHT {return ['(', ..._xpr, ')'] }
      / o:unary_operator o a:_xpr {return [o,...a]}
      / a:operand o"?:"o b:expr {return [{ func:'coalesce', args: [a,b] }]}
      / a:operand o"?"o b:expr o":"o c:expr {return [ 'case', 'when', a, 'then', b, 'else', c, 'end' ]}
      / a:operand o op:binary_operator o b:_xpr {return [a,op,...b]}
      / a:operand {return [a]}
    
  operand 
    = LEFT list:(x:expr {return [x]}) (comma x:expr {list.push(x)})* RIGHT {return {list}}
    / "?" {return {ref:['?'], param:true}}
    / ':' p:(name/anInteger) {return {ref:[p],param:true}} 
    / subselect
    / up:unparsed {return {xpr:[up]}}
    / ref:path {return {ref}}
    / val:Literal {return {val}}

  unary_operator "an operator" 
    = "-" !aNumber 
    / "+" !aNumber 
    / "~" 
    / "NOT"i !alpha {return 'not'}
    / "EXISTS"i !alpha {return 'exists'}
 	
  binary_operator "an operator" 
    = arithmetic_operator
    / comparison_operator
    / logic_operator
    / !SQL_keyword n:name {return n}
	    
  arithmetic_operator "an operator" 
    = "||" 
    / "&&" 
    / "+=" 
    / "-=" 
    / [*/%+-]

  comparison_operator "an operator" = 
    "==" / "=" / "!=" / "<>" / "<=" / ">=" / "<" / ">" 
    / o:( "eq"i/"ne"i/"lt"i/"gt"i/"le"i/"ge"i )!alpha {return o}
    / o:( "IS NOT"i/"NOT IN"i )!alpha {return o}
    / o:( "IS"i/"IN"i )!alpha {return o}
    / o:( "BETWEEN"i / "LIKE"i / "GLOB"i / "MATCH"i / "REGEXP"i )!alpha {return o}

  logic_operator "an operator" 
    = "AND"i !alpha {return 'and'}
    / "OR"i !alpha {return 'or'}
	
  CASE = o _xpr:("CASE"i !alpha {return ['case']}) 
    (_"WHEN"i_ w:expr _"THEN"i_ t:expr { _xpr.push ('when',w, 'then',t) })+ 
    (_"ELSE"i_ e:expr { _xpr.push ('else',e) })?
    _"END"i !alpha  { _xpr.push('end'); return _xpr} 

  // maybe_operator "an operator" = o op:$[:!|&~\?^]+ o {return op}

  
//--------------------------------------------------------------------------
// Path Expressions

	path "a path expression" 
    = p:( head:pseg {return [head]} ) ( dot tail:pseg {p.push(tail)} )* {return p}

	pseg 
    = id:name args:args? filter:filter? 
    {return args || filter ? $({id,args},filter) : id }

	qseg 
    = id:qname args:args? filter:filter? 
    {return args || filter ? $({id,args},filter) : id }

	filter 
    = BLEFT one:("1:")? o filter:( expr / "*" )? BRIGHT 
    {let f={filter}; if(one) f.cardinality={max:1}; return f}

  args 
    = LEFT a:( '*' / named_args / positional_args / ""{return[]} ) RIGHT 
    {return a}

  named_args 
    = args:(n:name colon v:expr_or_literal {return {[n]:v}}) 
    ( comma n:name colon v:expr_or_literal {args[n]=v} )* 
    {return args}

  positional_args 
    = head:expr_or_literal tail:(comma x:expr_or_literal {return x})* 
    {return [head, ...tail]}
  //

 
//--------------------------------------------------------------------------
// Names and References

  SQL_keyword 
    = ( "JOIN"i / "ON"i / "USING"i / "NATURAL"i / "CROSS"i / "LEFT"i / "RIGHT"i / "FULL"i / "OUTER"i / "INNER"i
    / "MIXIN"i / "FROM"i / "excluding"i / "WHERE"i / "HAVING"i / "GROUP BY"i / "ORDER BY"i 
    / "LIMIT"i / "OFFSET"i / "ASC"i / "DESC"i / "NOT"i  / "IN"i / "AS"i 
    / "CASE"i / "WHEN"i / "THEN"i / "ELSE"i / "END"i )_

  
  xref "a reference"   //> to other definitions -> 2b resolved to fqns
    =  c:":"? r:qname
    {return c?c+r:r}

  eref "a reference"  //> to elements with optional target prefix 
    = r:(qname ":")? e:qname
    {return r ? r[0] : e}


  name "a name" = $(![0-9]alpha+) / quoted 
	qname "a name" = q:qualified id:name { return q+id }
	qualified = all:( id:name dot { return id+'.' })* {return all.join('')}
  quoted = '"' i:$('""'/[^"])+ '"' { return i.replace(/""/g,'"') }
  alpha = [_$A-Za-z0-9]

  

//--------------------------------------------------------------------------
// Literals


  Literal 
    = aRecord
    / anArray
    / aScalar

  aScalar "a literal"
    = aSymbol
    / aNumber
    / aString
    / aDate
    / true 
    / false 
    / null  
  
  aRecord 
    = r:OPEN
    (k:$(qname("#"name)?) (colon v:(Literal/anExpression) {r[k]=v} /""{r[k]=true}) comma)* 
    (k:$(qname("#"name)?) (colon v:(Literal/anExpression) {r[k]=v} /""{r[k]=true}))? //last 
    CLOSE {return r}

  anArray 
    = a:BLEFT
    (x:(Literal/anExpression) comma {a.push(x)})* 
    (x:(Literal/anExpression) {a.push(x)})?  //last
    BRIGHT {return a}

  aSymbol // an enum symbol
    = "#" s:name 
    {return{'#':s}}
    
  aDate 
    = $(("datetime"/"timestamp"/"date"/"time") aString)
  
  aString 
    = ['] s:$("''"/[^'])* ['] 
    {return s.replace(/''/g,"'")}
  
  aNumber
    = x:$([-]?[0-9]+("."[0-9]+)?("e"[0-9]+)? )
    { return parseFloat(x) }
  
  anInteger 
    = x:$([-]?[0-9]+ )
    {return parseInt(x)}
  
	anExpression 
    = x:unparsed {return {'=':x}}
    / r:$(qname('@'qname('#'qname+)?)?) {return{'=':r}} 


  null  =  "null"i !alpha {return null}
  true  =  "true"i !alpha {return true} 
  false = "false"i !alpha {return false}    
  unparsed "(...)"  = "#(" u:$( unparsed / (![()] .)+ )* ")"o {return u}
  //> reads arbitrary input between balenced parenthesis
  

//--------------------------------------------------------------------------
// Punctuation


  OPEN "{" = o"{"o {return{/* can be filled in subsequently*/}}
  CLOSE "}" = o"}" {return}
  LEFT "(" = o"("o {return "("}
  RIGHT ")" = o")" {return ")"}
  BLEFT "[" = o"["o {return[/* can be filled in subsequently*/]}
  BRIGHT "]" = o"]" {return}
  colon "a colon" = o":"o {return ":"}
  comma "a comma" = o","o {return ","}
  dot "" = o"."o {return "."}
  eq "=" = o"="o {return "="}
  as = _"as"i_{return}



//--------------------------------------------------------------------------
// Whitespaces and Comments
 
 
  _ "" = $([ \t] / lf / Comment )+
  o "" = $([ \t] / lf / Comment )*
  lf "end of line" = [\n\r\u2028\u2029]

  Comment "comment" = InlineComment / LineEndComment 
  InlineComment = $( "/*" (!"*/" .)* "*/" ) 
  LineEndComment = $( ("//" / "--") (!lf .)* )


//--------------------------------------------------------------------------