/*USAGE:*/() => {
  const app = require('express')()
  cds.serve('all').in(app)  //> no subsequent .at() or .with() possible
  cds.serve('single').in(app).at('/mount-point').with(function ({Books}) {
    this.on('READ', Books, (cds) => cds.reply({}))
  })
}

module.exports = cds_serve
const cds = require('../index')
const path = require('path')
const lib = require('@sap/cds-services'); lib.inject(cds)

Object.defineProperties (cds.service||{}, {
  impl: {value: function cds_service_impl(fn){return fn} }, // dummy function to assist vscode typings-based IntelliSense
  for: {value: Object.defineProperty (lib.service, 'name', {value:'cds_service_factory'})},
  adapter: {value: {for: lib.to }},
  client: {value: {for: lib.for }},
})


/** Load given model(s) and construct providers for all defined services. */
function cds_serve (model, options={}) {

  const console = options.log || global.console
  if (model === 'all' || model[0] === 'all') {
    const _m = this.env.service.model
    model = _m ? cds.resolve(_m) : [ 'srv', 'services', '.' ].find (m => cds.resolve(m))
    if (!model)  throw new Error (`[cds] - \n
      No service models found in current working directory.
      Make sure you call cds.serve in the root of your project.
    `)
  }
  let ready = this.load(model) .then (_addProviders)
  const providers = []    //> filled by _addProviders when model is loaded

  return {
    // Fluent API to fill in options subsequently (= yet before model is loaded)
    to (protocol) {
      options.to = protocol
      return this
    },
    at (path) {
      options.at = path
      return this
    },
    with (impl) {
      options.with = impl
      return this
    },

    /** Add all providers as routers to the given express app */
    in (app) {
      this.then(() => {
        const ProtocolAdapter = {for:(
          options.to === 'odata' ? cds.service.adapter.for.odata_v4 :
          options.to === 'fiori' ? cds.service.adapter.for.odata_v4 :
          !options.to ? cds.service.adapter.for.odata_v4 :
          (()=>{ throw new Error (`service protocol ${options.to} is not supported`) })()
        )}
        for (let p of providers) {
          app.use (p.path, ProtocolAdapter.for(p))
        }
      })
      return this
    },

    /** Construct and launch an express app with the providers */
    listen() {
      let app = require('./server')
      return this.in(app) .then (app.run)
    },

    // Allow consumers to act subsequently
    then (next) { return ready = ready.then(next) },
    catch (err) { return ready = ready.catch(err) },
  }

  /**
   * Construct providers for all services defined in the loaded model.
   */
  function _addProviders (csn, o = options, n = 0) {
    console.log(`[cds] - loaded service definitions from\n\n  ${csn._sources.map(_local).join('\n  ')}\n`)
    cds.reflect(csn) .foreach (cds.service, def => {
      if (o.service && o.service != def.name || def['@cds.ignore']) return
      if ((o.at || o.with) && ++n > 1) throw new Error('You cannot specify `path` or `impl` for multiple services')
      const impl = _impl4(def, o.with)
      const service = cds.service.for (csn, {service: def.name, __proto__: o}, impl)
      const path = service.path = _path4(def, o.at)
      console.log (`[cds] - serving ${def.name} at ${path}${impl ? ' - impl: ' + _local(impl._source) : ''}`)
      providers.push (service)
      if (o.service)  return service
    })
  }
}

/**
 * Resolve a service implementation function as follows...
 * 1. if _impl is a function --> got it
 * 2. if _impl is a string --> `require (it)`
 * 3. if def is annotated with @impl --> `require (def@impl)`
 * 4. if we got the model's source --> `require (<basename>.js)`
 */
function _impl4 (def, _impl = def['@impl']) {
  let impl = _impl
  if (typeof impl === 'function') {
    return Object.defineProperty (impl, '_source', {value: impl.name || '<inline>'})
  } else if (!impl) { // find a service implementation adjacent to the source model file
    const _source = def['@source'] || def._location && def._location.filename
    if (!_source) return
    impl = path.resolve (_source.replace(/\.(cds|json|yaml)$/, '.js'))
    try { require(impl) } catch(e) {
      // REVISIT: should go away by deploying modules always from project root folder
      impl = path.resolve (_source.replace(/\.(cds|json|yaml)$/, '.js'))
    }
  } else {
    const fs = require('fs')
    if (def['@source'] && fs.existsSync(path.resolve(def['@source'], '..', impl))) {
      impl = path.resolve(def['@source'], '..', impl)
    } else {
      impl = path.resolve(impl)
    }
  }
  try { return Object.defineProperty (require(impl), '_source', {value: impl}) }
  catch (e) { if (_impl || e.code !== 'MODULE_NOT_FOUND') throw e }
}

function _path4 (def, _path) {
  return _path || def['@path'] || '/' + (
    /[^.]+$/.exec(def.name)[0].replace(/Service$/, '').replace(/^(.)/, c => c.toLowerCase())
  )
}

function _local (filename) { return path.relative('', filename) }

/* eslint no-console:off */