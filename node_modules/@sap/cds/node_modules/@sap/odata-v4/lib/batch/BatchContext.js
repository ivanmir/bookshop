'use strict';

/**
 * Stores information required for batch processing, similar to the Context class.
 */
class BatchContext {

    /**
     * Constructor
     *
     * @param {OdataRequest} incomingODataRequest Request received from the client
     * @param {OdataResponse} incomingODataResponse Response to be send to the client
     * @param {Service} service Service instance which should be used to execute the requests inside the batch request
     */
    constructor(incomingODataRequest, incomingODataResponse, service) {

        /**
         * OdataRequest wrapping the network request received by node.js
         * @type {OdataRequest}
         * @private
         */
        this._incomingODataRequest = incomingODataRequest;

        /**
         * OdataResponse wrapping the network response to be send by node.js
         * @type {OdataResponse}
         * @private
         */
        this._incommingODataResponse = incomingODataResponse;

        /**
         * Service instance
         * @type {Service}
         * @private
         */
        this._service = service;

        /**
         * Requests extracted from the batch requests multipart/mixed payload
         * @type {OdataRequestInBatch[]}
         * @private
         */
        this._requests = [];

        /**
         * Responses to be written into the batch response as part of multipart/mixed payload
         * @type {OdataResponseInBatch[]}
         * @private
         */
        this._responses = [];

        /**
         * ExecutionInfo, used by the execution info builder and the execution info processor to determine how
         * the requests inside the batch request are processed. This is just a data container to allow maximum
         * flexibility (e.g. may allow parallel execution of atomicity groups in future)
         * @type {Object}
         * @private
         */
        this._executionInfo = null;

        /**
         * Map containing the location header of the executed requests identified by the atomicity group and request id, used for content id referencing
         * @type {Map<string,Map<string,string>>}
         */
        this._locations = new Map();

        /**
         * Set containing all requests ids and atomicity group ids who have been executed without failure.
         * This list is used by the dependency check to check if all required requests are executed
         * As key the request id and the atomicity group id is used.
         * @type {Set<string>}
         * @private
         */
        this._executed = new Set();

        /**
         * Map containing for each atomicity group (identified by the atomicity group id) a list of BatchErrorInfo
         * instances to store which requests of the atomicity group have not been executed successfully.
         * @type {Map<string,BatchErrorInfo[]>}
         */
        this._failedRequestsPerAtomicityGroup = new Map();

        /**
         * Array containing error information of each failed request which is not inside an atomicity group
         * @type {BatchErrorInfo[]}
         */
        this._failedRequestsPerBatch = [];

        /**
         * Map contains the error object which caused an atomicity group to fail.
         * This might be also an error thrown by the application or an internal error
         * @type {Map<string,Error[]>}
         */
        this._failedAtomicityGroups = new Map();

        /**
         * Flag indicating if the batch processing should be continued after the first error
         * @type {boolean}
         * @private
         */
        this._continueOnError = this._incomingODataRequest.getPreferences().getOdataContinueOnError();

        /**
         * Boundary of the incoming batch request if multipart/mixed format is used. Used to create the response boundary.
         * @type {string}
         * @private
         */
        this._boundary = '';

        /**
         * Semantic of batch request {@see BatchContext.SEMANTIC}
         * @type {string}
         */
        this._semantic = '';
    }

    /**
     * Returns the batch request received from the client
     *
     * @returns {OdataRequest}
     */
    getRequest() {
        return this._incomingODataRequest;
    }

    /**
     * Returns the batch response to be send to the client
     *
     * @returns {OdataResponse}
     */
    getResponse() {
        return this._incommingODataResponse;
    }

    /**
     * Returns the odata service which is used to execute the requests inside the batch request
     *
     * @returns {Service} Service instance
     */
    getService() {
        return this._service;
    }

    /**
     * Adds a odata response to the responses list for this batch request
     *
     * @param {OdataResponseInBatch} oDataResponse Response
     */
    addResponseInBatch(oDataResponse) {
        this._responses.push(oDataResponse);
    }

    /**
     * Marks a request or atomicity group as executed
     *
     * @param {string} id Request id or atomicity group id
     */
    markIdAsExecuted(id) {
        this._executed.add(id);
    }

    /**
     * Check if a request has been
     *
     * @param {string} id Request id or atomicity group id
     * @returns {boolean}
     */
    isIdExecuted(id) {
        return this._executed.has(id);
    }

    /**
     * Store information of a failed request for an atomicity group
     *
     * @param {string} atomicityGroupId Atomicity group id
     * @param {BatchErrorInfo} batchErrorInfo Error information
     * @private
     */
    _markRequestAsFailedForAtomicityGroup(atomicityGroupId, batchErrorInfo) {
        let errorList = this._failedRequestsPerAtomicityGroup.get(atomicityGroupId);
        if (!errorList) {
            errorList = [];
            this._failedRequestsPerAtomicityGroup.set(atomicityGroupId, errorList);
        }
        errorList.push(batchErrorInfo);

        // also mark the whole atomicity group as failed, if the group is not alreaday marked as failed (e.g. due to
        // an error in the previous batched request)
        if (!this._failedAtomicityGroups.get(atomicityGroupId)) {
            this.markAtomicityGroupAsFailed(atomicityGroupId, batchErrorInfo);
        }
    }

    /**
     * If a batched request is processed with (status code  >= 400 && status code  < 600) this method is called to store the error information
     * The request is marked as failed and if the request belong to an atomicity group this group is also marked as failed
     * @param {BatchErrorInfo} batchErrorInfo
     */
    markRequestAsFailed(batchErrorInfo) {
        const atomicityGroup = batchErrorInfo.getRequest().getAtomicityGroupId();

        if (atomicityGroup) {
            this._markRequestAsFailedForAtomicityGroup(atomicityGroup, batchErrorInfo);
        } else {
            this._failedRequestsPerBatch.push(batchErrorInfo);
        }
    }

    /**
     * Mark an atomicity group as failed
     *
     * @param {string} atomicityGroupId Atomicity group ID
     * @param {Error} error Error
     */
    markAtomicityGroupAsFailed(atomicityGroupId, error) {
        this._failedAtomicityGroups.set(atomicityGroupId, error);
    }

    /**
     * Returns the map with failed atomicity groups
     *
     * @returns {Map<string,BatchErrorInfo|Error>}
     */
    getFailedAtomicityGroups() {
        return this._failedAtomicityGroups;
    }

    /*
     * Returns the failed requests of an atomicity group
     *
     * @param atomicityGroupId
     * @returns {OdataResponseInBatch} Erroneous request
     */
    getFailedRequestsOfAtomicityGroup(atomicityGroupId) {
        return this._failedRequestsPerAtomicityGroup.get(atomicityGroupId) || [];
    }


    /**
     * Returns the failed requests of the batch request which are not inside an atomicity group
     *
     * @returns {BatchErrorInfo[]}
     */
    getFailedRequestsOfBatchRequest() {
        return this._failedRequestsPerBatch;
    }

    /**
     * Check if a atomicity group has been executed
     * @param {string} id Atomicity group id
     * @returns {boolean}
     */
    isAtomicityGroupExecuted(id) {
        return this._failedRequestsPerAtomicityGroup.get(id) === undefined;
    }


    /**
     * Sets the list of odata requests which have been read from the batch request
     * @param {OdataRequestInBatch[]} requestsInBatch Requests collected by the batch multipart parsing
     * @returns {BatchContext} This instance
     */
    setRequestList(requestsInBatch) {
        this._requests = requestsInBatch;
        return this;
    }

    /**
     * Returns the list of OData requests which have been read from the batch request
     *
     * @returns {OdataRequestInBatch[]}
     */
    getRequestList() {
        return this._requests;
    }

    /**
     * Returns the list of OData responses for the batch response
     *
     * @returns {OdataResponseInBatch[]}
     */
    getResponseList() {
        return this._responses;
    }


    /**
     * Set the executionInfo, used by the execution info builder and the execution info processor to determine how
     * the requests inside the batch request are processed. This is just a data container to allow maximum
     * flexibility (e.g. allow parallel execution of atomicity groups)
     *
     * @returns {Array<Command>}
     */
    getExecutionInfo() {
        return this._executionInfo;
    }

    /**
     * Set the executionInfo, used by the execution info builder and the execution info processor to determine how
     * the requests inside the batch request are processed. This is just a data container to allow maximum
     * flexibility (e.g. allow parallel execution of atomicity groups)
     *
     * @param {Array<Command>} info Execution info
     * @returns {BatchContext}  This instance
     */
    setExecutionInfo(info) {
        this._executionInfo = info;
        return this;
    }

    /**
     * Set whether the batch request execution should be continued after an error
     *
     * @param {boolean} continueOnError  True: continue after error, false do not continue
     * @returns {BatchContext} This instance
     */
    setContinueOnError(continueOnError) {
        this._continueOnError = continueOnError;
        return this;
    }

    /**
     * Returns whether the batch request execution should be continued after an error
     *
     * @returns {boolean}
     */
    isContinueOnError() {
        return this._continueOnError;
    }


    /**
     * Set the boundary of the incoming batch request. Used to create the response boundary.
     *
     * @param {string} boundary
     * @returns {BatchContext} This instance
     */
    setBatchBoundary(boundary) {
        this._boundary = boundary;
        return this;
    }

    /**
     * Returns the boundary of the incoming batch request. Used to create the response boundary.
     *
     * @returns {string} boundary
     */
    getBoundary() {
        return this._boundary;
    }

    /**
     * Set the semantic for batch processing
     *
     * @param {BatchContext.SEMANTIC} semantic
     * @returns {BatchContext} This instance
     */
    setSemantic(semantic) {
        this._semantic = semantic;
        return this;
    }

    /**
     * Returns the semantic for batch processing
     *
     * @returns {BatchContext.SEMANTIC} semantic
     */
    getSemantic() {
        return this._semantic;
    }


    /**
     * Sets a location (e.g. from an create response)
     *
     * @param {string} atomicityGroup Atomicity group
     * @param {string} id Request ID
     * @param {string} location Location of the created or modified entity
     * @returns {BatchContext} This instance
     */
    addLocation(atomicityGroup, id, location) {
        let atomicityMap = this._locations.get(atomicityGroup);
        if (!atomicityMap) {
            atomicityMap = new Map();
            this._locations.set(atomicityGroup, atomicityMap);
        }

        atomicityMap.set(id, location);
        return this;
    }

    /**
     * Returns a location (e.g. from an create response)
     *
     * @param {string} atomicityGroup Atomicity group
     * @param {string} id
     * @returns {string}
     */
    getLocation(atomicityGroup, id) {
        const atomicityMap = this._locations.get(atomicityGroup);
        if (!atomicityMap) {
            return null;
        }

        return atomicityMap.get(id);
    }

    removeAtomicityGroup(atomicityGroupId) {
        let idsToBeRemoved = [];
        let responsesToBeRemoved = [];

        // collect all request's ids belonging to the given atomicity group id
        for (let request of this._requests) {
            if (request.getAtomicityGroupId() === atomicityGroupId) {
                idsToBeRemoved.push(request.getOdataRequestId());
            }
        }

        // collect all responces to be removed
        for (let response of this._responses) {
            if (response.getAtomicityGroupId() === atomicityGroupId) {
                responsesToBeRemoved.push(response);
            }
        }

        // remove affected request ids from executed list
        for (let id of idsToBeRemoved) {
            this._executed.delete(id);
        }

        // remove affected responses from responses list
        for (let response of responsesToBeRemoved) {
            const index = this._responses.indexOf(response);
            if (index !== -1) {
                this._responses.splice(index, 1);
            }
        }

        // remove atomicity group
        this._failedRequestsPerAtomicityGroup.delete(atomicityGroupId);
        this._failedAtomicityGroups.delete(atomicityGroupId);
    }

    /**
     * Returns the current logger instance.
     *
     * @returns {LoggerFacade} The current logger facade
     */
    getLogger() {
        return this._incomingODataRequest.getLogger();
    }
}


/**
 * Semantic of an batch request
 * MULTIPART means the Odata 4.0 batch semantic for multipart/mixed content type is used
 * JSON means the Odata 4.1 batch semantic for batch in application/json content type is used (not yet supported)
 * @type {{MULTIPART: string, JSON: string}}
 */


/**
 * @enum {string}
 * @type {{MULTIPART: string, JSON: string}}
 */
BatchContext.SEMANTIC = {
    MULTIPART: 'MULTIPART',
    JSON: 'JSON'
};

module.exports = BatchContext;
