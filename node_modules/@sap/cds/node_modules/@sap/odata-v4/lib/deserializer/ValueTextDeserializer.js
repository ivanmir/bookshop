'use strict';

const ValueConverter = require('../utils/ValueConverter');
const ValueValidator = require('../validator/ValueValidator');
const JsonContentTypeInfo = require('../format/JsonContentTypeInfo');
const EdmPrimitiveTypeKind = require('../edm/EdmPrimitiveTypeKind');
const DeserializationError = require('../errors/DeserializationError');
const validateThat = require('../validator/ParameterValidator').validateThat;
const INTEGER_VALIDATION = new RegExp('^[-+]?\\d{1,10}$');
const NUMBER_VALIDATION = new RegExp('^[-+]?[0-9]+(?:\\.[0-9]+)?(?:[Ee][-+]?\\d+)?$');

/**
 * Deserializes a provided payload containing a textual representation of a primitive value
 * into a Javascript object.
 */
class ValueTextDeserializer {

    /**
     * Creates an instance of ValueTextDeserializer.
     */
    constructor() {
        this._converter = new ValueConverter(new ValueValidator(),
            // The input is a string, so the parameter to expect the format according to IEEE754
            // can be set unconditionally.  This is needed, e.g., for large Int64 values.
            new JsonContentTypeInfo().addParameter(JsonContentTypeInfo.FormatParameter.IEEE754, 'true'));
    }

    /**
     * Converts a provided value into the appropriate Javascript value.
     * Available facets are taken into account.
     *
     * @param {EdmProperty} edmProperty the corresponding edm property
     * @param {string} propertyValue the string value of the primitive property
     * @returns {?(number|string|boolean|Buffer)} the primitive javascript value
     * @throws {DeserializationError} if the conversion was not successful
     */
    convertPrimitiveValue(edmProperty, propertyValue) {
        validateThat('edmProperty', edmProperty).truthy().typeOf('object');
        validateThat('propertyValue', propertyValue).truthy().typeOf('string');

        const type = edmProperty.getType();
        let value = propertyValue;
        if (type === EdmPrimitiveTypeKind.Binary) {
            value = Buffer.from(propertyValue);
        } else if (type === EdmPrimitiveTypeKind.Boolean) {
            if (propertyValue === 'true') value = true;
            if (propertyValue === 'false') value = false;
        } else if (type === EdmPrimitiveTypeKind.Int16
            || type === EdmPrimitiveTypeKind.Int32
            || type === EdmPrimitiveTypeKind.Byte
            || type === EdmPrimitiveTypeKind.SByte) {
            if (!INTEGER_VALIDATION.exec(propertyValue)) {
                throw new DeserializationError(`Wrong value for property '${edmProperty.getName()}'.`);
            }
            value = Number(propertyValue);
        } else if (type === EdmPrimitiveTypeKind.Single
            || type === EdmPrimitiveTypeKind.Double) {
            if (!NUMBER_VALIDATION.exec(propertyValue)) {
                throw new DeserializationError(`Wrong value for property '${edmProperty.getName()}'.`);
            }
            value = Number(propertyValue);
        }

        // The value converter asserts maxLength, scale, precision facets.
        try {
            this._converter.convert(edmProperty, value);
        } catch (error) {
            throw new DeserializationError(`Wrong value for property '${edmProperty.getName()}'.`, error);
        }

        return value;
    }
}

module.exports = ValueTextDeserializer;
