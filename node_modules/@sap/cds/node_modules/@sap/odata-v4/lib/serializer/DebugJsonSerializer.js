'use strict';

const validateThat = require('../validator/ParameterValidator').validateThat;
const packageJson = require('../../package.json');
const ExpressionVisitor = require('../utils/ExpressionVisitor');
const UriHelper = require('../uri/UriHelper');
const Expression = require('../uri/Expression');
const TransformationKind = require('../uri/apply/Transformation').TransformationKind;
const AggregateMethod = require('../uri/apply/AggregateExpression').StandardMethod;
const BottomTopMethod = require('../uri/apply/BottomTopTransformation').Method;
const RepresentationKind = require('../format/RepresentationKind');
const ContentTypes = require('../format/ContentTypeInfo').ContentTypes;
const HttpStatusCode = require('../http/HttpStatusCode');

class DebugJsonSerializer {

    /**
     * Creats an instance of the debug-view JSON serializer
     *
     * @param {Object} context - The OData context
     * @param {string} payload - The response body. It is the result of the previous serializer, referring either to data (e.g. metadata, service, entity collection, .. etc.) for successful request, or to an error (any).
     * @param {string} err - Error
     */
    constructor(context, payload, err) {
        validateThat('context', context).truthy().typeOf('object');

        this._context = context;
        this._payload = payload;
        this._error = err;
    }

    /**
     * Serializes the debug view and returns a stringified JSON object with the following structure:
     *      {
     *          request: {...},
     *          response: {...},
     *          context: {...},
     *      }
     *
     * @returns {string} - Stringified JSON object of the debug view
     */
    serialize() {
        const request = this._context.getRequest();
        const response = this._context.getResponse();

        let body = request.getBody() || '';
        if (request.getContract().getRepresentationKind() === RepresentationKind.Kinds.BATCH) body = '';

        let output = {
            request: {
                method: request.getMethod(),
                uri: request.getUrlObject().href,
                headers: request.getHeaders(),
                body
            },
            response: {
                headers: response.getHeaders(),
                status: {
                    code: response.getOriginalStatusCode(),
                    info: response.getStatusMessage() || HttpStatusCode.Texts[response.getOriginalStatusCode()]
                },
                body: this._payload
            },
            context: {
                uriInfo: null,
                requestRepresentationKind: request.getContract().getRepresentationKind(),
                responseRepresentationKind: response.getOriginalContract().getRepresentationKind()
            },
            server: {
                version: 'OData node.js library, v' + packageJson.version,
                environment: {
                    platform: process.platform,
                    arch: process.arch,
                    node: {
                        version: process.version
                    },
                    process: {
                        uptime: Math.trunc(process.uptime() / 60) + ' minutes'
                    }
                }
            },
            log: this._context.getLogger().getLog()
        };

        try {
            if (response.getOriginalContract().getContentTypeInfo().getMimeType() === ContentTypes.JSON) {
                output.response.body = JSON.parse(this._payload);
            }
        } catch (error) {
            // A possible error can be ignored if the payload is not in JSON.
            // The payload itself is already in the output.
        }

        try {
            output.context.uriInfo = this._buildUriInfo(request.getUriInfo());
        } catch (error) {
            this._error = error;
        }

        if (this._error) {
            output.server.stacktrace = this._collectErrorStacktrace(this._error, []);
        }

        const mainPm = this._context.getPerformanceMonitor();
        if (!mainPm.isNoOpMonitor()) {
            output.profile = mainPm.getResult();
        }

        return JSON.stringify(output);
    }

    /**
     * Build the error stacktrace recursive. If there is a getRootCause method and this methods
     * returns a root error the stack of the root error will be pushed to the stacktrace.
     *
     * @param {Error} error The error to build the stacktrace from.
     * @param {Array} stacktrace This array will be filled with the stacktrace.
     *                           Each element is a nested root error.
     * @private
     */
    _collectErrorStacktrace(error, stacktrace) {
        stacktrace.push(error.stack);
        if (error.getRootCause && error.getRootCause()) {
            let innerError = error.getRootCause();
            this._collectErrorStacktrace(innerError, stacktrace);
        }
        return stacktrace;
    }

    /**
     * Serializes the URI info object.
     *
     * @param {Object} uriInfo - The URI info
     * @returns {Object} - Serialized JSON object
     * @private
     */
    _buildUriInfo(uriInfo) {
        if (!uriInfo) return null;
        return {
            pathSegments: this._buildPathSegments(uriInfo.getPathSegments()),
            queryOptions: this._buildQueryOptions(uriInfo.getQueryOptions())
        };
    }

    /**
     * Prepare the provided resource-path segments for serialization.
     * @param {UriResource[]} segments
     * @returns {Array} the built segments prepared for serialization
     * @private
     */
    _buildPathSegments(segments) {
        return segments.map(segment => {
            let segmentResult = {
                kind: segment.getKind(),
                name: segment.getPathSegmentIdentifier()
            };

            this._buildKeyPredicates(segmentResult, segment.getKeyPredicates());
            this._buildNavProperty(segmentResult, segment.getNavigationProperty());
            this._buildProperty(segmentResult, segment.getProperty());
            return segmentResult;
        });
    }

    /**
     * Prepare the provided expression based query option for serialization.
     *
     * @param {Object} option The query option to build
     * @returns {Object} The built query option prepared for serialization
     * @private
     */
    _buildExpressionBasedQueryOption(option) {
        const context = {};

        new ExpressionVisitor()
            .on('visit', function visit(property, stack, currentContext, next) {
                if (property instanceof Expression) {
                    this.visitExpression(property, stack, currentContext, next);
                }
            })
            .visit(option, context);

        return context;
    }

    /**
     * Prepare the provided expand query option for serialization.
     * The preparation is done recursive for all available expands.
     *
     * @param {Object} $expand The query option to build
     * @returns {Object} The built query expand option prepared for serialization
     * @private
     */
    _buildExpandQueryOption($expand) {
        return $expand.map((expandItem) => {
            const context = {};

            const pathSegments = expandItem.getPathSegments();

            context.$expandPath = pathSegments.map(segment => {
                return {
                    kind: segment.getKind(),
                    name: segment.getPathSegmentIdentifier(),
                    type: segment.getEdmType().getFullQualifiedName().toString(),
                    isCollection: segment.isCollection()
                };
            });

            const $select = expandItem.getOption('$select');
            if ($select) {
                context.$select = this._buildSelectQueryOption($select);
            }

            const nextExpand = expandItem.getOption('$expand');
            if (nextExpand) {
                context.$expand = this._buildExpandQueryOption(nextExpand);
            }

            return context;
        });
    }

    /**
     * Prepare the provided select query option for serialization.
     *
     * @param {Object} $select The query option to build
     * @returns {string[]} The built query select option prepared for serialization
     * @private
     */
    _buildSelectQueryOption($select) {
        return $select.map(selectItem => {
            const pathSegments = selectItem.getPathSegments();
            if (pathSegments.length > 0) {
                return pathSegments.map(segment => segment.getPathSegmentIdentifier()).join('/');
            }

            if (selectItem.isAllOperationsInSchema()) {
                return selectItem.getAllOperationsInSchemaNamespace() + '.*';
            }

            return '*';
        });
    }

    /**
     * Prepare the provided orderby query option for serialization.
     *
     * @param {Object} $orderby The query option to build
     * @returns {Object} The built query orderby option prepared for serialization
     * @private
     */
    _buildOrderByQueryOption($orderby) {
        return $orderby.map(this._buildOrderByItem, this);
    }

    /**
     * Prepare the provided order-by item for serialization.
     * @param {OrderByItem} item
     * @returns {Object} the built order-by item prepared for serialization
     * @private
     */
    _buildOrderByItem(item) {
        return {
            nodeType: 'Orderby',
            sortOrder: item.isDescending() ? 'desc' : 'asc',
            expression: this._buildExpressionBasedQueryOption(item.getExpression())
        };
    }

    /**
     * Prepare the provided apply query option for serialization.
     *
     * @param {Transformation[]} apply the query option to build
     * @returns {Array} the built apply query option prepared for serialization
     * @private
     */
    _buildApplyQueryOption(apply) {
        return apply.map(transformation => {
            let result = {
                transformation: Object.keys(TransformationKind)
                    .find(name => TransformationKind[name] === transformation.getKind())
            };

            switch (transformation.getKind()) {
                case TransformationKind.AGGREGATE:
                    result.aggregate = transformation.getExpressions().map(this._buildAggregateExpression, this);
                    break;

                case TransformationKind.BOTTOM_TOP:
                    result.method = Object.keys(BottomTopMethod)
                        .find(name => BottomTopMethod[name] === transformation.getMethod());
                    result.number = this._buildExpressionBasedQueryOption(transformation.getNumber());
                    result.value = this._buildExpressionBasedQueryOption(transformation.getValue());
                    break;

                case TransformationKind.COMPUTE:
                    result.expressions = transformation.getExpressions().map(computeExpression => {
                        return {
                            expression: this._buildExpressionBasedQueryOption(computeExpression.getExpression()),
                            alias: computeExpression.getAlias()
                        };
                    });
                    break;

                case TransformationKind.CONCAT:
                    result.sequences = transformation.getSequences().map(this._buildApplyQueryOption, this);
                    break;

                case TransformationKind.CUSTOM_FUNCTION:
                    result.function = transformation.getFunction().getFullQualifiedName().toString();
                    if (transformation.getParameters()) {
                        result.parameters = transformation.getParameters().map(parameter => {
                            let parameterResult = { name: parameter.getEdmRef().getName() };
                            if (parameter.getText() !== undefined) parameterResult.value = parameter.getText();
                            if (parameter.getAlias()) parameterResult.alias = parameter.getAlias();
                            if (parameter.getAliasValue()) parameterResult.aliasValue = parameter.getAliasValue();
                            if (parameter.getExpression()) {
                                parameterResult.expression =
                                    this._buildExpressionBasedQueryOption(parameter.getExpression());
                            }
                            return parameterResult;
                        });
                    }
                    break;

                case TransformationKind.EXPAND:
                    result.expand = this._buildExpandQueryOption([transformation.getExpand()])[0];
                    break;

                case TransformationKind.FILTER:
                    result.filter = this._buildExpressionBasedQueryOption(transformation.getFilter());
                    break;

                case TransformationKind.GROUP_BY:
                    result.items = transformation.getGroupByItems().map(this._buildGroupByItem, this);
                    result.transformations = this._buildApplyQueryOption(transformation.getTransformations());
                    break;

                case TransformationKind.ORDER_BY:
                    result.items = this._buildOrderByQueryOption(transformation.getOrderByItems());
                    break;

                case TransformationKind.SEARCH:
                    result.search = this._buildExpressionBasedQueryOption(transformation.getSearch());
                    break;

                case TransformationKind.SKIP:
                    result.skip = transformation.getSkip();
                    break;

                case TransformationKind.TOP:
                    result.top = transformation.getTop();
                    break;

                default:
            }
            return result;
        });
    }

    /**
     * Prepare the provided aggregation expression for serialization.
     * @param {AggregateExpression} expression
     * @returns {Object} the built aggregation expression prepared for serialization
     * @private
     */
    _buildAggregateExpression(expression) {
        let result = { };
        if (expression.getPathSegments().length) {
            result.pathSegments = this._buildPathSegments(expression.getPathSegments());
        }
        if (expression.getExpression()) {
            result.expression = this._buildExpressionBasedQueryOption(expression.getExpression());
        }
        if (expression.getAlias()) result.alias = expression.getAlias();
        if (expression.getStandardMethod() !== null) {
            result.standardMethod = Object.keys(AggregateMethod)
                .find(name => AggregateMethod[name] === expression.getStandardMethod());
        }
        if (expression.getCustomMethod()) result.customMethod = expression.getCustomMethod().toString();
        if (expression.getFrom().length) {
            result.from = expression.getFrom().map(this._buildAggregateExpression, this);
        }
        if (expression.getInlineAggregateExpression()) {
            result.inlineAggregateExpression =
                this._buildAggregateExpression(expression.getInlineAggregateExpression());
        }
        return result;
    }

    /**
     * Prepare the provided group-by item for serialization.
     * @param {GroupByItem} item
     * @returns {Object} the built group-by item prepared for serialization
     * @private
     */
    _buildGroupByItem(item) {
        let result = { };
        if (item.getPathSegments().length) result.pathSegments = this._buildPathSegments(item.getPathSegments());
        if (item.isRollupAll()) result.isRollupAll = true;
        if (item.getRollup().length) result.rollup = item.getRollup().map(this._buildGroupByItem, this);
        return result;
    }

    /**
     * Prepare the provided query options for serialization.
     *
     * @param {Object} queryOptions The query options to build
     * @param {Object} queryOptions.$filter Odata $filter query options to build
     * @param {Object} queryOptions.$orderby Odata $orderby query options to build
     * @param {Object} queryOptions.$search Odata $search query options to build
     * @returns {Object} The built query options prepared for serialization
     * @private
     */
    _buildQueryOptions(queryOptions) {
        const result = Object.assign({}, queryOptions);

        if (queryOptions) {
            if (queryOptions.$apply) {
                result.$apply = this._buildApplyQueryOption(queryOptions.$apply);
            }

            if (queryOptions.$filter) {
                result.$filter = this._buildExpressionBasedQueryOption(queryOptions.$filter);
            }

            if (queryOptions.$orderby) {
                result.$orderby = this._buildOrderByQueryOption(queryOptions.$orderby);
            }

            if (queryOptions.$expand) {
                result.$expand = this._buildExpandQueryOption(queryOptions.$expand);
            }

            if (queryOptions.$search) {
                result.$search = this._buildExpressionBasedQueryOption(queryOptions.$search);
            }

            if (queryOptions.$select) {
                result.$select = this._buildSelectQueryOption(queryOptions.$select);
            }
        }

        return result;
    }

    /**
     * Build the debug output structure for a navigation property. The parameter _result will be
     * decorated.
     *
     * @param {Object} _result The object to decorate with navigation properties parameters.
     * @param {EdmNavigationProperty} navProp The navigation property.
     * @private
     */
    _buildNavProperty(_result, navProp, partnerCache) {
        if (!navProp) return;

        let result = _result;

        const localPartnerCache = partnerCache || [];

        result.entityType = navProp.getEntityType().getName();
        result.isCollection = navProp.isCollection();
        result.isNullable = navProp.isNullable();

        const partner = navProp.getPartner();
        if (partner) {
            result.partner = null;
            if (localPartnerCache.indexOf(partner) === -1) {
                localPartnerCache.push(partner);
                result.partner = { name: partner.getName() };
                this._buildNavProperty(result.partner, partner, localPartnerCache);
            }
        }

        const constraints = navProp.getReferentialConstraints();
        if (constraints && constraints.size > 0) {
            result.constraints = Array.from(constraints.values()).map(constraint => constraint.constraint);
        }
    }

    /**
     * Build the debug output structure for a given array of EdmKeyPropertyRef. The parameter
     * _result will be decorated with property 'keyPredicates' if keyPredicates are available.
     *
     * @param {Object} _result The object to decorate with entitySet properties parameters.
     * @param {EdmKeyPropertyRef[]} keyPredicates The array of EdmKeyPropertyRef.
     * @private
     */
    _buildKeyPredicates(_result, keyPredicates) {
        let resultPredicates = UriHelper.buildKeyPredicates(keyPredicates);
        for (let keyPredicate of resultPredicates) {
            keyPredicate.type = keyPredicate.type.toString();
        }

        if (resultPredicates && resultPredicates.length > 0) {
            let result = _result;
            result.keyPredicates = resultPredicates;
        }
    }

    /**
     * Build the debug output structure for a structural property.
     * The parameter _result will be decorated.
     *
     * @param {Object} _result object to decorate with the property's parameters
     * @param {EdmProperty} property structural property
     * @private
     */
    _buildProperty(_result, property) {
        if (!property) return;
        let result = _result;
        if (property.getType()) result.type = property.getType().toString();
        result.isCollection = property.isCollection();
        result.isNullable = property.isNullable();
    }
}

module.exports = DebugJsonSerializer;
