'use strict';

const fs = require('fs');
const path = require('path');

const APP_ROOT_PATH = path.dirname(__dirname).replace(/\\/g, '/');
const DEFAULT_CONFIG_PATH = path.resolve(__dirname, '../dependencies.json').replace(/\\/g, '/');

class ModuleCache {
    constructor() {
        this._dependencies = new Map();
        this._initialDependencies = new Map();

        // indicates whether the module cache has been initialized
        this._isInitialized = false;
    }

    /**
     * Creates JSON object representing dependencies configuration at the specified configPath
     * at the file system.
     *
     * @param {string} configPath - path to the file containing the dependencies configuration
     *
     * @returns {Object} configuration of dependencies. For example:
     *  {
     *    sinon: {
     *        path: 'sinon'
     *    },
     *    coreModule: {
     *        path: './lib/core/coreModule'
     *    },
     *    http: {
     *        path: 'http'
     *    }
     *  }
     */
    createConfig(configPath) {
        try {
            return JSON.parse(fs.readFileSync(configPath, 'utf8'));
        } catch (e) {
            throw new Error('Error while reading configuration file: ' + e.message);
        }
    }

    /**
     * Loads module with the specified dependencyName from the specified modulePath. In order to load
     * the module the specified modulePath will be passed as an input for the node.js require()
     * function.
     *
     * @param {string} dependencyName - name of the dependency as defined in the dependencies
     * configuration file
     * @param {string} modulePath - path, which should be used to load the module. It will be passed
     * as an input for node.js require function, i.e. it should follow all the corresponding rules
     * concerning module paths in node.js. In case a relative path is specified, it should be relative
     * to the application root path.
     *
     * @returns {Object} value of the module.exports property of the loaded module. i.e. result of the
     * invocation of the require() function for the module.
     */
    loadModule(dependencyName, modulePath) {
        let normalizedPath;

        if (!modulePath) {
            throw new Error('Module path must be specified');
        }

        normalizedPath = modulePath;
        if (normalizedPath.startsWith('.')) {
            normalizedPath = normalizedPath.replace('.', APP_ROOT_PATH);
        }

        try {
            return require(normalizedPath);  // eslint-disable-line global-require
        } catch (e) {
            throw new Error(`Dependency '${dependencyName}' could not be loaded: ${e.message}`);
        }
    }

    /**
     * Loads all the dependencies from the dependencies configuration file.
     *
     * @param {Object} config - object representing the configuration from the dependencies
     * configuration file.
     */
    loadDependencies(config) {
        for (let dependencyName of Object.keys(config)) {
            this._dependencies.set(dependencyName,
                this.loadModule(dependencyName, config[dependencyName].path));
        }
    }

    /**
     * Initializes the module cache. The method must be called only once during the application
     * life cycle. The further method calls will have no effect.
     *
     * @param {Object} config - configuration of the module cache. The specified object must have
     * 'path' property containing path to the JSON file containing the dependencies configuration. The
     * configuration file must contain a JSON object with the properties representing configuration for
     * all the required dependencies. For example:
     *  {
     *    "module1": {
     *        "path": "module1"
     *    },
     *    "module2": {
     *        "path": "./lib/some_folder/module2"
     *    }
     *    ...
     *  }
     *
     * In the example above, "module1" is a name of the dependency. This name should be later used to
     * lookup the dependency via the module cache. Value of the 'path' property must contain a path
     * to the required node module. The path must follow node.js conventions for module loading via the
     * require() function. In case a relative path is specified, it must be relative to the application
     * root folder.
     *
     * THIS METHOD IS USED FOR TESTING ONLY AND IS NOT INTENDED TO BE USED PUBLICLY.
     * @private
     */
    _init(config = { path: DEFAULT_CONFIG_PATH }) {
        if (this._isInitialized) {
            return;
        }

        if (!config || !config.path) {
            throw new Error("Configuration object with the 'path' property must be specified");
        }

        this.loadDependencies(this.createConfig(config.path));
        this._isInitialized = true;
    }

    /**
     * Registers the specified dependency for the specified dependencyName. In case dependency with the
     * specified name has already been configured in the module cache, it will be overridden.
     * The overridden dependency can be later restored using restore() function of the module cache.
     *
     * @param {string} dependencyName - name of the dependency.
     * @param {string | Object} dependency - either a path to the node module which should be loaded or
     * an object, which must be returned when the dependency is looked up.
     */
    register(dependencyName, dependency) {
        if (!dependencyName || !dependency) {
            throw new Error('Dependency and its name must be specified');
        }

        // if a dependency for the specified name has already been defined, store its initial value to
        // be able to restore it later
        if (this._dependencies.has(dependencyName)) {
            this._initialDependencies.set(dependencyName, this._dependencies.get(dependencyName));
        }

        this._dependencies.set(dependencyName,
            typeof dependency === 'string' ? this.loadModule(dependencyName, dependency) : dependency);
    }

    /**
     * Restores an overridden dependency with the specified dependencyName.
     *
     * @param {string} dependencyName - name of the dependency
     */
    restoreDependency(dependencyName) {
        if (!this._dependencies.has(dependencyName)) {
            throw new Error(`Dependency with '${dependencyName}' name has not been found`);
        }

        // check whether the dependency has been overridden
        if (!this._initialDependencies.has(dependencyName)) {
            return;
        }

        this._dependencies.set(dependencyName, this._initialDependencies.get(dependencyName));
        this._initialDependencies.delete(dependencyName);
    }

    /**
     * Restores the dependency(ies), which has been overridden by calling the register() function.
     *
     * @param {string} [dependencyName] - name of the dependency, which should be restored. In case no
     * value is specified for the parameter, all the overridden dependencies will be restored.
     */
    restore(dependencyName) {
        if (dependencyName) {
            this.restoreDependency(dependencyName);
        } else {
            for (let initialDependencyName of this._initialDependencies.keys()) {
                this._dependencies.set(initialDependencyName, this._initialDependencies.get(initialDependencyName));
                this._initialDependencies.delete(initialDependencyName);
            }
        }
    }

    /**
     * Returns dependency with the specified dependencyName. If there is no dependency with the
     * specified name, the method throws an Error.
     *
     * @param {string} dependencyName - name of the dependency, which should be returned
     *
     * @returns {Object} either module.exports object of the dependency module or an object, which has
     * been registered for the dependency via register() function of the module cache.
     */
    lookup(dependencyName) {
        if (!dependencyName) {
            throw new Error('Dependency name must be specified');
        }

        // explicitly throw an error to prevent an illusion that undefined/null is registered for the
        // dependency
        if (!this._dependencies.has(dependencyName)) {
            throw new Error(`Dependency with '${dependencyName}' name has not been found`);
        }

        return this._dependencies.get(dependencyName);
    }

    /**
     * THIS METHOD IS USED FOR TESTING ONLY AND IS NOT INTENDED TO BE USED PUBLICLY.
     * @private
     */
    _reset() {
        this._dependencies = new Map();
        this._initialDependencies = new Map();
        this._isInitialized = false;
    }
}

const moduleCache = new ModuleCache();

module.exports = moduleCache;

// Explicitly call the init() function to initialize the module cache; must be done after export declaration.
moduleCache._init();
