'use strict';

const moduleCache = require('../ModuleCache');
const MetadataCache = require('../utils/MetadataCache');
const validateThat = require('../validator/ParameterValidator').validateThat;
const IllegalArgumentError = require('../errors/IllegalArgumentError');
const ServiceResolutions = require('./ServiceResolutions');
const CommandFactory = require('../invocation/CommandFactory');
const CommandExecutor = require('../invocation/CommandExecutor');
const RepresentationKinds = require('../format/RepresentationKind').Kinds;
const PerformanceMonitorFactory = require('../utils/PerformanceMonitor').PerformanceMonitorFactory;
const LoggerFacade = require('../logging/LoggerFacade');
const DebugLogger = require('../logging/DebugLogger');
const ConfigurationError = require('../errors/ConfigurationError');

const IS_DEBUG_REGEXP = new RegExp('[?&]odata-debug=(?:json|html)(?:&|$)');
const IS_PROFILING_REGEXP = new RegExp('[?&]odata-profile=true(?:&|$)');

/**
 * The Service is the main service class where all service components must be registered.
 * This service is the main public api used by the service developer.
 */
class Service {

    /**
     * Constructor.
     * @param {EdmProvider} edmProvider the entity data model
     */
    constructor(edmProvider) {
        validateThat('edmProvider', edmProvider).truthy().typeOf('object');

        this._edmProvider = edmProvider;

        // Do not load ComponentManager with require because of inner dependencies and testing.
        const ComponentManager = moduleCache.lookup('ComponentManager');
        this._componentManager = new ComponentManager();

        // Do not load FormatManager with require because of inner dependencies and testing.
        const FormatManager = moduleCache.lookup('FormatManager');
        this._formatManager = new FormatManager();
        this._bodyParserManager = new FormatManager();

        this._basePath = '';
        this._loggerFacade = null;

        this._metadataCache = null;
        this._metadataETag = null;
    }

    /**
     * Get the EDM.
     * @returns {Edm}
     */
    getEdm() {
        return this._edmProvider;
    }

    /**
     * Get the FormatManager.
     * @returns {FormatManager}
     */
    getFormatManager() {
        return this._formatManager;
    }

    /**
     * (Creates) and returns an instance of MetadataCache to cache mimeType and locale specific metadata documents
     * @returns {MetadataCache}
     * @private
     */
    _getMetadataCache() {
        if (!this._metadataCache) {
            this._metadataCache = new MetadataCache();
        }
        return this._metadataCache;
    }

    /**
     * Returns the base path of the current odata service.
     * The base path is the part of the URL not belonging to OData
     * which means that this part of the URL will not be interpreted as an OData resource.
     *
     * @returns {string} The base path of the url.
     */
    getBasePath() {
        return this._basePath;
    }

    /**
     * Sets the base path of the URL.
     * The OData resource URL starts after this base path and will be interpreted as an OData resource.
     * @param {string} basePath The base path of the url.
     * @returns {Service} This instance of odata service.
     * @throws {ConfigurationError} If the provided basePath is not null and does not end with '/'
     */
    setBasePath(basePath) {
        if (basePath != null && !basePath.endsWith('/')) {
            throw new ConfigurationError("Provided base path must end with '/'");
        }
        this._basePath = basePath;
        return this;
    }

    /**
     * Registers a event listener by its name.
     * The names are not arbitrary. Currently only the following events are supported:
     * General listeners: request, error, debug
     * CRUD listeners: create, read, update, delete
     * Batch listeners: batch-start, batch-end, atomicity-group-start, atomicity-group-end
     * @param {string} eventName The name of the listener.
     * @param {Object} eventListener the listener to register.
     * @returns {Service} Instance of this service.
     */
    on(eventName, eventListener) {

        const supportedEvents = [
            'request', 'error', 'debug', 'create', 'read', 'update', 'delete',
            'atomicity-group-start', 'atomicity-group-end', 'batch-start', 'batch-end'
        ];
        let eventNameLower = eventName.toLowerCase();
        if (supportedEvents.indexOf(eventNameLower) <= -1) {
            throw IllegalArgumentError.createForIllegalValue('eventName', ...supportedEvents);
        }
        validateThat('eventListener', eventListener).typeOf('function');

        this.getComponentManager().use(eventName, eventListener);
        this.getLogger().info('Register listener for ' + eventName);
        return this;
    }

    /**
     * Registers a service component by its name. The names are not arbitrary. They must be used
     * from /lib/core/ComponentManager.Components.
     *
     * @param {string} name The name of the component.
     * @param {*} component the component to register.
     * @returns {Service} Instance of this service.
     */
    use(name, component) {
        this.getLogger().info('Register component ' + name);
        this.getComponentManager().use(name, component);
        return this;
    }

    /**
     * Registers a logger. Occurring log events will be sent to this logger instance.
     *
     * @param {Object} logger The root logger
     * @param {Function} logger.debug The debug function called with string
     * @param {Function} logger.path The path function called with string
     * @param {Function} logger.info The info function called with string
     * @param {Function} logger.warning The warning function called with string
     * @param {Function} logger.error The error function called with string
     * @param {Function} logger.fatal The fatal function called with string
     * @param {Function} formatter Formatter to be used to convert
     * @returns {Service} Instance of this service.
     */
    log(logger, formatter) {
        this._loggerFacade = new LoggerFacade(logger).setFormatter(formatter);
        this._componentManager.use(moduleCache.lookup('ComponentManager').Components.LOGGER, this._loggerFacade);
        return this;
    }

    /**
     * Returns the component manager.
     * The component manager manages all registered components within the library.
     *
     * @returns {ComponentManager} The component manager
     */
    getComponentManager() {
        return this._componentManager;
    }

    /**
     * Sets the supported odata version.
     *
     * @param {string} version - The supported odata version.
     * @returns {Service}
     */
    setOdataVersion(version) {
        this._odataVersion = version;
        this.getLogger().info('Set OdataVersion to ' + version);
        return this;
    }

    /**
     * Returns the supported odata version.
     *
     * @returns {string}
     */
    getOdataVersion() {
        return this._odataVersion;
    }

    /**
     * Sets the distinct etag for the metadata document
     *
     * @param {string} etag the etag for the metadata document
     * @returns {Service} Instance of this service.
     */
    setMetadataEtag(etag) {
        this._metadataETag = etag;
        return this;
    }

    /**
     * Returns the distinct etag for the metadata document
     *
     * @returns {?string} the etag for the metadata document
     */
    getMetadataEtag() {
        return this._metadataETag;
    }

    /**
     * Returns the current logger
     *
     * @returns {Logger} The current logger instance
     */
    getLogger() {
        return this._loggerFacade;
    }

    /**
     * Processes a request. This is the main starting point to use this library.
     *
     * @param {http.IncomingMessage|PlainHttpRequest} request The request to process.
     * @param {http.ServerResponse|PlainHttpResponse} response The response to process.
     * @returns {Promise}
     */
    process(request, response) {
        const logger = this.getLogger();
        logger.path('Entering Service.process()...');

        // Check if odata-dabug=json|html is part of the request url
        const isDebugRequested = IS_DEBUG_REGEXP.test(request.url);
        const isProfiling = isDebugRequested || IS_PROFILING_REGEXP.test(request.url);

        logger.debug('Debug mode requested: ' + isDebugRequested);
        logger.debug('Profiling requested: ' + isProfiling);

        const rootPerformanceMonitor = PerformanceMonitorFactory.getInstance(isProfiling).start();

        logger.info('Start processing request ' + request.method + ' ' + request.url);
        logger.debug('Using odata base path: ' + this.getBasePath());

        const Context = moduleCache.lookup('Context');

        let context;
        let errorFromDebugHandler = null;
        let isDebug = false;

        return Promise.resolve()
            .then(() => {
                // This Promise handles the setup of the context object.
                return new Promise(resolve => {
                    const serviceResolutionFn = ServiceResolutions.viaBasePath(this.getBasePath(),
                        !!request._batchInfo);

                    context = new Context(request, response, this, serviceResolutionFn);
                    context.setPerformanceMonitor(rootPerformanceMonitor);
                    context.setLogger(isDebugRequested ? new DebugLogger(logger) : logger);
                    context.getRequest().setService(this);
                    logger.debug('Request headers: ', context.getRequest().getHeaders());
                    resolve();
                });
            })
            .then(() => {
                // In this Promise, the debug handler gets called and the debug information gets evaluated.
                return new Promise((resolve) => {
                    const debugHandler = this.getComponentManager().getComponent('debug');
                    if (debugHandler) {
                        const next = error => {
                            if (error) {
                                logger.error('Error occurred: ' + error.message);
                                logger.debug('Error stacktrace: ' + error.stack);
                                errorFromDebugHandler = error;
                                return resolve();
                            }

                            // Check whether debug mode is allowed by the application (default is false) and
                            // if debug was requested. Only if both are true the request will be executed in debug mode
                            isDebug = context.getRequest().getContract().isDebug() && isDebugRequested;
                            context.getRequest().getContract().enableDebugMode(isDebug);
                            if (isDebug) {
                                context.getResponse().setBuffered(true);
                            }
                            logger.info('Component: \'debug\' was called. Debugging is: ' +
                                `${isDebug ? 'enabled' : 'disabled'} for the request`);
                            return resolve();
                        };

                        // Debug handler gets called here, with the next callback declared above
                        debugHandler(context.getRequest(), context.getResponse(), next);
                    } else {
                        resolve();
                    }
                });
            })
            .then(() => {
                // This Promise handles the creation and execution of the command chain.
                const options = {
                    context,
                    componentManager: this._componentManager,
                    formatManager: this._formatManager,
                    bodyParserManager: this._bodyParserManager,
                    isDebug: isDebug,
                    isProfiling
                };
                const successCommands = CommandFactory.createForSingleRequest(options);
                const errorCommands = CommandFactory.createForSingleRequestError(options);

                const executor = new CommandExecutor(context.getLogger(), rootPerformanceMonitor);
                return new Promise((resolve, reject) => {
                    const endCallback = err => {
                        if (err) {
                            logger.error('Error occurred: ' + err.message);
                            logger.debug('Error stacktrace: ' + err.stack);
                            rootPerformanceMonitor.stop();
                            return reject(err);
                        }

                        logger.info('Request processing finished');
                        rootPerformanceMonitor.stop();
                        return resolve();
                    };
                    executor.execute(successCommands, errorCommands, errorFromDebugHandler, endCallback);
                });
            });
    }

    /**
     * Registers a serializer needed to serialize the result data into the response.
     * @param {RepresentationKind.Kinds} representationKind Kind of request like 'metadata' or 'resource'.
     * @param {string} contentType Requested content type like 'application/json'.
     * @param {Function} serializerFunction The function which will be called on serialization.
     * @param {Function} [parameterCheckFunction] the function to check the format parameters
     * @returns {Service} This instance of service.
     */
    format(representationKind, contentType, serializerFunction, parameterCheckFunction) {
        return this._registerDeserializer(this._formatManager,
            representationKind, contentType, serializerFunction, parameterCheckFunction);
    }

    /**
     * Registers a body parsing facade. This facade is responsible for parsing/deserializing the request
     * payload.
     *
     * @param {RepresentationKind.Kinds} representationKind The corresponding representation kind
     * @param {ContentTypeInfo.ContentTypes} contentType The corresponding content type
     * @param {Function} deserializerFunction The deserialization facade to register
     * @returns {Service} This instance
     */
    parse(representationKind, contentType, deserializerFunction) {
        return this._registerDeserializer(this._bodyParserManager,
            representationKind, contentType, deserializerFunction);
    }

    /**
     * Registers a provided deserializer function at its format manager in dependency of the corresponding
     * representation kind and content type
     *
     * @param {FormatManager} manager The corresponding manager
     * @param {RepresentationKind.Kinds} representationKind The corresponding representation kind
     * @param {ContentTypeInfo.ContentTypes} contentType The corresponding content type
     * @param {Function} parserFunction The parser facade to register
     * @param {?Function} parameterCheckFunction the function to check the format parameters
     * @returns {Service} This instance
     * @private
     */
    _registerDeserializer(manager, representationKind, contentType, parserFunction, parameterCheckFunction) {
        if (representationKind !== RepresentationKinds.NO_CONTENT) {
            validateThat('contentType', contentType).notNullNorUndefined().typeOf('string');
        }
        validateThat('serializerFunction', parserFunction).truthy().typeOf('function');

        manager.use(representationKind, contentType, parserFunction, parameterCheckFunction);

        return this;
    }
}

module.exports = Service;
