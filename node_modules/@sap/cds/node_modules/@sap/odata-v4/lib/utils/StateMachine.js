'use strict';

/**
 * A state machine processing states
 */
class StateMachine {

    /**
     * Creates an instance of StateMachine.
     *
     * @param {Object} stmContext The state machine context
     * @param {LoggerFacade} logger Any logger
     */
    constructor(stmContext, logger) {
        this._stmContext = stmContext;
        this._listeners = new Map();
        this._error = null;
        this._isFinal = false;
        this._history = [];
        this._nextStateParams = [];
        this._logger = logger;
    }

    /**
     * Returns the processing history of the state machine.
     *
     * @returns {Object[]} Array of states
     */
    getHistory() {
        return this._history;
    }

    /**
     * Returns true if the state machine is in final state
     *
     * @returns {boolean} true or false
     */
    isFinal() {
        return this._isFinal;
    }

    /**
     * Registers a listener which is called on each state.
     *
     * @param {string} name The name of the listener
     * @param {Function} listener The listener
     * @returns {StateMachine} This instance
     */
    on(name, listener) {
        this._listeners.set(name, listener);
        return this;
    }

    /**
     * Runs the current state and starts with the one identified by name.
     *
     * @param {string} name Name of start state
     * @param {any} nextStateParams Parameter of the naxt state
     * @returns {boolean} True if statemachine is not in final state
     */
    next(name, ...nextStateParams) {
        this._logger.path(`Entering StateMachine.next(${name}, ...params)`);
        this._logger.debug('Current state history: ', this._history);

        if (this.isFinal() || this._error) {
            return false;
        }

        if (name != null) {
            this._currentState = this._getState(name);
            this._assertStateExists(this._currentState, name);
        }

        this._nextStateParams = this._nextStateParams.concat(nextStateParams);

        const next = (error, nextStateName, ...currentParams) => {

            if (error) {
                this._error = error;
                this._executeListener('error', error);
                return;
            }

            if (nextStateName == null) {
                this._isFinal = true;
                return;
            }

            this._currentState = this._getState(nextStateName);
            this._assertStateExists(this._currentState, nextStateName);

            this._nextStateParams = currentParams;
            return;
        };

        if (this._currentState) {
            const stateTemp = this._currentState;
            const params = this._nextStateParams;

            this._logger.debug(`Execute state: ${stateTemp.name} with params: `, stateTemp, params);

            stateTemp.state(next, ...params);

            this._executeListener(stateTemp.name);
            this._history.push(stateTemp);
            return true;
        }

        return false;
    }

    /**
     * Asserts that the state exists.
     *
     * @private
     * @param {Object} state The current state
     * @param {string} name The name of the state
     */
    _assertStateExists(state, name) {
        if (state == null) {
            const history = this.getHistory().map(stateElem => stateElem.name).join(', ');
            throw new Error(
                `Runtime error in StateMachine. State '${name}' does not exist. History was '${history}'`
            );
        }
    }

    /**
     * Executes a listener.
     *
     * @private
     * @param {string} name The name of the listener
     * @param {any} params Any params to provide
     */
    _executeListener(name, ...params) {
        const listener = this._getListener(name);
        if (listener) {

            this._logger.debug(`Execute state listener ${name} with params: `, params);
            listener(...params);
        }
    }

    /**
     * Finds a state by its name.
     *
     * @private
     * @param {string} name The name of the state
     * @returns {Object} The state found or null
     */
    _getState(name) {
        const state = this._stmContext[name];
        if (state) {
            return { name, state };
        }
        return null;
    }

    /**
     * Return the listener found by its name.
     *
     * @private
     * @param {string} name The name of the listener
     * @returns {Function} The listener found or null
     */
    _getListener(name) {
        return this._listeners.get(name);
    }
}

module.exports = StateMachine;
