'use strict';

const crypto = require('crypto');
const LeastRecentlyUsedStrategy = require('./LeastRecentlyUsedStrategy');

class MetadataCache {

    constructor() {
        this._cachedMetadata = new Map();

        /**
         * @type {AbstractCachingStrategy}
         */
        this._cachingStrategy = new LeastRecentlyUsedStrategy();
    }

    /**
     * Retrieves a cached metadata document for a specific mimeType and locale
     * @param {string} mimeType The mimeType the metadata should be retrieved for
     * @param {string} locale The locale the metadata should be retrieved for
     * @returns {?Object} The cached metadata or null, if none was found in the cache
     */
    get(mimeType, locale) {
        const metadataInformation = this._getMimeTypeCache(mimeType).get(locale);
        if (metadataInformation) metadataInformation.time = Date.now();
        return metadataInformation || null;
    }

    /**
     * Sets a metadata-document for the given mimeType and locale in the cache
     * @param {string} mimeType The mimeType of the metadata-document
     * @param {string} locale The locale of the metadata-document
     * @param {string} metadata The metadata-document to be cached
     */
    set(mimeType, locale, metadata) {
        const metadataSize = this._getStringSizeKilobyte(metadata);
        const metadataInformation = {
            time: Date.now(),
            size: metadataSize,
            etag: this._getEtag(metadata),
            metadata: metadata
        };
        const mimeTypeCache = this._getMimeTypeCache(mimeType);
        // Set the newest entry
        mimeTypeCache.set(locale, metadataInformation);

        // Remove items as long as the boundary is exceeded
        while (this._cachingStrategy.exceedsBoundary(mimeTypeCache)) {
            this._clear(mimeType, this._cachingStrategy.invalidateItem(mimeTypeCache));
        }
    }

    /**
     * Clears a single cache entry for a given mimeType and locale
     * @param {string} mimeType The mimeType of the entry that shall be deleted
     * @param {string} locale The locale of the entry that shall be deleted
     */
    _clear(mimeType, locale) {
        this._getMimeTypeCache(mimeType).delete(locale);
    }

    /**
     * (Creates) and returns the Map that holds locale specific for the requested mimeType
     * @param {string} mimeType The mimeType the Map should be retrieved for
     * @returns {Map} Map that holds locale specific metadata-documents
     * @private
     */
    _getMimeTypeCache(mimeType) {
        let cacheByMimeType = this._cachedMetadata.get(mimeType);
        if (!cacheByMimeType) {
            cacheByMimeType = new Map();
            this._cachedMetadata.set(mimeType, cacheByMimeType);
        }
        return cacheByMimeType;
    }

    /**
     * Calculates the byte size of the metadata string
     * @param {string}
     * @returns {number}
     * @private
     */
    _getStringSizeKilobyte(string) {
        return (Buffer.byteLength(string, 'utf8') / 1024);
    }

    /**
     * Calculates the ETag of the metadata string.
     * @param {string} metadata the metadata
     * @returns {string}
     * @private
     */
    _getEtag(metadata) {
        return crypto.createHash('sha256').update(JSON.stringify(metadata)).digest('base64');
    }
}

module.exports = MetadataCache;
