'use strict';

const RepresentationKinds = require('../format/RepresentationKind').Kinds;
const HttpMethods = require('./HttpMethod').Methods;
const ResourceKind = require('../uri/UriResource').ResourceKind;
const ErrorNames = require('../errors/AbstractError').ErrorNames;

/**
 * The HTTP status code.
 * @hideconstructor
 */
class HttpStatusCode {

    /**
     * Resolves the status code in the success case.
     * @param {OdataRequest} request the current OData request
     * @param {OdataResponse} response the current OData response
     * @returns {?HttpStatusCode.StatusCodes} The resolved statuscode or null if no statuscode could be resolved
     * @package
     */
    static resolveSuccessStatusCode(request, response) {
        const statuscode = response.getStatusCode();
        if (statuscode !== HttpStatusCode.StatusCodes.OK) return statuscode;

        const representationKind = response.getContract().getRepresentationKind();
        if (representationKind === RepresentationKinds.SERVICE ||
            representationKind === RepresentationKinds.METADATA ||
            representationKind === RepresentationKinds.BATCH) {
            return HttpStatusCode.StatusCodes.OK;
        }
        if (representationKind === RepresentationKinds.NO_CONTENT) return HttpStatusCode.StatusCodes.NO_CONTENT;

        let bodyValue;
        const body = response.getBody();
        if (body) {
            bodyValue = body.value;
        }

        const methodString = request.getMethod();
        if (methodString === HttpMethods.GET
            || methodString === HttpMethods.PATCH
            || methodString === HttpMethods.PUT) {
            return bodyValue == null ?
                HttpStatusCode.StatusCodes.NO_CONTENT :
                HttpStatusCode.StatusCodes.OK;
        } else if (methodString === HttpMethods.POST) {
            const lastSegmentKind = request.getUriInfo().getLastSegment().getKind();
            if (lastSegmentKind === ResourceKind.ACTION_IMPORT || lastSegmentKind === ResourceKind.BOUND_ACTION) {
                return bodyValue == null ? HttpStatusCode.StatusCodes.NO_CONTENT : HttpStatusCode.StatusCodes.OK;
            }
            return HttpStatusCode.StatusCodes.CREATED;
        } else if (methodString === HttpMethods.DELETE) {
            return HttpStatusCode.StatusCodes.NO_CONTENT;
        }

        return null;
    }

    /**
     * Resolves the status code in the error case.
     * @param {OdataRequest} request the current OData request
     * @param {OdataResponse} response the current OData response
     * @param {Error} error The error in this error case
     * @returns {HttpStatusCode.StatusCodes|number} The resolved statuscode
     * @package
     */
    static resolveErrorStatusCode(request, response, error) {
        switch (error.name) {
            case ErrorNames.URI_SEMANTIC:
            case ErrorNames.NOT_FOUND:
                return HttpStatusCode.StatusCodes.NOT_FOUND;

            case ErrorNames.URI_QUERY_OPTION_SEMANTIC:
            case ErrorNames.URI_SYNTAX:
            case ErrorNames.DESERIALIZATION:
            case ErrorNames.BAD_REQUEST:
                return HttpStatusCode.StatusCodes.BAD_REQUEST;

            case ErrorNames.NOT_IMPLEMENTED:
                return HttpStatusCode.StatusCodes.NOT_IMPLEMENTED;

            case ErrorNames.METHOD_NOT_ALLOWED:
                return HttpStatusCode.StatusCodes.METHOD_NOT_ALLOWED;

            case ErrorNames.NOT_ACCEPTABLE:
                return HttpStatusCode.StatusCodes.NOT_ACCEPTABLE;

            case ErrorNames.NOT_AUTHORIZED:
                return HttpStatusCode.StatusCodes.UNAUTHORIZED;

            case ErrorNames.INTERNAL_SERVER_ERROR:
                return HttpStatusCode.StatusCodes.INTERNAL_SERVER_ERROR;

            case ErrorNames.PRECONDITION_FAILED_ERROR:
                return HttpStatusCode.StatusCodes.PRECONDITION_FAILED;

            case ErrorNames.PRECONDITION_REQUIRED_ERROR:
                return HttpStatusCode.StatusCodes.PRECONDITION_REQUIRED;

            case ErrorNames.CONFLICT:
                return HttpStatusCode.StatusCodes.CONFLICT;

            default:
                return error.statusCode || HttpStatusCode.StatusCodes.INTERNAL_SERVER_ERROR;
        }
    }
    /**
     * Resolves the status code in the debug-output case.
     * @returns {HttpStatusCode.StatusCodes} The resolved statuscode
     * @package
     */
    static resolveDebugStatusCode() {
        return HttpStatusCode.StatusCodes.OK;
    }
}

/**
 * HTTP status codes
 *
 * @enum {number}
 * @readonly
 */
HttpStatusCode.StatusCodes = {
    OK: 200,
    CREATED: 201,
    ACCEPTED: 202,
    NO_CONTENT: 204,
    NOT_MODIFIED: 304,
    BAD_REQUEST: 400,
    UNAUTHORIZED: 401,
    NOT_FOUND: 404,
    METHOD_NOT_ALLOWED: 405,
    NOT_ACCEPTABLE: 406,
    CONFLICT: 409,
    PRECONDITION_FAILED: 412,
    UNSUPPORTED_MEDIA_TYPE: 415,
    FAILED_DEPENDENCY: 424,
    PRECONDITION_REQUIRED: 428,
    INTERNAL_SERVER_ERROR: 500,
    NOT_IMPLEMENTED: 501
};

/**
 * Text for HTTP status codes
 *
 * @enum {string}
 * @readonly
 */
HttpStatusCode.Texts = {
    200: 'OK',
    201: 'Created',
    202: 'Accepted',
    204: 'No Content',
    304: 'Not Modified',
    400: 'Bad Request',
    401: 'Unauthorized',
    404: 'Not Found',
    405: 'Method Not Allowed',
    406: 'Not Acceptable',
    409: 'Conflict',
    412: 'Precondition Failed',
    415: 'Unsupported Media Type',
    424: 'Failed Dependency',
    428: 'Precondition Required',
    500: 'Internal Server Error',
    501: 'Not Implemented'
};

module.exports = HttpStatusCode;
