'use strict';

const HttpHeaderReader = require('./HttpHeaderReader');
const BadRequestError = require('../errors/BadRequestError');

class HttpHeader {
    /**
     * Parses a content-type header.
     *
     * @param {string|Buffer} contentType - Header value to be parsed
     * @param {?ContentTypeInfo} contentTypeInfo Provide this if a special subtype of class ContentTypeInfo should be filled
     * @returns {ContentTypeInfo}
     */
    static parseContentTypeHeader(contentType, contentTypeInfo) {
        try {
            // readContentType works only on buffers
            return new HttpHeaderReader(Buffer.isBuffer(contentType) ? contentType : Buffer.from(contentType, 'latin1'))
                .readContentType(contentTypeInfo);
        } catch (err) {
            throw new BadRequestError(`Wrong content-type header value '${contentType}'`, err);
        }
    }

    /**
     * Parses an accept header.
     *
     * @param {string|Buffer} accept header value to be parsed
     * @returns {ContentTypeInfo[]}
     */
    static parseAcceptHeader(accept) {
        try {
            return new HttpHeaderReader(Buffer.isBuffer(accept) ? accept : Buffer.from(accept, 'latin1')).readAccept();
        } catch (err) {
            throw new BadRequestError(`Wrong accept header value '${accept}'`, err);
        }
    }

    /**
     * Parses an Accept-Charset header
     *
     * @param {string|Buffer} acceptCharset header value to be parsed
     * @returns {CharsetInfo[]}
     */
    static parseAcceptCharsetHeader(acceptCharset) {
        try {
            return new HttpHeaderReader(Buffer.isBuffer(acceptCharset) ?
                acceptCharset : Buffer.from(acceptCharset, 'latin1')).readAcceptCharset();
        } catch (err) {
            throw new BadRequestError(`Wrong accept-charset header value '${acceptCharset}'`, err);
        }
    }
    /**
     * Parses an prefer header.
     *
     * @param {string|Buffer} prefer header value to be parsed
     * @returns {Preferences}
     */
    static parsePreferHeader(prefer) {
        try {
            return new HttpHeaderReader(Buffer.isBuffer(prefer) ? prefer : Buffer.from(prefer, 'latin1')).readPrefer();
        } catch (err) {
            throw new BadRequestError(`Wrong prefer header value '${prefer}'`, err);
        }
    }

    /**
     * Reads a header line
     *
     * @param {Buffer} line
     * @returns {HeaderInfo|ContentTypeInfo}
     */
    static parseHeaderLine(line) {
        return new HttpHeaderReader(line).readHeaderLine(true);
    }
}

/**
 * Http header names
 *
 * @enum {string}
 * @readonly
 */
HttpHeader.HeaderNames = {
    ACCEPT: 'accept',
    ACCEPT_CHARSET: 'accept-charset',
    CONTENT_TYPE: 'content-type',
    CONTENT_ENCODING: 'content-encoding',
    CONTENT_LENGTH: 'content-length',
    CONTENT_LANGUAGE: 'content-language',
    LOCATION: 'Location',
    ODATA_ENTITYID: 'OData-EntityID',
    ODATA_VERSION: 'OData-Version',
    ODATA_MAXVERSION: 'OData-MaxVersion',
    PREFER: 'prefer',
    PREFERENCE_APPLIED: 'Preference-Applied',
    IF_NONE_MATCH: 'If-None-Match',
    IF_MATCH: 'If-Match',
    ETAG: 'ETag'
};

module.exports = HttpHeader;
