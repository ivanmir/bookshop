'use strict';

/**
 * The CommandExecutor executes a chain of commands and handles possible errors.
 */
class CommandExecutor {

    /**
     * Creates an instance of CommandExecutor.
     * @param {LoggerFacade} logger the logger
     * @param {?PerformanceMonitor} runTimeMeasurement
     */
    constructor(logger, runTimeMeasurement) {
        this._logger = logger;
        this._runTimeMeasurement = runTimeMeasurement;
        this._error = null;
    }

    /**
     * Executes the command success chain and executes the error chain in case of an error in the
     * success chain.
     *
     * @param {Array.<Array>} successCommands The command chain (array of commands with their descriptions) to execute
     * @param {Array.<Array>} failCommands The command chain (array of commands with their descriptions) to execute in case of an error
     * @param {?Error} initialError Error that occurred before initializing the command chain
     * @param {Function} endCallback the function called at the end, with parameter error
     */
    execute(successCommands, failCommands, initialError, endCallback) {
        this._logger.path('Entering CommandExecutor.execute()...');

        const successCallback = error => {
            if (error) {
                this._logger.error(`An error occurred: ${error.message}, \n Stacktrace: ${error.stack}`, error);

                if (failCommands) {
                    this._logger.info('Executing fail command chain...');
                    this._error = error;
                    this._execute(failCommands, 0, null, endCallback);
                } else {
                    endCallback(error);
                }
            } else {
                endCallback();
            }
        };

        // If the method was called with an initial error, only the error command chain will be executed
        if (initialError) {
            this._execute(failCommands, 0, initialError, successCallback);
        } else {
            this._execute(successCommands, 0, null, successCallback);
        }
    }

    /**
     * Executes the command referenced by its index recursively. The execution is asynchronous.
     *
     * @param {Array.<Array>} commands The command chain (array of commands with their descriptions) to execute recursively
     * @param {number} index The current command index to execute
     * @param {?Error} error A possible error
     * @param {Function} callback called when chain ends or an error occurs
     * @private
     */
    _execute(commands = [], index = 0, error, callback) {
        const commandInfo = commands[index];
        if (commandInfo && !error) {
            const command = commandInfo[0];
            const description = commandInfo[1];
            const next = (err, mappedError) => {
                if (this._error && mappedError) {
                    // The 'next(null, mappedError)' signature is used in case of an error listener
                    // where the listener can be used to map/exchange/wrap the original error.
                    this._error = mappedError;
                }
                if (this._runTimeMeasurement && description) this._runTimeMeasurement.getChild(description).stop();
                process.nextTick(() => this._execute(commands, index + 1, err, callback));
            };

            if (this._runTimeMeasurement && description) this._runTimeMeasurement.createChild(description).start();
            try {
                command.execute(next, this._error);
            } catch (innerError) {
                if (this._runTimeMeasurement && description) this._runTimeMeasurement.getChild(description).stop();
                callback(innerError);
            }
        } else {
            callback(error);
        }
    }
}

module.exports = CommandExecutor;
