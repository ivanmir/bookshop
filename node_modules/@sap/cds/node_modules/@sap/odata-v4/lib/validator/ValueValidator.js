'use strict';

const moduleCache = require('../ModuleCache');

const Big = moduleCache.lookup('big.js');

const YEAR_RE = '(?:-?(?:(?:(?:0\\d{3})|(?:[1-9]\\d{3,}))))';
const MONTH_RE = '(?:(?:0[1-9])|(?:1[012]))';
const DAY_RE = '(?:(?:0[1-9])|(?:[12]\\d)|(?:3[01]))';
const HOURS_RE = '(?:(?:[01]\\d)|(?:2[0-3]))';
const MINUTES_RE = '[0-5]\\d';
const SECONDS_RE = MINUTES_RE;
const FRACT_SECONDS_RE = '(\\d{1,12})';
const TIME_ZONE_RE = '(?:Z|(?:[+-]' + HOURS_RE + ':' + MINUTES_RE + '))';

// RegExp for Edm.Date values
const DATE_REG_EXP = new RegExp('^(?:' + YEAR_RE + '-' + MONTH_RE + '-' + DAY_RE + ')$');

// RegExp for Edm.DateTimeOffset values
const DATETIME_OFFSET_REG_EXP = new RegExp('^(?:' + YEAR_RE + '-' + MONTH_RE + '-' + DAY_RE +
    'T' + HOURS_RE + ':' + MINUTES_RE + '(?::' + SECONDS_RE + '(?:\\.' + FRACT_SECONDS_RE + ')?)?' + TIME_ZONE_RE +
    ')$');

// RegExp for Edm.TimeOfDay values
const TIME_OF_DAY_REG_EXP = new RegExp('^(?:' + HOURS_RE + ':' + MINUTES_RE + '(?::' + SECONDS_RE + '(?:\\.' +
    FRACT_SECONDS_RE + ')?)?)$');

const DURATION_TIME_RE = '(?:T(?:(?:(?:\\d+H)(?:\\d+M)?(?:\\d+(?:\\.(\\d+))?S)?)|(?:(?:\\d+M)(?:\\d+' +
    '(?:\\.(\\d+))?S)?)|(?:(?:\\d+(?:\\.(\\d+))?S))))';

// RegExp for Edm.Duration values
const DURATION_REG_EXP = new RegExp('^(?:-?P(?:(?:(?:\\d+D)' + DURATION_TIME_RE + '?)|' + DURATION_TIME_RE + '))$');

// RegExp for Edm.Guid values
const HEX_DIG = '[A-Fa-f0-9]';
const GUID_REG_EXP = new RegExp('^(?:' + HEX_DIG + '{8}-' + HEX_DIG + '{4}-' + HEX_DIG + '{4}-' +
    HEX_DIG + '{4}-' + HEX_DIG + '{12})$');

// RegExp for ETag values
const ETAG_VALUE_REG_EXP = new RegExp('^[!#-~\\x80-\\xFF]*$');  // %x21 / %x23-7E / obs-text

// max value for Edm.Int64
const INT64_MAX = new Big('9223372036854775807');

// min value for Edm.Int64
const INT64_MIN = new Big('-9223372036854775808');

// min value for IEEE 754 binary32 (i.e. Edm.Single)
const SINGLE_MIN = 1.401298464324817E-45;

// max value for IEEE 754 binary32  (i.e. Edm.Single)
const SINGLE_MAX = 3.4028234663852886E+38;

function createBig(value) {
    try {
        return new Big(value);
    } catch (e) {
        // Big constructor throws NaN if the input is not a number.
        // Return NaN here to avoid yet another try-catch block in the calling function
        return Number.NaN;
    }
}

/**
 * Validator of values according to the OData ABNF Construction Rules.
 */
class ValueValidator {
    /**
     * Validates value of Edm.Binary type.
     *
     * @param {Buffer} value - Edm.Binary value
     * @param {number} maxLength - value of MaxLength facet
     */
    validateBinary(value, maxLength) {
        if (!this.isBuffer(value)) {
            throw new Error(
                `Invalid value: ${value}. A Buffer instance must be specified for a value of Edm.Binary type.`);
        }

        this._checkMaxLength(value, maxLength, 'Edm.Binary');
    }

    /**
     * Returns true if value is a Buffer
     *
     * @param {*} value - The value to check
     * @returns {boolean} True if the value is a buffer, else false
     */
    isBuffer(value) {
        return Buffer.isBuffer(value);
    }

    /**
     * Validates value of Edm.Boolean type.
     *
     * @param {boolean} value - Edm.Boolean value
     */
    validateBoolean(value) {
        if (!this.isBoolean(value)) {
            throw new Error(
                `Invalid value: ${value}. A boolean value must be specified for a value of Edm.Boolean type.`);
        }
    }

    /**
     * Returns true if value is of type boolean.
     *
     * @param {*} value The value to check
     * @returns {boolean} Returns true if value is boolean, else false
     */
    isBoolean(value) {
        return typeof value === 'boolean';
    }

    /**
     * Validates value of Edm.Byte type.
     *
     * @param {number} value - Edm.Byte value
     */
    validateByte(value) {
        this._validateIntegerValue(value, 'Byte', 0, 255);
    }

    /**
     * Returns true if value is of type byte.
     *
     * @param {*} value The value to check
     * @returns {boolean} Returns true if value is unsigned byte, else false
     */
    isByte(value) {
        return this._isInteger(value, 0, 255);
    }

    /**
     * Validates value of Edm.SByte type.
     *
     * @param {number} value - Edm.SByte value
     */
    validateSByte(value) {
        this._validateIntegerValue(value, 'SByte', -128, 127);
    }

    /**
     * Returns true if value is of type sbyte.
     *
     * @param {*} value The value to check
     * @returns {boolean} Returns true if value is signed byte, else false
     */
    isSbyte(value) {
        return this._isInteger(value, -128, 127);
    }

    /**
     * Validates value of Edm.Int16 type.
     *
     * @param {number} value - Edm.Int16 value
     */
    validateInt16(value) {
        this._validateIntegerValue(value, 'Int16', -32768, 32767);
    }

    /**
     * Returns true if value is of type int16.
     *
     * @param {*} value The value to check
     * @returns {boolean} Returns true if value is int16, else false
     */
    isInt16(value) {
        return this._isInteger(value, -32768, 32767);
    }

    /**
     * Validates value of Edm.Int32 type.
     *
     * @param {number} value - Edm.Int32 value
     */
    validateInt32(value) {
        this._validateIntegerValue(value, 'Int32', -2147483648, 2147483647);
    }

    /**
     * Returns true if value is of type int32.
     *
     * @param {*} value The value to check
     * @returns {boolean} Returns true if value is int32, else false
     */
    isInt32(value) {
        return this._isInteger(value, -2147483648, 2147483647);
    }

    /**
     * Validates value of Edm.Int64 type.
     *
     * @param {number|string} value - Edm.Int64 value. Values in exponential notation are also supported.
     */
    validateInt64(value) {
        if (!this.isInt64(value)) {
            throw new Error(`Invalid value: ${value}. The value does not representing an integer or its value` +
                ' is not in range from -9223372036854775808 to 9223372036854775807');
        }
    }

    /**
     * Returns true if value is of type int64.
     *
     * @param {*} value The value to check
     * @returns {boolean} Returns true if value is int64, else false
     */
    isInt64(value) {
        const bigValue = createBig(value);
        return !Number.isNaN(bigValue) && bigValue.round(0).eq(bigValue)
            && bigValue.gte(INT64_MIN) && bigValue.lte(INT64_MAX);
    }


    /**
     * Validates, whether the value is an integer value, which belongs to the specified value range, defined via 'from'
     * and 'to' input parameters.
     *
     * @param {*} value - Any value, which should be validated
     * @param {string} edmType - name of the EDM type, for which the value is validated
     * @param {number} from - beginning of the valid value range, which the value must belong to
     * @param {number} to - end of the valid value range, which the value must belong to
     * @private
     */
    _validateIntegerValue(value, edmType, from, to) {
        if (!this._isInteger(value, from, to)) {
            // Duplicate code is needed because of different error messages
            if (!Number.isInteger(value)) {
                throw new Error(`Invalid value: ${value}. An integer value must be specified for a value of` +
                    ` Edm.${edmType} type.`);
            } else {
                throw new Error(`Invalid value: ${value}. Only number in the range from ${from} to ${to}` +
                    ` is allowed for a value of Edm.${edmType} type.`);
            }
        }
    }


    /**
     * Returns true if the provided value is an integer and within the range from 'from' to 'to'
     *
     * @param {*} value - Any value to check
     * @param {number} from - beginning of the valid value range, which the value must belong to
     * @param {number} to - end of the valid value range, which the value must belong to
     * @returns {boolean} True if the value is a valid integer, else false
     * @private
     */
    _isInteger(value, from, to) {
        return Number.isInteger(value) && value >= from && value <= to;
    }

    /**
     * Validates value of Edm.String type.
     *
     * @param {*} value - Edm.String value
     * @param {number} maxLength - value of MaxLength facet
     */
    validateString(value, maxLength) {
        if (!this.isString(value)) {
            throw new Error(`Invalid value: ${value}. A string value must be specified for a value of Edm.String` +
                ' type.');
        }

        this._checkMaxLength(value, maxLength, 'Edm.String');
    }

    /**
     * Returns true if the provided value is a string.
     *
     * @param {*} value - Any value to check
     * @returns {boolean} True if the value is a valid string, else false
     */
    isString(value) {
        return typeof value === 'string';
    }

    _checkMaxLength(value, maxLength, typeName) {
        // consider only integer maxLength values, ignoring both, unspecified and the special 'max' value
        if (Number.isInteger(maxLength) && value.length > maxLength) {
            throw new Error(`Invalid value: ${value}. Length of the ${typeName} value must not be greater than the ` +
                `MaxLength facet value (${maxLength})`);
        }
    }

    /**
     * Validates value of Edm.Date type.
     *
     * @param {*} value - Edm.Date value
     */
    validateDate(value) {
        if (!this.isDate(value)) {
            throw new Error(`Invalid value: ${value}. A string value in the format YYYY-MM-DD must be specified for ` +
                'a value of Edm.Date type.');
        }
    }

    /**
     * Returns true if the provided value is a YYYY-MM-DD date.
     *
     * @param {*} value - Any value to check
     * @returns {boolean} True if the value is a valid date, else false
     */
    isDate(value) {
        return typeof value === 'string' && DATE_REG_EXP.test(value);
    }

    /**
     * Validates value of Edm.DateTimeOffset type.
     *
     * @param {*} value - Edm.DateTimeOffset value
     * @param {number|string} [precision] - value of Precision facet
     */
    validateDateTimeOffset(value, precision) {
        let result = DATETIME_OFFSET_REG_EXP.exec(value);

        // We do not call this.isDateTimeOffset(...) because we need the result of
        // the regular expression

        if (typeof value !== 'string' || !result) {
            throw new Error(`Invalid value: ${value}. A string value in the format YYYY-MM-DDThh:mm:ss.sTZD must be ` +
                'specified for a value of Edm.DateTimeOffset type.');
        }

        const milliseconds = result[1];
        this._checkMillisecondsPrecision(value, milliseconds, precision);
    }

    /**
     * Returns true if the provided value is a YYYY-MM-DDTHH:mm:ss.023Z date time offset.
     *
     * @param {*} value - Any value to check
     * @returns {boolean} True if the value is a valid date time offset, else false
     */
    isDateTimeOffset(value) {
        return typeof value === 'string' && DATETIME_OFFSET_REG_EXP.test(value);
    }

    /**
     * Validates value of Edm.TimeOfDay type.
     *
     * @param {*} value - Edm.TimeOfDay value
     * @param {number|string} [precision] - value of Precision facet
     */
    validateTimeOfDay(value, precision) {
        let result = TIME_OF_DAY_REG_EXP.exec(value);

        // We do not call this.isTimeOfDay(...) because we need the result of
        // the regular expression

        if (typeof value !== 'string' || !result) {
            throw new Error(`Invalid value: ${value}. A string value in the format hh:mm:ss.s must be ` +
                'specified for a value of Edm.TimeOfDay type.');
        }

        const milliseconds = result[1];
        this._checkMillisecondsPrecision(value, milliseconds, precision);
    }

    /**
     * Returns true if the provided value is a HH:mm:ss.023Z time of day.
     *
     * @param {*} value - Any value to check
     * @returns {boolean} True if the value is a valid time of day, else false
     */
    isTimeOfDay(value) {
        return typeof value === 'string' && TIME_OF_DAY_REG_EXP.test(value);
    }

    /**
     * Validates value of Edm.Duration type.
     *
     * @param {*} value - Edm.Duration value
     * @param {number|string} [precision] - value of Precision facet
     */
    validateDuration(value, precision) {
        let result = DURATION_REG_EXP.exec(value);

        // We do not call this.isDuration(...) because we need the result of
        // the regular expression

        if (typeof value !== 'string' || !result) {
            throw new Error(`Invalid value: ${value}. A string value in the format PnDTnHnMn.nS must be specified ` +
                'for a value of Edm.Duration type.');
        }

        // Because of the different combinations of the duration parts (HS, MS, S) we have 6 places (i.e. matching
        // groups) in the regular expression, which match milliseconds. Therefore slice() is called on the result
        // array to "extract" only these 6 matches and find the one, which matches, i.e. not empty
        const milliseconds = result.slice(1, 7).find((match) => match != null);

        this._checkMillisecondsPrecision(value, milliseconds, precision);
    }

    /**
     * Returns true if the provided value is a duration.
     *
     * @param {*} value - Any value to check
     * @returns {boolean} True if the value is a valid duration, else false
     */
    isDuration(value) {
        return typeof value === 'string' && DURATION_REG_EXP.test(value);
    }

    /**
     * Checks whether the milliseconds satisfy the specified precision for the value.
     *
     * @param {string} value - temporal value, which can contain milliseconds
     * @param {string} milliseconds - part of the value, representing milliseconds
     * @param {number} precision - value of the Precision facet for the property, which has the specified value
     * @private
     */
    _checkMillisecondsPrecision(value, milliseconds, precision) {
        if (!milliseconds || precision == null) {
            return;
        }

        // milliseconds is a string value, so just check its length
        if (milliseconds.length > precision) {
            throw new Error(`Invalid value: ${value}. The number of milliseconds does not correspond to the ` +
                `Precision facet value ${precision}`);
        }
    }

    /**
     * Validates value of Edm.Decimal type.
     *
     * @param {number|string} value - Edm.Decimal value. Values in exponential notation are also supported.
     * @param {number|string} [precision] - value of Precision facet
     * @param {number|string} [scale] - value of Scale facet
     */
    validateDecimal(value, precision, scale) {
        // precision and scale values are not validated assuming that the metadata validation is done before calling
        // the serializer

        const bigValue = createBig(value);

        // We do not call this.isDecimal(...) because we need the big js object

        // check that the value represents a number
        if (Number.isNaN(bigValue)) {
            throw new Error(`Invalid value: ${value}. A number or a string representing a number must be ` +
                'specified for a value of Edm.Decimal type.');
        }

        // check that the value has no more digits than specified for precision
        if (precision != null && bigValue.c.length > precision) {
            throw new Error(`Invalid value: ${value}. The specified Edm.Decimal value does not correspond to the ` +
                `Precision facet value ${precision}`);
        }

        if (scale == null || scale === 'variable') {
            return;
        }

        // specify 0 as the rounding mode to simply truncate the number wihout any sort of rounding
        const integerPart = bigValue.round(0, 0);

        if (precision === scale) {
            if (!integerPart.eq(0)) {
                throw new Error(`Invalid value: ${value}. If Precision is equal to Scale, a single zero must ` +
                    'precede the decimal point in the Edm.Decimal value');
            }

            return;
        }

        // validate number of digits in the integer (i.e. left) part of the value
        if (precision != null && integerPart.c.length > (precision - scale)) {
            throw new Error(`Invalid value: ${value}. The number of digits to the left of the decimal point ` +
                `must not be greater than Precision minus Scale, i.e. ${precision - scale}`);
        }

        // validate number of digits in the decimal (i.e. right) part of the value
        const decimalPart = bigValue.minus(integerPart);
        if (decimalPart.c.length > scale && !decimalPart.eq(0)) {
            throw new Error(`Invalid value: ${value}. The specified Edm.Decimal value has more digits to the ` +
                `right of the decimal point than allowed by the Scale facet with ${scale} value`);
        }
    }

    /**
    * Returns true if the provided value is a decimal number
    *
    * @param {*} value - Any value to check
    * @returns {boolean} True if the value is a valid decimal number, else false
    */
    isDecimal(value) {
        const bigValue = createBig(value);
        return !Number.isNaN(bigValue);
    }

    /**
     * Validates value of Edm.Single type.
     *
     * @param {*} value - Edm.Single value
     */
    validateSingle(value) {
        if (!this.isSingle(value)) {
            throw new Error(`Invalid value: ${value}. Only a number having absolute value in the range from ` +
                `${SINGLE_MIN} to ${SINGLE_MAX} is allowed for a value of Edm.Single type.`);
        }
    }

    /**
    * Returns true if the provided value is a single precision float number
    *
    * @param {*} value - Any value to check
    * @returns {boolean} True if the value is a valid single precision float number, else false
    */
    isSingle(value) {
        if (typeof value === 'number') {
            const absValue = Math.abs(value);
            return absValue === 0 || absValue >= SINGLE_MIN && absValue <= SINGLE_MAX;
        }
        return false;
    }

    /**
     * Validates value of Edm.Double type.
     *
     * @param {*} value - Edm.Double value
     */
    validateDouble(value) {
        if (!this.isDouble(value)) {
            throw new Error(`Invalid value: ${value}. A number value must be specified for a value of ` +
                'Edm.Double type.');
        }
    }

    /**
     * Returns true if the provided value is a double number
     *
     * @param {*} value - Any value to check
     * @returns {boolean} True if the value is a valid double number, else false
     */
    isDouble(value) {
        return typeof value === 'number';
    }

    /**
     * Validates value of Edm.Guid type.
     *
     * @param {*} value - Edm.Guid value
     */
    validateGuid(value) {
        if (!this.isGuid(value)) {
            throw new Error(`Invalid value: ${value}. A string value in the format ` +
                '8HEXDIG-4HEXDIG-4HEXDIG-4HEXDIG-12HEXDIG must be specified for a value of Edm.Guid type.');
        }
    }

    /**
     * Returns true if the provided value is a GUID.
     *
     * @param {*} value - Any value to check
     * @returns {boolean} True if the value is a valid GUID, else false
     */
    isGuid(value) {
        return typeof value === 'string' && GUID_REG_EXP.test(value);
    }

    /**
     * Validates if the provided etag value matches the expected format.
     * The value must be a string of allowed characters as described in RFC 7232
     * (see https://tools.ietf.org/html/rfc7232#section-2.3 for details).
     *
     * @param {string} value The provided etag value to validate
     * @returns {string} The provided value
     * @throws {Error} If the etag value doesn't match the required format
    */
    validateEtagValue(value) {
        if (value == null) throw new Error('Invalid etag value. Value can not be null or undefined');
        if (typeof value !== 'string') throw new Error('Invalid etag value. Etag must be type of String');
        if (!ETAG_VALUE_REG_EXP.test(value)) throw new Error('Invalid etag value.');

        return value;
    }
}

module.exports = ValueValidator;
