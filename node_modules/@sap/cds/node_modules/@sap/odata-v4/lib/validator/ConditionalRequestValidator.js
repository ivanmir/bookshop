'use strict';

const HttpMethods = require('../http/HttpMethod').Methods;
const ResourceKinds = require('../uri/UriResource').ResourceKind;
const PreconditionFailedError = require('../errors/PreconditionFailedError');
const PreconditionRequiredError = require('../errors/PreconditionRequiredError');
const ConflictError = require('../errors/ConflictError');
const FeatureSupport = require('../FeatureSupport');

const STATES = {
    INITIAL: 'Initial',
    IS_CONCURRENT_RESOURCE: 'Is concurrent resource',
    REQUEST_HAS_IF_MATCH_HEADER: 'Request has If-Match header',
    REQUEST_HAS_IF_NONE_MATCH_HEADER: 'Request has If-None-Match header',
    PRECONDITION_REQUIRED: '428 Precondition required',
    PRECONDITION_FAILED: '412 Precondition failed',
    NOT_MODIFIED: '304 Not modified',
    CONFLICT: '409 Conflict',
    VALIDATE: 'Validate',
    VALIDATE_IF_MATCH: 'Validate If-Match',
    VALIDATE_IF_MATCH_IS_STAR: 'Validate If-Match is *',
    IS_PUT_PATCH_BOUND_ACTION: 'Is PUT/PATCH/Bound Action',
    MAKE_REQUEST_UPDATE_ONLY: 'Make request update only',
    COMPARE_IF_MATCH: 'Compare If-Match',
    VALIDATE_IF_NONE_MATCH: 'Validate If-None-Match',
    IS_GET: 'Is GET',
    VALIDATE_IF_NONE_MATCH_IS_STAR: 'Validate If-None-Match is *',
    COMPARE_IF_NONE_MATCH: 'Compare If-None-Match',
    IS_PUT_PATCH_DELETE_BOUND_ACTION: 'Is PUT/PATCH/DELETE/Bound Action',
    MAKE_REQUEST_INSERT_ONLY: 'Make request insert only',
    FINAL: 'Final'
};

const parseHeaderEtagValue = value => {
    return value.split(',').map(str => {
        let result = str.trim();
        if (result === '*') return result;
        if (result.startsWith('W/')) result = result.substr(2);
        return result.startsWith('"') && result.endsWith('"') ?
            result.substr(1, result.length - 2) :
            null;
    });
};

class ConditionalRequestValidator {

    constructor(stateMachine) {
        this._stateMachine = stateMachine;
    }

    startWith(stateName) {
        this._startWith = stateName;
        return this;
    }

    validate(...params) {
        let run = this._stateMachine.next(this._startWith, ...params);
        while (run === true) {
            run = this._stateMachine.next();
        }
    }

    static createStateMachineContext(logger = { path() { }, debug() { } }) {

        // For now implemented as a singelton
        if (ConditionalRequestValidator.DEFAULT_STATEMACHINE_CONTEXT) {
            return ConditionalRequestValidator.DEFAULT_STATEMACHINE_CONTEXT;
        }

        ConditionalRequestValidator.DEFAULT_STATEMACHINE_CONTEXT = {
            [STATES.INITIAL]: (next, context) => {
                logger.path('Entering state: Initial');
                next(null, STATES.IS_CONCURRENT_RESOURCE, context);
            },
            [STATES.IS_CONCURRENT_RESOURCE]: (next, context) => {
                logger.path('Entering state: Is concurrent resource');
                const nextState = context.isConcurrentResource === true ?
                    STATES.REQUEST_HAS_IF_MATCH_HEADER : STATES.CONFLICT;
                next(null, nextState, context);
            },
            [STATES.REQUEST_HAS_IF_MATCH_HEADER]: (next, context) => {
                logger.path('Entering state: Request has If-Match header');
                const nextState = context.ifMatch == null ?
                    STATES.REQUEST_HAS_IF_NONE_MATCH_HEADER : STATES.FINAL;
                next(null, nextState, context);
            },
            [STATES.REQUEST_HAS_IF_NONE_MATCH_HEADER]: (next, context) => {
                logger.path('Entering state: Request has If-None-Match header');
                const nextState = context.ifNoneMatch == null ?
                    STATES.IS_GET : STATES.FINAL;
                next(null, nextState, context, null, STATES.FINAL, STATES.PRECONDITION_REQUIRED);
            },
            [STATES.PRECONDITION_REQUIRED]: (next) => {
                logger.path('Entering state: 428 Precondition required');
                next(new PreconditionRequiredError());
            },
            [STATES.PRECONDITION_FAILED]: (next) => {
                logger.path('Entering state: 412 Precondition failed');
                next(new PreconditionFailedError());
            },
            [STATES.NOT_MODIFIED]: (next) => {
                logger.path('Entering state: 304 Not modified');
                next(null, STATES.FINAL);
            },
            [STATES.CONFLICT]: (next) => {
                logger.path('Entering state: 409 Conflict');
                next(new ConflictError('The requested resource is not concurrent'));
            },
            [STATES.VALIDATE]: (next, context, etags) => {
                logger.path('Entering state: Validate');

                next(null, STATES.VALIDATE_IF_MATCH, context, etags);
            },
            [STATES.VALIDATE_IF_MATCH]: (next, context, etags) => {
                logger.path('Entering state: Validate If-Match');

                let nextState = context.ifMatch == null ?
                    STATES.VALIDATE_IF_NONE_MATCH : STATES.VALIDATE_IF_MATCH_IS_STAR;
                next(null, nextState, context, etags);
            },
            [STATES.VALIDATE_IF_MATCH_IS_STAR]: (next, context, etags) => {
                logger.path('Entering state: Validate If-Match is *');

                if (context.ifMatch === '*') {
                    next(null, STATES.IS_PUT_PATCH_BOUND_ACTION, context, etags,
                        STATES.MAKE_REQUEST_UPDATE_ONLY, STATES.COMPARE_IF_MATCH);
                } else {
                    next(null, STATES.COMPARE_IF_MATCH, context, etags);
                }
            },
            [STATES.IS_PUT_PATCH_BOUND_ACTION]: (next, context, etags, trueState, falseState) => {
                logger.path('Entering state: Is PUT/PATCH/Bound Action');
                const method = context.method;
                const kind = context.kind;
                const nextState = method === HttpMethods.PUT || method === HttpMethods.PATCH ||
                    kind === ResourceKinds.BOUND_ACTION ? trueState : falseState;
                next(null, nextState, context, etags);
            },
            [STATES.MAKE_REQUEST_UPDATE_ONLY]: (next /* , context, etags */) => {
                logger.path('Entering state: Make request update only');
                // next(null, STATES.VALIDATE_IF_NONE_MATCH, context, etags); // Default Processing when supported
                next(FeatureSupport.getUnsupported(FeatureSupport.features.Upsert));
            },
            [STATES.COMPARE_IF_MATCH]: (next, context, etags) => {
                logger.path('Entering state: Compare If-Match');

                const rawHeaderEtags = parseHeaderEtagValue(context.ifMatch);
                let nextState;

                if (rawHeaderEtags.includes('*')) {
                    nextState = STATES.VALIDATE_IF_NONE_MATCH;
                } else {
                    const headerValues = parseHeaderEtagValue(context.ifMatch);
                    logger.debug('Compare ', headerValues.join(','), ' with ', etags);
                    nextState = headerValues.includes(etags) === true ?
                        STATES.VALIDATE_IF_NONE_MATCH : STATES.PRECONDITION_FAILED;
                }
                next(null, nextState, context, etags);
            },
            [STATES.VALIDATE_IF_NONE_MATCH]: (next, context, etags) => {
                logger.path('Entering state: Validate If-None-Match');

                const nextState = context.ifNoneMatch == null ?
                    STATES.IS_GET : STATES.VALIDATE_IF_NONE_MATCH_IS_STAR;
                next(null, nextState, context, etags,
                    STATES.NOT_MODIFIED, STATES.FINAL);
            },
            [STATES.IS_GET]: (next, context, etags, trueState, falseState) => {
                logger.path('Entering state: Is GET');

                const method = context.method;
                const nextState = method === HttpMethods.GET ? trueState : falseState;
                next(null, nextState, context, etags);
            },

            [STATES.VALIDATE_IF_NONE_MATCH_IS_STAR]: (next, context, etags) => {
                logger.path('Entering state: Validate If-None-Match is *');

                if (context.ifNoneMatch === '*') {
                    next(null, STATES.IS_PUT_PATCH_BOUND_ACTION, context, etags,
                        STATES.MAKE_REQUEST_INSERT_ONLY, STATES.COMPARE_IF_NONE_MATCH);
                } else {
                    next(null, STATES.COMPARE_IF_NONE_MATCH, context, etags);
                }
            },
            [STATES.COMPARE_IF_NONE_MATCH]: (next, context, etags) => {
                logger.path('Entering state: Compare If-None-Match');

                let nextState;
                if (context.ifNoneMatch === '*') {
                    nextState = etags == null ? STATES.NOT_MODIFIED : STATES.IS_PUT_PATCH_DELETE_BOUND_ACTION;
                } else {
                    nextState = parseHeaderEtagValue(context.ifNoneMatch).includes(etags) === true ?
                        STATES.IS_PUT_PATCH_DELETE_BOUND_ACTION : STATES.FINAL;
                }

                next(null, nextState, context, STATES.PRECONDITION_FAILED, STATES.NOT_MODIFIED);
            },
            [STATES.IS_PUT_PATCH_DELETE_BOUND_ACTION]: (next, context, trueState, falseState) => {
                logger.path('Entering state: Is PUT/PATCH/DELETE/Bound Action');

                const method = context.method;
                const kind = context.kind;

                const nextState = method === HttpMethods.PUT || method === HttpMethods.PATCH ||
                    method === HttpMethods.DELETE || kind === ResourceKinds.BOUND_ACTION ? trueState : falseState;

                next(null, nextState, context);
            },
            [STATES.MAKE_REQUEST_INSERT_ONLY]: (next /* , context */) => {
                logger.path('Entering state: Make request insert only');
                // next(null, STATES.FINAL, context); // Default Processing when supported
                next(FeatureSupport.getUnsupported(FeatureSupport.features.Upsert));
            },
            [STATES.FINAL]: (next) => {
                logger.path('Entering state: final');

                next();
            }

        };
        return ConditionalRequestValidator.DEFAULT_STATEMACHINE_CONTEXT;
    }
}

ConditionalRequestValidator.STATES = STATES;

module.exports = ConditionalRequestValidator;
