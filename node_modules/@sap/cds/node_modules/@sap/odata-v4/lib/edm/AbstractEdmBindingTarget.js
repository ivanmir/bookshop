'use strict';

const EdmAnnotation = require('./EdmAnnotation');
const EdmNavigationPropertyBinding = require('./EdmNavigationPropertyBinding');
const Target = require('./Target');
const validateThat = require('../validator/ParameterValidator').validateThat;

/**
 * {@link EdmEntitySet} and {@link EdmSingleton} share much information, this information
 * contained in this class.
 * @abstract
 * @hideconstructor
 * @ignore
 */
class AbstractEdmBindingTarget {

    /**
     * Constructor
     *
     * @param {Edm} edm The edm itself
     * @param {EdmEntityContainer} container The entity container the target belongs to
     * @param {CsdlEntitySet|CsdlSingleton} target The target
     * @param {Object} configuration Configuration object with additional configuration properties
     * @param {boolean} configuration.isConcurrent True if this binding target is target of a conditional request with concurrent modifications
     */
    constructor(edm, container, target, configuration = {}) {
        validateThat('edm', edm).truthy();
        validateThat('container', container).truthy();
        validateThat('target', target).truthy();

        /**
         * @type {Edm}
         * @private
         */
        this._edm = edm;

        /**
         * @type {string}
         * @private
         */
        this._name = target.name;

        /**
         * EntityContainer containing this binding target
         * @type {EdmEntityContainer}
         * @private
         */
        this._entityContainer = container;

        /**
         * @type {CsdlEntitySet|CsdlSingleton}
         * @private
         */
        this._target = target;

        /**
         * The Navigation property bindings
         * @type {EdmNavigationPropertyBinding[]}
         * @private
         */
        this._navigationPropertyBindings = null;


        /**
         * @type {EdmAnnotation[]}
         * @private
         */
        this._annotations = null;

        /**
         * Configuration object
         * @type {Object}
         * @private
         */
        this._configuration = configuration;
    }

    /**
     * Return whether this binding target is configured to be concurrency controlled.
     * @returns {boolean}
     */
    isConcurrent() {
        return this._configuration.isConcurrent === true;
    }

    /**
     * Return the name.
     *
     * @returns {string}
     */
    getName() {
        return this._name;
    }

    /**
     * Return all navigation property bindings
     * See
     * <a href="./../ODataSpecification/odata-v4.0-errata03-os/complete/part3-csdl/odata-v4.0-errata03-os-part3-csdl-complete.html#_Toc453752607">
     *     13.4 Element edm:NavigationPropertyBinding
     * </a> for details
     *
     * @returns {EdmNavigationPropertyBinding[]}
     */
    getNavigationPropertyBindings() {

        if (this._navigationPropertyBindings) {
            return this._navigationPropertyBindings;
        }

        this._navigationPropertyBindings = [];

        for (let binding of this._target.navigationPropertyBindings) {
            this._navigationPropertyBindings.push(
                new EdmNavigationPropertyBinding(binding.path, binding.target));
        }

        return this._navigationPropertyBindings;
    }


    /**
     * Return the entityContainer containing this binding target
     *
     * @returns {EdmEntityContainer}
     */
    getEntityContainer() {
        return this._entityContainer;
    }

    /**
     * Return the type of the target
     *
     * @returns {EdmEntityType}
     */
    getEntityType() {
        return this._edm.getEntityType(this._target.type);
    }

    /**
     * Return the target for a given path or null if no target was found.
     *
     * @param {string} inputPath The EntitySetPath value
     * @returns {?(EdmEntitySet|EdmSingleton)}
     */
    getRelatedBindingTarget(inputPath) {
        validateThat('inputPath', inputPath).truthy();

        /**
         * @type {EdmEntitySet|EdmSingleton}
         */
        let bindingTarget = null;

        let path = inputPath;
        // The input path has to be sliced by the binding param path segment
        // See odata-v4.0-errata03-os-part3-csdl-complete > 12. ff
        const pathSplit = inputPath.split('/');
        if (pathSplit.length > 1) {
            path = pathSplit.splice(1).join('/');
        }

        let max = this.getNavigationPropertyBindings().length;

        for (let c = 0; c < max; c++) {

            /**
             * @type {EdmNavigationPropertyBinding}
             */
            let binding = this.getNavigationPropertyBindings()[c];
            let edmTarget;
            let entityContainer;

            if (!path.startsWith(binding.getPath())) {
                continue;
            }

            edmTarget = new Target(binding.getTarget(), this._entityContainer);
            entityContainer = this._edm.getEntityContainer(edmTarget.getEntityContainer());

            if (!entityContainer) return null;

            bindingTarget = entityContainer.getEntitySet(edmTarget.getTargetName())
                || entityContainer.getSingleton(edmTarget.getTargetName());
        }

        return bindingTarget;
    }

    /**
     * Return the annotations for this object.
     *
     * @returns {EdmAnnotation[]}
     */
    getAnnotations() {
        if (!this._annotations) {
            this._annotations = this._target.annotations.map(item => new EdmAnnotation(this._edm, item));
        }
        return this._annotations;
    }
}

module.exports = AbstractEdmBindingTarget;
