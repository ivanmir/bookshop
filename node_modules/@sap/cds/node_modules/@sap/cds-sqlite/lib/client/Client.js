const {Database} = require('sqlite3')
const SqliteStatement = require('../statement/SqliteStatement')
const {
  BaseClient,
  errors: {
    IllegalFunctionArgumentError,
    InconsistentClientError,
    SqlError
  },
  builder: {sqlFactory},
  expand: {
    createJoinCQNFromExpanded,
    hasExpand,
    rawToExpanded
  },
  contains: {
    replaceContainsWithLike,
    hasContains
  },
  postProcessing: {
    getPostProcessMapper,
    postProcess
  }
} = require('@sap/cds-sql')

class Client extends BaseClient {
  /**
   * Create an SqliteClient object.
   *
   * Username/password are currently not supported,
   * but at least the host must be provided.
   *
   * @param {Object} connect - Connection details.
   * @param {string} connect.host - Filename to the database or :memory; for in memory
   * @param {string} [connect.user] - Username for authentication
   * @param {string} [connect.password] - Password for authentication
   */
  constructor (connect) {
    const convertToBase64Buffer = (element) => {
      return Buffer.from(element, 'base64')
    }
    const convertToISOTime = (value) => {
      if (value === null) {
        return value
      }

      if (!value) {
        value = 0
      }

      return new Date(value).toISOString()
    }

    super([
      ['cds.Boolean', Boolean],
      ['cds.Integer64', String],
      ['cds.Binary', convertToBase64Buffer],
      ['cds.LargeBinary', convertToBase64Buffer],
      ['cds.DateTime', convertToISOTime],
      ['cds.Timestamp', convertToISOTime]
    ])

    this._connect = connect
    this._user = 'anonymous' // default user
    this._transCount = 0
  }

  /**
   * Open database connection.
   *
   * Opening connection occurs while opening Sqlite database.
   *
   * @returns {Promise} Promise, that resolves with SqliteClient if _connect is successful or rejects with error if not.
   */
  connect () {
    return new Promise((resolve, reject) => {
      if (!this._connect) {
        return reject(new IllegalFunctionArgumentError('connect'))
      }

      this._dbc = new Database(this._connect.host, (err) => {
        if (err) {
          return reject(err)
        }

        resolve(this)
      })
    })
  }

  /**
   * Close database connection.
   *
   * Closing connection occurs while closing Sqlite database.
   *
   * @returns {Promise} Promise, that resolves if end is successful or rejects with error if not.
   */
  end () {
    return new Promise((resolve, reject) => {
      this._dbc.close((err) => {
        if (err) {
          return reject(err)
        }

        resolve()
      })
    })
  }

  /**
   * Execute SQL statement.
   *
   * If execution of SQL statement requires additional values,
   * then the values to be provided as an array.
   * In order to provide multiple value sets with a single execute (example: batch insert)
   * values have to be provided as arrays of values composed in an outer array.
   *
   * Method returns a result object.
   * In case of SELECT the result object contains a result-set.
   * In other cases the result is an empty array - DIFFERENT TO HANA!
   *
   * The query can be provided as SQL string or as CQN object.
   *
   * @example <caption>Simple Select as SQL string<caption>
   * .execute("SELECT * FROM T")
   * @example <caption>Select with filter as SQL string<caption>
   * .execute("SELECT * FROM T WHERE X = ?", [1])
   * @example <caption>Single Insert as SQL string<caption>
   * .execute("INSERT INTO T (A, B) VALUES (?,?)", [1, 'a'])
   * @example <caption>Multiple Insert as SQL string<caption>
   * .execute("INSERT INTO T (A, B) VALUES (?,?)", [[1, 'a'], [2, 'b']])
   * @example <caption>Simple Select as CQN object<caption>
   * .execute(SELECT.from('T'))
   * @example <caption>Select with filter as CQN object<caption>
   * .execute(SELECT.from('T').where(['x', '=', 1])
   *
   * @param {string|object} query - SQL string or CQN object generated by the DML statements.
   * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string.
   * @returns {Promise} Promise, that resolves with result object (array) if successful or rejects with error if not.
   *
   */
  execute (query, values = []) {
    if (this._toBeDestroyed) {
      return Promise.reject(new InconsistentClientError())
    }
    if (!Array.isArray(values)) {
      return Promise.reject(new IllegalFunctionArgumentError('values'))
    }

    if (typeof query === 'string') {
      return this._executeSQL(query, values)
    }

    if (typeof query === 'function') {
      return this._runBlock(query)
    }

    try {
      let newQuery = query
      if (query && hasContains(query)) {
        newQuery = replaceContainsWithLike(query)
      }

      if (hasExpand(newQuery)) {
        return this._processExpand(newQuery)
      }

      const {sql, values = []} = sqlFactory(newQuery, {
        typeConversion: this._typeConversionMap,
        user: this._user,
        now: {sql: 'strftime(\'%Y-%m-%dT%H:%M:%SZ\',\'now\')'} // '2012-12-03T07:16:23Z'
      }, this._csn)

      return this._executeSQL(sql, values, getPostProcessMapper(this._toService, this._csn, newQuery))

      // The clients of this client are expecting a promise return in any case.
    } catch (err) {
      return Promise.reject(err)
    }
  }

  /**
   * Checks which of the sqlite3 is most fitting for the sql values combination.
   * @param {string} sql - Raw SQL query string
   * @param {Array} values - Array of DML values, which are added as query parameters
   * @param {Map} [postMapper] - SELECT post processing type conversion config
   * @returns {*}
   * @private
   */
  _executeSQL (sql, values, postMapper) {
    if (this._isStatementType('select', sql)) {
      return this._executeSelect(sql, values, postMapper)
    }

    // Only bulk inserts will have arrays in arrays
    if (this._isStatementType('insert', sql) && Array.isArray(values[0]) && values.length > 1) {
      return this._bulkInsert(sql, values)
    }

    return this._runSingle(sql, Array.isArray(values[0]) ? values[0] : values)
  }

  _isStatementType (type, sql) {
    // Regex is faster than toLower + trim + startsWith
    return (new RegExp(`^\\s*${type}`, 'i')).test(sql)
  }

  _executeSelect (sql, values, postMapper) {
    return new Promise((resolve, reject) => {
      // All is faster than each for us, as the result needs to be returned as whole.
      this._dbc.all(sql, values, (err, result) => {
        if (err) {
          return reject(new SqlError(err, sql, values))
        }

        resolve(postProcess(result, postMapper))
      })
    })
  }

  _runSingle (sql, values) {
    return new Promise((resolve, reject) => {
      this._dbc.run(sql, values, function (err) {
        if (err) {
          return reject(new SqlError(err, sql, values))
        }

        resolve(this.changes)
      })
    })
  }

  /**
   * One can not use more than 999 values per insert.
   * There is no build in bulk support of sqlite3.
   * This requires to split into multiple SQLs in case the total sum of values is greater than 999.
   */
  _bulkInsert (sql, values) {
    const valuesPerRow = values[0].length
    const placeholders = this._getBulkPlaceholders(valuesPerRow)
    const promises = []

    // In case 999 will be reached this vars will be reset
    let bulkSql = sql
    let flattenedValues = []

    for (const insert of values) {
      // Execute as adding this row would add more values than supported
      if ((flattenedValues.length + valuesPerRow) > 999) {
        promises.push(this._runSingle(bulkSql, flattenedValues))

        bulkSql = sql
        flattenedValues = []
      }

      // Array is empty on first run and after reset
      if (flattenedValues.length !== 0) {
        bulkSql += placeholders
      }

      flattenedValues.push(...insert)
    }

    // Ensure last bulk is executed
    promises.push(this._runSingle(bulkSql, flattenedValues))

    // Wait for all inserts to be done
    return Promise.all(promises)
      .then(() => {
        // return affected rows
        return values.length
      })
  }

  _getBulkPlaceholders (valuesPerRow) {
    const placeholders = []

    for (let i = 0; i < valuesPerRow; i++) {
      placeholders.push('?')
    }

    return `,(${placeholders.join(',')})`
  }

  _processExpand (cqn) {
    const sqls = []
    const expandQueries = createJoinCQNFromExpanded(cqn, this._csn)

    for (const cqn of expandQueries.queries) {
      cqn._conversionMapper = getPostProcessMapper(this._toService, this._csn, cqn)

      const {sql, values} = sqlFactory(cqn)
      sqls.push(this._executeSelect(sql, values, false))
    }

    return Promise.all(sqls)
      .then((results) => {
        return rawToExpanded(expandQueries, results)
      })
  }

  /**
   * Prepare SQL statement.
   *
   * @param {string} sql - SQL statement.
   * @returns {Promise} Promise, that resolves with SqliteStatement if successful and rejects if not.
   */
  prepareStatement (sql) {
    return new Promise((resolve, reject) => {
      this._dbc.serialize(() => {
        const stmt = this._dbc.prepare(sql, (err) => {
          if (err) {
            return reject(new SqlError(err, sql))
          }

          resolve(new SqliteStatement(stmt, this._dbc))
        })
      })
    })
  }

  /**
   * Returns connection state.
   *
   * @returns {boolean} true for connected, false for not connected
   */
  isConnected () {
    return this._dbc.open === true
  }

  /**
   * Set database locale.
   *
   * Locale is currently not supported by the node.js Sqlite driver.
   * There is a possibility to set locale in Sqlite, for example, in Java:
   * https://stackoverflow.com/questions/13720092/why-and-where-to-call-setlocale
   */
  setLocale () {
  }

  /**
   * Set database user.
   *
   * Username/password is not supported by default in Sqlite.
   */
  setUser (user) {
    this._user = user || 'anonymous'
  }

  /**
   * Execute begin transaction.
   *
   * @returns {Promise} - Resolves if begin is successful, rejects if not.
   */
  begin () {
    this._transCount++
    if (this._transCount === 1) {
      return this.execute('BEGIN')
    }

    return Promise.resolve()
  }

  /**
   * Execute commit transaction.
   *
   * @returns {Promise} - Resolves if commit is successful, rejects if not.
   */
  commit () {
    if (this._transCount === 0) {
      return Promise.resolve()
    }

    this._transCount--
    if (this._transCount === 0) {
      return this.execute('COMMIT')
    }

    return Promise.resolve()
  }

  /**
   * Execute rollback transaction.
   *
   * @returns {Promise} - Resolves if rollback is successful, rejects if not.
   */
  rollback () {
    if (this._transCount === 0) {
      return Promise.resolve()
    }

    this._transCount--
    if (this._transCount === 0) {
      return this.execute('ROLLBACK')
    }

    return Promise.resolve()
  }

  /**
   * Forwards deploy to the base class providing client information.
   * @param {Object|Promise} csn - the unreflected CSN or promise that will resolve into csn.
   * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
   */
  deploy (csn) {
    return super.deploy(csn, 'sqlite')
  }
}

module.exports = Client
