'use strict';

const i18nError = require('./i18n-error');
const propsUtils = require('./util-properties');

const odataAnnos = ['@Common.Label', '@Common.Heading', '@Common.QuickInfo',
  '@Common.Text', '@Core.Description', '@Core.LongDescription',
  '@Common.ValueList.Label', '@Common.ValueListMapping.Label', '@Communication.Address.country',
  '@UI.HeaderInfo.TypeName', '@UI.HeaderInfo.TypeNamePlural', '@UI.FieldGroup.Label',
  '@UI.DataPoint.Title', '@UI.DataPoint.Description', '@UI.DataPoint.LongDescription',
  '@UI.Chart.Title', '@UI.Chart.Description', '@UI.SelectionPresentationVariant.Text',
  '@UI.PresentationVariant.Text', '@UI.SelectionVariant.Text'];

/**
 * This method is the entry point to the exporting the localized annotations functionality.
 * Takes as a parameter the already parsed model in CSN format.
 * Returns a string as an output in a form of properties file:
 *  prop1 = value1
 *  prop2 = value2
 * 
 * Specifics for the property names are:
 *  1. Entities and nums are denoted with '..'
 *  2. Delimiter for subelements is '.'
 * 
 * For example(@A is localized annotation):
 *  "E": {
 *    "kind": "entity",
 *    "elements": {
 *      "a" : {
 *      "type": "cds.String",
 *      "@A": "annotations A in element a"
 *      },
 *      "b": {
 *        "elements": {
 *          "c": {
 *            "type": "cds.String",
 *            "@A": "annotations A in element b.c"
 *          } } } } }
 * 
 * the output will be:
 *  E..a@A = annotations A in element a
 *  E..b.c@A = annotations A in element b.c
 * 
 * Enum example input(@A is localized annotation):
 *  "E": {
 *    "enum":{
 *      "a":{
 *        "val": 0,
 *        "@A": "annotations A in enum's element a"
 *      },
 *      "b":{
 *        "val": 1,
 *        "@A": "annotations A in enum's element b"
 *      }
 *    }
 *  }
 * 
 * the ouput will be:
 * E..a@A = annotations A in enum's element a
 * E..b@A = annotations A in enum's element b
 * 
 * @param model
 */
function exportAnnotations(model) {
  let definitions = model.definitions;

  var localizedAnnotations = [...odataAnnos];
  var entries = [];

  createDefinitionsEntries(definitions, localizedAnnotations, entries);
  let annotations = localizedAnnotationsValues(localizedAnnotations, entries);
  if (Object.keys(annotations).length > 0) {
    return annotations;
  } else {
    throw new i18nError('There are no annotated elements with the defined localized annotations.');
  }
}

/**
 * Goes through the definitions and collects definitions path chain and belonging annotations, 
 * fill up the entries array with elements of the custom type Entry.
 * 
 * Fill up the localizedAnnotations array with the respective annotations from the model.
 * 
 * @param definitions 
 * @param localizedAnnotations 
 * @param entries 
 */
function createDefinitionsEntries(definitions, localizedAnnotations, entries) {
  for (let key in definitions) {
    let value = definitions[key];
    // collect annotations from all top level definition
    collectAnnotationsForObject(value, [key], entries);
    if (isStructured(value) && (isEntity(value) || isType(value)))
      intoStruct(value.elements, [key + '..'], false, entries, localizedAnnotations);
    if (isStructured(value) && isAnnotation(value))
      intoStruct(value.elements, [key + '.'], true, entries, localizedAnnotations);
    if (isStructured(value) && isView(value))
      intoStruct(value.elements, [key + '..'], false, entries, localizedAnnotations);
    if (isEnum(value))
      intoEnum(value.enum, [key + '..'], entries);
    if (isFunctionOrAction(value))
      intoAction(value, [key + '..'], entries, localizedAnnotations);
    if (isEntity(value) && has.call(value, 'actions')) {
      for (let a in value.actions)
        intoAction(value.actions[a], [key + '.$actions.', a], entries, localizedAnnotations, true);
    }
    if (isAnnotation(value) && isLocalized(value))
      localizedAnnotations.push('@' + key);
  }
}

function intoAction(action, parents, entries, localizedAnnotations, isBound) {
  if (isBound) {
    collectAnnotationsForObject(action, parents, entries);
  }
  // when return type is inline structured
  if (has.call(action, 'returns') && isStructured(action.returns)) {
    if (isBound)
      parents.push('.');
    intoStruct(action.returns.elements, parents, false, entries, localizedAnnotations);
  }
  if (has.call(action, 'params')) {
    if (isBound)
      parents.push('.$param.')
    else {
      let last = parents.pop();
      last = last.slice(0, -1);
      parents.push(last, '$param.');
    }
    for (let p in action.params) {
      parents.push(p);
      collectAnnotationsForObject(action.params[p], parents, entries);
      parents.pop();
    }
  }
  parents.pop();
}

/**
 * Dive recursivly into structured element.
 * 
 * @param elements 
 * @param parents 
 * @param isAnnotation 
 * @param entries 
 * @param localizedAnnotations 
 */
function intoStruct(elements, parents, isAnnotation, entries, localizedAnnotations) {
  for (let key in elements) {
    let value = elements[key];
    if (isStructured(value)) {
      parents.push(key + '.');
      intoStruct(value.elements, parents, isAnnotation, entries, localizedAnnotations)
    } else if (isEnum(value)) {
      parents.push(key + '.');
      intoEnum(value.enum, parents, entries);
    } else {
      parents.push(key);
    }
    collectAnnotationsForObject(value, parents, entries);
    if (isAnnotation && isLocalized(value)) {
      localizedAnnotations.push('@' + parents.join(''));
    }
    parents.pop();
  }
}

/**
 * Loops into enum definition.
 * 
 * @param enumElem 
 * @param parents 
 * @param entries 
 */
function intoEnum(enumElem, parents, entries) {
  for (let key in enumElem) {
    let value = enumElem[key];
    if (value && value.val && isStructured(value.val)) {
      parents.push(key + '.');
      intoStruct(value.val.elements, parents, false, entries);
      collectAnnotationsForObject(value, parents, entries);
    } else if (value && value.val && isEnum(value.val)) {
      parents.push(key + '.');
      intoEnum(value.val.enum, parents);
      collectAnnotationsForObject(value, parents, entries);
    } else if (value) {
      parents.push(key);
      if (value.val)
        collectAnnotationsForObject(value.val, parents, entries);
      collectAnnotationsForObject(value, parents, entries);
    }
    parents.pop();
  }
}

/**
 * Collects all annotations for a given object.
 * 
 * @param obj 
 * @param parents 
 * @param entries 
 */
function collectAnnotationsForObject(obj, parents, entries) {
  let annotations = Object.keys(obj).filter(key => key.includes('@'));
  if (annotations.length) {
    let entry = new Entry(JSON.parse(JSON.stringify(parents)));
    annotations.forEach(anno => {
      if ((obj.origin && Object.keys(obj.origin._artifact).filter(key => key.includes('@')).includes(anno))
        && (obj[anno] === obj.origin._artifact[anno])) // if the same annotation assignment is not overridden in the view/projection
        return;
      entry[anno] = obj[anno];
    })
    entries.push(entry);
  }
}

class Entry {
  constructor(path) {
    this.path = path;
  }

  getPathAsString() {
    let path = this.path.join('');
    return path.endsWith('.') ?
      path.slice(0, -1)
      : path;
  }
}

/**
 * Collect localized annotations values from the model's entries.
 * 
 * @param localizedAnnotations 
 * @param entries 
 */
function localizedAnnotationsValues(localizedAnnotations, entries) {
  let result = Object.create(null);
  entries.forEach(entry => {
    let annotations = annotationsInElement(localizedAnnotations, Object.keys(entry));
    if (annotations.length) {
      annotations.forEach(anno => {
        if (entry[anno] instanceof Object && has.call(entry[anno], '='))
          return;
        else
          result[forOutput(entry.getPathAsString()) + '@' + forOutput(anno.substring(1))] = entry[anno].val;
      });
    }
  });
  return result;
}

/**
 * Makes an intersection between the array containing all localized
 * annotations and an object's properties in order to be determined if element
 * is annotated with localized annotation(s).
 * 
 * @param localizedAnnotations 
 * @param properties 
 */
function annotationsInElement(localizedAnnotations, properties) {
  let result = localizedAnnotations.map((anno) => {
    return filterLocalizedAnnos(anno);
  });
  return Array.from(new Set(result)).filter(n => n);

  function filterLocalizedAnnos(anno) {
    if (properties.indexOf(anno) !== -1)
      return anno;
    // if there is annotation with variants
    let re = new RegExp(anno + '#.+', 'g');
    let p = properties.find((prop) => {
      return re.test(prop);
    })
    if (p && p.length > 0) {
      return p;
    }
    return undefined;
  }
}

/**
 * Prepare the string for outputing
 * 
 * @param path 
 */
function forOutput(path) {
  // escape the a backslash when it is escaping a backslash, e.g. '\\ ' -> '\\\ '
  path = path.replace(String.fromCharCode(92), String.fromCharCode(92, 92));
  // escape the ':' as it is saved character in the Javaspec for properties file
  path = propsUtils.escapeSymbolInString(path, ':');
  // escape the '=' for the same reason
  path = propsUtils.escapeSymbolInString(path, '=');
  // escape the whitespaces
  path = propsUtils.escapeAllInString(path, /\s+/g);
  return path;
}


const has = Object.prototype.hasOwnProperty;

function isAnnotation(elem) {
  return has.call(elem, 'kind') && elem.kind === 'annotation';
}

function isLocalized(elem) {
  return (has.call(elem, 'localized') && elem.localized && elem.localized.val) ||
    (has.call(elem, 'type') && !has.call(elem, 'builtin') && has.call(elem.type, '_artifact') && isLocalized(elem.type._artifact));
}

function isStructured(elem) {
  return has.call(elem, 'elements');
}

function isEntity(elem) {
  return (has.call(elem, 'kind') && elem.kind === 'entity') ||
    (has.call(elem, 'type') && elem.type === 'cds.Entity');
}

function isView(elem) {
  return elem.kind && elem.kind === 'view';
}

function isEnum(elem) {
  return has.call(elem, 'enum');
}

function isFunctionOrAction(elem) {
  return has.call(elem, 'kind') && (elem.kind === 'action' || elem.kind === 'function');
}

function isType(elem) {
  return has.call(elem, 'kind') && elem.kind === 'type';
}

module.exports = exportAnnotations;
