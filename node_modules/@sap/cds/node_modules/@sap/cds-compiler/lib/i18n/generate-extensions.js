const propsUtils = require('./util-properties');

/**
 * 
 * The main method for generation of CSN extensions from a given properties file.
 * Takes as a parameter the content of a property file.
 * Returns an augmented CSN.
 * 
 */
function generateExts(content, source) {
  let targets = Object.create(null);
  let model = generate.extensionsWrapper();
  let props = propsUtils.readProperties(content, model, source, source !== '<code>');

  for (let key in props) {
    addToTargets(key, props[key], targets);
  }

  let extensions = createExtensions(targets, source);
  model.extensions = extensions;
  model.$frontend = 'i18n';
  return model;
}

/**
 * 
 * Fill up the target object with parsed elements from passed line of the input file.
 *
 */
function addToTargets(key, value, targets) {
  let atIndex = propsUtils.unescapedSymbolIndex(key, '@');
  let assignee = key.substring(0, atIndex);
  let anno = key.substring(atIndex);

  if (assignee.includes('..')) {
    addStructiredTarget(assignee, targets, anno, value);
  } else if (assignee.includes('.$actions.') || assignee.includes('.$param.')) {
    addActionToTargets(assignee, anno, value, targets);
  } else {
    addTopLevelTarget(assignee, targets, anno, value);
  }

  function addStructiredTarget(assignee, targets, anno, value) {
    let [def, elements] = assignee.split('..');
    let subElems = elements.split('.');
    let objToExtend = targets[def] ? targets[def] : targets[def] = Object.create(null);

    subElems.forEach(elem => {
      let temp = objToExtend[elem] ? objToExtend[elem] : objToExtend[elem] = Object.create(null);
      objToExtend = temp;
    });

    addAnnotation(objToExtend, anno, value);
  }

  function addTopLevelTarget(assignee, targets, anno, value) {
    if (targets[assignee])
      addAnnotation(targets[assignee], anno, value);
    else {
      targets[assignee] = Object.create(null);
      addAnnotation(targets[assignee], anno, value);
    }
  }

  function addActionToTargets(assignee, anno, value, targets) {
    if (assignee.includes('.$actions.')) /* bound action/function */ {
      let [art, rest] = assignee.split('.$actions.');
      let objToExtend = targets[art] ? targets[art] : targets[art] = Object.create(null);

      if (!objToExtend.actions)
        objToExtend.actions = Object.create(null);

      if (rest.includes('.$param.')) /* bound action/function parameter */ {
        let [act, param] = rest.split('.$param.');

        objToExtend.actions[act] ? objToExtend.actions[act] : objToExtend.actions[act] = Object.create(null);
        let obj = objToExtend.actions[act].params ? objToExtend.actions[act].params : objToExtend.actions[act].params = Object.create(null);
        obj[param] ? addAnnotation(obj[param], anno, value) : addAnnotation(obj[param] = Object.create(null), anno, value);
      } else if (rest.includes('.')) /* bound action/function return element */ {
        let elems = rest.split('.');
        let act = elems.splice(0, 1);

        if (!objToExtend.actions[act])
          objToExtend.actions[act] = Object.create(null);
        if (!objToExtend.actions[act].returns)
          objToExtend.actions[act].returns = Object.create(null);

        if (elems.length > 1) {
          let first = elems.shift();
          let temp = objToExtend.actions[act].returns[first] ?
            objToExtend.actions[act].returns[first]
            : objToExtend.actions[act].returns[first] = Object.create(null);
          elems.forEach(e => {
            temp = temp[e] = Object.create(null);
          });
          addAnnotation(temp, anno, value);
        } else {
          if (!objToExtend.actions[act].returns[elems[0]])
            objToExtend.actions[act].returns[elems[0]] = Object.create(null);
          addAnnotation(objToExtend.actions[act].returns[elems[0]], anno, value);
        }

      } else /* bound action/function itself */ {
        objToExtend.actions[rest] ?
          addAnnotation(objToExtend.actions[rest], anno, value)
          : addAnnotation(objToExtend.actions[rest] = Object.create(null), anno, value);
      }
    } else if (assignee.includes('.$param.')) /* unbound action/function parameter */ {
      let [act, param] = assignee.split('.$param.');
      let objToExtend = targets[act] ? targets[act] : targets[act] = Object.create(null);

      if (!objToExtend.params)
        objToExtend.params = Object.create(null);

      let p = objToExtend.params[param] ? objToExtend.params[param] : objToExtend.params[param] = Object.create(null);
      addAnnotation(p, anno, value);
    }
  }

  function addAnnotation(assignee, anno, value) {
    let temp = assignee[anno] = Object.create(null);
    Object.assign(temp, value);
  }
}

function createExtensions(targets, source) {
  let result = [];
  for (let key in targets) {
    let value = targets[key];
    let ext = generateExtension(key, value, source, { filename: source });
    ext.obj.location = { filename: source, start: ext.startLocation, end: ext.endLocation };
    result.push(ext.obj);
  }
  return result;

  function generateExtension(key, value, source, location) {
    let ext = generate.extension(key, location, true);
    let startLocation = {};
    let endLocation = {};

    for (let prop in value) {
      let valueObj = value[prop];

      // annotate the top level artifact
      if (prop.startsWith('@')) {
        if (!startLocation.offset)
          startLocation = location.start = { offset: valueObj.line, line: valueObj.line, column: valueObj.start };
        endLocation = location.end = { offset: valueObj.line, line: valueObj.line, column: valueObj.end };
        ext.annotationAssignments.push(generate.annotationAssignment(prop.substring(1), valueObj, source));
      } else if (prop === 'actions') { // bound actions
        if (!ext.actions)
          ext.actions = Object.create(null);
        let acts = createActions(valueObj, JSON.parse(JSON.stringify(location)));
        Object.assign(ext.actions, acts.obj);
        startLocation = acts.startLocation;
        endLocation = acts.endLocation;
      } else if (prop === 'params') { // unbound param
        if (!ext.params)
          ext.params = Object.create(null);
        let param = createParams(valueObj, JSON.parse(JSON.stringify(location)));
        Object.assign(ext.params, param.obj);
        startLocation = param.startLocation;
        endLocation = param.endLocation;
      } else if (prop === 'returns') { // unbound return
        if (!ext.returns)
          ext.returns = Object.create(null);
        if (!ext.returns.elements)
          ext.returns.elements = Object.create(null);
        Object.assign(ext.returns.elements, createStruct(prop, valueObj, location));
      } else { // structured definition
        if (!ext.elements)
          ext.elements = Object.create(null);
        let elems = createStruct(prop, valueObj, location);
        Object.assign(ext.elements, elems.elements);
        if (!startLocation.offset)
          startLocation = elems.startLocation;
        endLocation = elems.endLocation;
      }
    }

    ext.location.start = startLocation;
    ext.location.end = endLocation;
    return { obj: ext, location: location, startLocation: startLocation, endLocation: endLocation };

    function createActions(valueObj, location) {
      let startLocation = {};
      let endLocation = {};
      let result = Object.create(null);

      for (let actName in valueObj) {
        let act = valueObj[actName];
        let actLocation = {};
        let temp = generate.action(actName, actLocation);
        for (let p in act) {
          if (p === 'params') {
            temp[actName].params = Object.create(null);
            let param = createParams(act[p], JSON.parse(JSON.stringify(location)));
            Object.assign(temp[actName].params, param.obj);
            if (!location.start)
              location.start = param.startLocation;
            location.end = param.endLocation;
          } else if (p === 'returns') {
            let elems = createStruct(p, act[p], location);
            Object.assign(temp[actName], elems.elements);
            if (!location.start)
              location.start = elems.startLocation;
            location.end = elems.endLocation;
          } else if (p.startsWith('@')) {
            if (!location.start)
              location.start = { offset: act[p].line, line: act[p].line, column: act[p].start };
            location.end = { offset: act[p].line, line: act[p].line, column: act[p].end };
            temp[actName].annotationAssignments.push(generate.annotationAssignment(p.substring(1), act[p], source));
          }
        }
        Object.assign(actLocation, location);
        if (!startLocation.offset)
          startLocation = actLocation.start;
        endLocation = actLocation.end;
        location = { filename: location.filename };
        Object.assign(result, temp);
      }
      return { obj: result, startLocation: startLocation, endLocation: endLocation };
    }

    function createParams(params, location) {
      let result = Object.create(null);
      for (let pa in params) {
        result[pa] = generate.actions.param(pa, location);
        for (let anno in params[pa]) {
          if (!location.start)
            location.start = { offset: params[pa][anno].line, line: params[pa][anno].line, column: params[pa][anno].start };
          location.end = { offset: params[pa][anno].line, line: params[pa][anno].line, column: params[pa][anno].end };

          result[pa].annotationAssignments.push(generate.annotationAssignment(anno.substring(1), params[pa][anno], source));
        }
      }
      return { obj: result, startLocation: location.start, endLocation: location.end };
    }

    function createStruct(name, value, location) {
      let t = Object.create(null);
      for (let p in value) {
        if (p === 'returns')
          continue;
        if (p.startsWith('@')) {
          location.start = { offset: value[p].line, line: value[p].line, column: value[p].start };
          location.end = { offset: value[p].line, line: value[p].line, column: value[p].end };

          if (!t[name])
            t[name] = generate.extension(name, JSON.parse(JSON.stringify(location)));

          t[name].annotationAssignments.push(generate.annotationAssignment(p.substring(1), value[p], source));
        } else {
          let elems = createStruct(p, value[p], location);
          if (!t[name])
            t[name] = generate.extension(name, JSON.parse(JSON.stringify(location)));
          if (!t[name].elements)
            t[name].elements = Object.create(null);
          Object.assign(t[name].elements, elems.elements);
          location.end = elems.endLocation;
        }
      }
      return { elements: t, startLocation: JSON.parse(JSON.stringify(location.start)), endLocation: JSON.parse(JSON.stringify(location.end)) };
    }
  }
}

let generate = {
  extensionsWrapper: function () {
    return {
      kind: "source",
      extensions: [],
      messages: []
    }
  },
  extension: function (key, location, isMainArtifact) {
    return {
      location,
      name: isMainArtifact
        ? { absolute: key, location }
        : { path: [{ id: key, location }], location },
      annotationAssignments: [],
      kind: 'annotate'
    }
  },
  annotationAssignment: function (name, valueObj, source) {
    let location = {
      filename: source,
      start: { offset: valueObj.line, line: valueObj.line, column: valueObj.start },
      end: { offset: valueObj.line, line: valueObj.line, column: valueObj.end }
    };
    return {
      name: {
        absolute: name,
        location
      },
      priority: 'i18n',
      value: {
        literal: 'string',
        val: valueObj.val,
        location
      },
      location
    }
  },
  action: function (name, location) {
    let obj = Object.create(null);
    obj[name] = {
      name: { id: name, location: location },
      location: location,
      annotationAssignments: [],
      kind: 'annotate'
    };
    return obj;
  },
  actions: {
    param: function (name, location) {
      return {
        name: { id: name, location },
        location,
        annotationAssignments: [],
        kind: 'annotate'
      };
    },
    returns: function (name, location) {
      return {
        name: { id: name, location },
        location,
        annotationAssignments: [],
        kind: 'annotate',
        elements: Object.create(null)
      };
    }
  }
}

module.exports = generateExts;
