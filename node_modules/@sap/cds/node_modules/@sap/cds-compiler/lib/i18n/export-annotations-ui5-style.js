'use strict';

const walker = require('../json/walker');
const propsUtils = require('./util-properties');
const odataAnnos = ['@Common.Label', '@Common.Heading', '@Common.QuickInfo',
  '@Common.Text', '@Core.Description', '@Core.LongDescription',
  '@Common.ValueList.Label', '@Common.ValueListMapping.Label', '@Communication.Address.country',
  '@UI.HeaderInfo.TypeName', '@UI.HeaderInfo.TypeNamePlural', '@UI.FieldGroup.Label',
  '@UI.DataPoint.Title', '@UI.DataPoint.Description', '@UI.DataPoint.LongDescription',
  '@UI.Chart.Title', '@UI.Chart.Description', '@UI.SelectionPresentationVariant.Text',
  '@UI.PresentationVariant.Text', '@UI.SelectionVariant.Text'];

function exportAnnotations(model) {
  // collect localized annos from the model
  let localAnnos = collectLocAnnos(model.definitions);
  localAnnos.push(...odataAnnos);

  let properties = Object.create(null);
  // walk through the annotation assignments
  walker.walk(model.definitions, (isNode, elem) => {
    if (isNode) {
      let annos = takeAnnotations(elem);
      if (annos && annos.length > 0 && !isAnnotate(elem)) {
        annos.forEach(a => {
          let annoName = getAbosoluteName(elem[a]);
          if (localAnnos.includes(annoName))
            processI18nEntry(elem[a], properties, elem.name ? elem.name.id : '');
        })
      }
    }
  });
  model.properties = properties;
  return model;
}

const takeAnnotations = function (obj) {
  return Object.keys(obj).filter(prop => {
    return prop.startsWith('@') ? prop : undefined;
  })
}

const processI18nEntry = function (anno, properties, elemName) {
  if (!anno.val)
    return;
  if (anno.literal && anno.literal !== 'string')
    return;
  if (anno.name && anno.name.path) {
    let propName = `${elemName}_${anno.name.path[anno.name.path.length - 1].id}` || '';
    propName = propsUtils.escapeSymbolInString(propName, ':');
    propName = propsUtils.escapeSymbolInString(propName, '=');
    propName = propsUtils.escapeAllInString(propName, /\s+/g);
    if (properties[propName]) {
      let names = Object.keys(properties)
        .filter(n => {
          return n.includes(propName);
        });
      let indices = names.map(i => {
        return parseInt(i.slice(-1));
      })
        .filter(i => {
          return !!i;
        });
      let index = Math.max(...indices);
      propName = index === -Infinity ? `${propName}1` : `${propName}${index + 1}`;
    }
    if (anno.val && !anno.val.includes('{i18n>')) {
      properties[propName] = JSON.parse(JSON.stringify(anno.val));
      anno.val = `{i18n>${propName}}`;
    }
  }
}

const collectLocAnnos = function (definitions) {
  let result = [];
  walker.walkNodesEx(definitions, (value) => {
    if (isLocalizedAnno(value))
      result.push(getElemAbsName(value));
    if (isStructAnno(value))
      return value.elements;
    return '';
  });
  return result;
}

const isAnnotate = function (obj) {
  return obj.kind && obj.kind === 'annotate';
}

const isLocalizedAnno = function (obj) {
  if (obj.kind && (obj.kind === 'annotation' || obj._main && obj._main.kind && obj._main.kind === 'annotation')) {
    let localized = obj.localized || (obj._finalType && obj._finalType.localized);
    return !!(localized && localized.val);
  }
  return false;
}

const isStructAnno = function (obj) {
  if (obj.kind && (obj.kind === 'annotation' || obj._main && obj._main.kind && obj._main.kind === 'annotation'))
    if (obj.elements)
      return true;
  return false;
}

const getAbosoluteName = function (obj) {
  if (!obj.name)
    return '';
  if (obj.name.absolute)
    return obj.name.absolute;
  if (obj._block && obj.name.id)
    return `${getAbosoluteName(obj._block)}.${obj.name.id}`;
  if (obj.name.path)
    return obj.name.path.map(elem => {
      return elem.id;
    }).join('.');
  return '';
}

const getElemAbsName = function (obj) {
  if (!obj.name)
    return '';
  if (obj.name.absolute)
    return obj.name.element ? `${obj.name.absolute}.${obj.name.element}` : obj.name.absolute;
  return '';
}

module.exports = exportAnnotations;
