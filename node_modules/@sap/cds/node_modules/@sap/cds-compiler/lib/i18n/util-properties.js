const i18nError = require('./i18n-error');
const { CompileMessage } = require('../base/messages');

/**
 * Parse content of a property file.
 * Ignores blank lines and comments.
 * Returns an object containing all valid properties lines.
 * 
 * Example input:
 * T1@A=Dog
 * E..a@A=Mouse
 * E..c.y@A=Elephant
 * 
 * Return:
 * { 'T1@A': { line: 1, val: 'Dog', start: 1, end: 10 },
 *   'E..a@A': { line: 2, val: 'Mouse', start: 1, end: 14 },
 *   'E..c.y@A': { line: 3, val: 'Elephant', start: 1, end: 19 } }
 * @param {String} content 
 */
function readProperties(content, model, source, isCommand) {
  let result = Object.create(null);
  // Split into lines (regardless of platform, accept Unix, Mac and Windows style ... sigh)
  let lines = content.match(/[^\r\n]+/g);
  let lineCounter = 0;
  lines.forEach(line => {
    line.trim();
    lineCounter++;
    // comments are ignored
    if (isComment(line))
      return;
    //blank lines are ignored
    if (isBlankLine(line))
      return;
    if (!(line.includes('@') && line.includes('='))) {
      let msg = 'There is a property not in the desirable format. The properties should be in the form  of:'
        + '<target>@<annotation>=[<value>]';
      let location = {
        filename: source,
        start: { offset: lineCounter, line: lineCounter, column: 1 },
        end: { offset: lineCounter, line: lineCounter, column: line.length }
      }
      if (isCommand) {
        model.messages.push(new CompileMessage(location, msg));
        return;
      } else {
        throw new i18nError(msg);
      }
    }
    parseProp(line, result, lineCounter);
  });
  return result;
}

/**
 * Parse a line from the property file, but as it is done in the Java world. 
 * @param {String} line 
 * @param {Object} result 
 */
function parseProp(line, result, lineCounter) {
  let limit = line.length;
  let keyLen = 0;
  let valueStart = limit;
  let char = 0;
  let hasSep = false;
  let precedingBackslash = false;

  while (keyLen < limit) {
    char = line[keyLen];
    if ((char === '=' || char === ':') && !precedingBackslash) {
      valueStart = keyLen + 1;
      hasSep = true;
      break;
    } else if ((char === ' ' || char === '\t' || char === '\f') && !precedingBackslash) {
      valueStart = keyLen + 1;
      break;
    }
    if (char === '\\') {
      precedingBackslash = !precedingBackslash;
    } else {
      precedingBackslash = false;
    }
    keyLen++;
  }
  while (valueStart < limit) {
    char = line[valueStart];
    if (char !== ' ' && char !== '\t' && char !== '\f') {
      if (!hasSep && (char === '=' || char === ':')) {
        hasSep = true;
      } else {
        break;
      }
    }
    valueStart++;
  }
  let temp = result[unescapeAllSpecialChars(line.substring(0, keyLen))] = Object.create(null);
  temp.line = lineCounter;
  temp.val = line.substring(valueStart);
  temp.start = 1;
  temp.end = line.length;
  // result[line.substring(0, keyLen)] = line.substring(valueStart);
}

/**
 * "A comment line has an ASCII '#' or '!' as its first non-white space character;
 * comment lines are also ignored and do not encode key-element information."
 * source: https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#load-java.io.Reader-
 * @param {String} line 
 */
function isComment(line) {
  return line.startsWith('#') || line.startsWith('!');
}

function isBlankLine(line) {
  return line.trim() === '';
}


/**
 * Return the first index of symbol, where it is not escaped with a backslash.
 * -1 is returned if there is no such.
 * 
 * @param {String} string 
 * @param {String} symbol 
 */
function unescapedSymbolIndex(string, symbol) {
  if (!string.includes(symbol))
    return -1;
  let indices = [];
  for (let i = 0; i < string.length; i++) {
    if (string[i] === symbol)
      indices.push(i);
  }
  indices = indices.filter(i => {
    if (!(string[i - 1] === '\\'))
      return i;
    return undefined;
  })
  return indices[0] || -1;
}

/**
 * Add backslash before all the matches
 * of the passed as second argument regular expression.
 * 
 * @param {String} str
 * @param {RegExp} re 
 */
function escapeAllInString(str, re) {
  if (!(re instanceof RegExp)) {
    throw new Error('Passed argument is not instance of RegExp');
  }
  let matches = Array.from(new Set(str.match(re)));
  matches.forEach(e => {
    str = escapeSymbolInString(str, e);
  })
  return str;
}

/**
 * Add backslash before all the occurrences
 * of the passed second argument.
 * 
 * @param {String} string 
 * @param {String} symbol 
 */
function escapeSymbolInString(string, symbol) {
  let re = new RegExp(symbol, 'g');
  return string.replace(re, '\\' + symbol);
}

function escapeAllJavaPropsChars(str) {
  // escape a backslash when it is escaping a backslash, e.g. '\\ ' -> '\\\ '
  str = str.replace(/\\/g, String.fromCharCode(92, 92));
  // escape the ':' as it is saved character in the Javaspec for properties file
  str = escapeSymbolInString(str, ':');
  // escape the '=' for the same reason
  str = escapeSymbolInString(str, '=');
  // escape the whitespaces
  str = escapeAllInString(str, /\s+/g);
  return str;
}

/**
 * Unescape all special to javaprops, CDS, JSON characters.
 * @param {String} str 
 */
function unescapeAllSpecialChars(str) {
  str = unescapeJavaPropsChars(str);
  str = unescapeJSONStringChars(str);
  return str
}

function unescapeJavaPropsChars(str) {
  str = str.replace(/\\:/g, ':');
  str = str.replace(/\\=/g, '=');
  str = str.replace(/\\\s/g, ' ');
  return str;
}

function unescapeJSONStringChars(str) {
  str = str.replace(/\//g, '/');
  str = str.replace(/"/g, '"');
  str = str.replace(String.fromCharCode(92, 92), String.fromCharCode(92));
  return str;
}

module.exports = {
  readProperties,
  unescapeAllSpecialChars,
  unescapedSymbolIndex,
  escapeAllJavaPropsChars,
  escapeAllInString,
  escapeSymbolInString
};