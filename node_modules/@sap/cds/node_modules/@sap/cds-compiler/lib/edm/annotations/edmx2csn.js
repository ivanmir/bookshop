'use strict';

// translate edmx that is supposed to contain only annotations to an extension csn

var xmlParser = require('./xmlParser')
const g_dict = require('./vocabularies/Dictionary.json');

function translateToCsn(xml) {
  let xmljs = xmlParser.xmlToJs(xml);
  let csn = {};
  handleGeneric(xmljs);
  let extCsn = turnIntoExtension(csn);
  return extCsn;

  // result:
  //  one entry for each annotated thing ("target"),
  //  key is target name (original string from edmx, i.e. element paths are
  //    separated with "/")
  //  value is object (dictionary) with annotation names as property names
  //  annotations are flattened, qualifiers are part of annotation name
  //  flattening stops at arrays

  // add to result groups according to target (full path name)
  // -> annotations for a target come one by one and are here
  //    added to the same object

  function addToResult(target, anno) {
    getOrAddSubobjects(csn, target)["@"+anno.term] = anno.val
  }

  function getOrAddSubobjects(obj, path) {
    // return property "name" of obj
    // if it doesn't exist, first create it as empty object
    function getOrAddSubobject(obj, name) {
      if (obj[name] == undefined) obj[name] = {};
      return obj[name]; 
    }

    let parts = path.split('/');
    for (let i=0; i<parts.length; i++) {
      if (i>0) obj = getOrAddSubobject(obj, "elements")
      obj = getOrAddSubobject(obj, parts[i]);
    }
    return obj;
  }

  function turnIntoExtension(csnBase) {
    let exts = { extensions: [] }
    for (let t in csnBase) {
      let ext = {
        kind: "annotate",
        target: t
      }
      Object.assign(ext, csnBase[t]);
      exts.extensions.push(ext);
    }
    return exts;
  }


  /***********************************************************************************************

  anatomy of edmx
  <dummy>
    - optional artificial top level element to group several <Annonations ...>
      (xml parser cannot deal with multiple top level entries)

  <Annotations ...>
    - always has attribute "Target"
    - has elements <Annotation ...>

  <Annotation ...>
    - always has attribute "Term"
    - has EITHER one other attribute OR one element that is not itself an <Annotation ...>
    - can have elements <Annotation ...>

  <Record ...>
    - can have attribute "Type"
    - can have elements <PropertyValue ...>
    - can have elements <Annotation ...>

  <PropertyValue ...>
    - always has attribute "Property"
    - has EITHER one other attribute OR one element <Collection> or <Record ...>

  <Collection>
    - has elements

  ***********************************************************************************************/

  // generic handler function, call specific handler based on
  //   the element kind
  function handleGeneric(obj, expType) {
    const handlers = {
      Annotations   : handleAnnotations,
      Annotation    : handleAnnotation,
      Record        : handleRecord,
      //PropertyValue : handlePropertyValue, -> called directly
      Collection    : handleCollection,
      dummy                  : obj => obj["$elements"].map(handleGeneric),
      "edmx:Edmx"            : obj => obj["$elements"].map(handleGeneric),
      "edmx:Reference"       : obj => obj,
      "edmx:DataServices"    : obj => obj["$elements"].map(handleGeneric),
      Schema                 : obj => obj["$elements"].map(handleGeneric),
      String                 : obj => handleValue("String", obj["$value"]),
      PropertyPath           : obj => handleValue("PropertyPath", obj["$value"]),
      NavigationPropertyPath : obj => handleValue("NavigationPropertyPath", obj["$value"]),
      AnnotationPath         : obj => handleValue("AnnotationPath", obj["$value"])
    };
    return handlers[obj["$kind"]](obj, expType);
  }

  function handleAnnotations(obj) {
    for (let e of obj["$elements"]) {
      handleAnnotation(e, anno=>addToResult(obj["Target"], anno));
    }
  }

  function handleAnnotation(obj, add) {
    let term = obj["Term"];

    let dictTerm = g_dict.terms[term];
    let dictTermType = dictTerm.Type;

    let qualifier = obj["Qualifier"];
    if (qualifier) term += '#' + qualifier;

    let val = null;

    // attribute?
    let attribs = Object.keys(obj).filter(x => x != "$kind" && x != "Term" && x != "Qualifier" && x != "$elements");
    if (attribs.lenght > 1) throw "too many attributes";
    let attribName = attribs[0];
    if (attribName) {
      val = handleValue(attribName, obj[attribName]);
    }

    // element?
    let nestedAnnos = [];
    if (obj["$elements"] != undefined) {
      nestedAnnos = obj["$elements"].filter(x => x["$kind"] == "Annotation");

      let otherElems = obj["$elements"].filter(x => x["$kind"] != "Annotation");
      if (otherElems.length>0 && attribName) throw "attribute AND elements";
      if (otherElems.length>1) throw "too many elements";
      if (otherElems.length>0) {
        val = handleGeneric(otherElems[0], dictTermType)
      }
    }

    // handle nested annos
    if (nestedAnnos.length > 0) {
      if (Array.isArray(val)) {
        throw "nested anno at array"
      }

      if (!isRecord(val)) {
        // scalar value => turn into pseudo-struct
        val = { "$value": val }
      }
      for (let a of nestedAnnos) {
        handleAnnotation(a, ax => val['@'+ax.term] = ax.val);
      }
    }

    // flatten
    (function flatten(term, val) {
      if (isRecord(val)) {
        for (let p in val) {
          flatten(term + '.' + p, val[p])
        }
      }
      else {
        add({ term: term, val: val})
      }
    })(term, val);

    function isRecord(val) {
      return ( val instanceof Object &&
               !Array.isArray(val) &&
               !(Object.keys(val).length == 1 && val["="] != undefined) &&
               !(Object.keys(val).length == 1 && val["#"] != undefined) );
    }
  }


  // input: obj representing an edmx:Record
  // output: js object
  function handleRecord(obj, dictTypeName) {
    let newObj = {};

    // explicit type required?
    let dictType = dictTypeName ? g_dict.types[dictTypeName] : null;
    if (dictType && dictType.Abstract) {
      newObj["$Type"] = obj["Type"];
    }

    let elements = obj["$elements"];
    if (elements) {
      if (elements.find(x => x["$kind"] != "PropertyValue" && x["$kind"] != "Annotation") != null) throw "unexpected element kind " + JSON.stringify(elements, null, 2);

      let elemPropVal = elements.filter(x => x["$kind"] == "PropertyValue");
      for (let p of elemPropVal) {
        let res = handlePropertyValue(p);
        newObj[res.name] = res.value;
      }

      let elemAnno = elements.filter(x => x["$kind"] == "Annotation");
      for (let a of elemAnno) {
        handleAnnotation(a, ax => newObj['@'+ax.term] = ax.val);
      }
    }

    return newObj;
  }


  // input: obj representing xml element <PropertyValue ...>
  function handlePropertyValue(obj) {
    let val = null;

    // attribute?
    let attribs = Object.keys(obj).filter(x => x != "$kind" && x != "Property" && x != "$elements");
    if (attribs.lenght > 1) throw "too many attributes";
    let attribName = attribs[0];
    if (attribName) {
      val = handleValue(attribName, obj[attribName]);
    }

    // element?
    let elem = null;
    if (obj["$elements"] != undefined) {
      if (attribName) throw "attribute AND elements";
      if (obj["$elements"].length>1) throw "too many elements";
      elem = obj["$elements"][0];
      val = handleGeneric(elem)
    }

    return {name: obj["Property"], value: val}
  }


  function handleCollection(obj, dictType) {
    let expType = dictType ? dictType.match(/^Collection\((.+)\)/)[1] : null;
    return obj["$elements"] ? obj["$elements"].map(x => handleGeneric(x, expType)) : [];
  }


  // input: simple value
  // output: representation of this value in csn
  function handleValue(name, val) {
    const handlers = {
      String                : val => val,
      Bool                  : val => val == "true",
      Byte                  : val => parseInt(val),
      Int                   : val => parseInt(val),
      Decimal               : val => parseFloat(val),
      Float                 : val => parseFloat(val),
      EnumMember            : val => handleEnumValue(val),
      Path                  : val => ({ "=": val.replace(/\//g, '.') }),
      PropertyPath          : val => ({ "=": val.replace(/\//g, '.') }),
      NavigationPropertyPath: val => ({ "=": val.replace(/\//g, '.') }),
      AnnotationPath        : val => ({ "=": val })
    };
    return handlers[name](val);

    function handleEnumValue(val) {
      // is this a multi enum value?
      let es = val.split(' ').map(x => ({ "#": x.match(/\/(.*)$/)[1] }));
      return es.length == 1 ? es[0] : es;
    }
  }
}

module.exports = { translateToCsn };
