'use strict'

const glue = require('./glue.js')

class Node {

  static create(v, details=Object.create(null), csn=undefined)
  {
    return new this(v, details, csn);
  }

  constructor(v, attributes=Object.create(null), csn=undefined)
  {
    if(!attributes || typeof attributes !== 'object')
      throw "Please debug me: attributes must be a dictionary"
    if(!(v instanceof Array))
      throw "Please debug me: v is either undefined or not an array: " + v;
    if(v.filter(v=>v).length != 1)
      throw "Please debug me: exactly one version must be set"
    Object.assign(this, attributes);
    this.set({ _children: [], _xmlOnlyAttributes: Object.create(null), _jsonOnlyAttributes: Object.create(null), _v: v });

    if(this.v2)
      this.setSapVocabularyAsAttributes(csn);
  }

  get v2() { return this._v[0] }
  get v4() { return this._v[1] }

  get kind() {
    return this.constructor.name
  }

  // set's additional properties that are invisible for the iterators
  set(attributes)
  {
    if(!attributes || typeof attributes !== 'object')
      throw "Please debug me: attributes must be a dictionary"
    let newAttributes = Object.create(null);
    for (let p in attributes) newAttributes[p] = {
      value: attributes[p],
      configurable: true,
      enumerable: false,
      writable: true
    }
    return Object.defineProperties(this, newAttributes)
  }

  // set properties that should only appear in the XML representation
  setXml(attributes)
  {
    if(!attributes || typeof attributes !== 'object')
      throw "Please debug me: attributes must be a dictionary"
    return Object.assign(this._xmlOnlyAttributes, attributes);
  }

  // set properties that should only appear in the JSON representation
  // today JSON attributes are not rendered in toJSONattributes()
  setJSON(attributes)
  {
    if(!attributes || typeof attributes !== 'object')
      throw "Please debug me: attributes must be a dictionary"
    return Object.assign(this._jsonOnlyAttributes, attributes);
  }

  append(...children)
  {
    // remove undefined entries
    this._children.push(...children.filter(c => c));
    return this
  }

  // virtual
  toJSON()
  {
    let json = Object.create(null);
    // $kind Property MAY be omitted in JSON for performance reasons
    if(this.kind != 'Property')
      json['$Kind'] = this.kind;

    this.toJSONattributes(json);
    this.toJSONchildren(json);
    return json
  }
  
  // virtual
  toJSONattributes(json)
  {
    for (let p in this)
    {
      if (p != 'Name')
        json[p[0] == '@' ? p : '$' + p] = this[p];
    }
    return json;
  }

  // virtual
  toJSONchildren(json)
  {
    // any child with a Name should be added by it's name into the JSON object
    // all others must overload toJSONchildren()
    this._children.filter(c => c.Name).forEach(c => json[c.Name] = c.toJSON());
  }

  // virtual
  toXML(indent = '', what='all')
  {
    let kind = this.kind;
    let head = indent + "<" + kind;

    head += this.toXMLattributes();

    let inner = this.innerXML(indent + '  ', what)
    if (inner.length < 1) {
      head += "/>"
    }
    else if (inner.length < 77 && inner.indexOf('<') < 0) {
      head += ">" + inner.slice(indent.length + 1, -1) + "</" + kind + ">"
    } else {
      head += ">\n" + inner + indent + "</" + kind + ">"
    }
    return head;
  }

  // virtual
  toXMLattributes()
  {
    let tmpStr = ""
    for (let p in this) {
      if (typeof this[p] !== 'object')
        tmpStr += ' ' + p + '="' + escapeString(this[p]) + '"'
    }
    for (let p in this._xmlOnlyAttributes) 
    {
      if (typeof this._xmlOnlyAttributes[p] !== 'object')
        tmpStr += ' ' + p + '="' + escapeString(this._xmlOnlyAttributes[p]) + '"'
    }
    return tmpStr;

    function escapeString(s) {
      return (typeof s === 'string') ? s.replace(/"/g, '&quot;') : s;
    }
  }

  // virtual
  innerXML(indent, what='all')
  {
    let xml = "";
    this._children.forEach(e => 
      xml += e.toXML(indent, what) + '\n');
    return xml;
  }

  // virtual
  setSapVocabularyAsAttributes(csn)
  {
    if(csn)
    {
      for (let p in csn)
        if (p.match(/^@sap./))
          this.setXml( { ['sap:' + p.slice(5).replace(/\./g, '-')] : csn[p] } );
    }
  }
}

class Reference extends Node
{
  static
  create(v, details)
  {
    let node = super.create(v, details);
    if(node.v2)
      node['xmlns:edmx'] = 'http://docs.oasis-open.org/odata/ns/edmx';
    return node;
  }
  get kind() { return 'edmx:Reference' }

  toJSON()
  {
    let json = Object.create(null);
    let includes = [];
    this._children.forEach(c => includes.push(c.toJSON()));
    if(includes.length > 0)
      json['$Include'] = includes;
    return json;
  }
}

class Include extends Node
{
  get kind() { return 'edmx:Include' }
  toJSON()
  {
    let json = Object.create(null);
    return this.toJSONattributes(json);
  }
}

class Schema extends Node
{
  static
  create(v, ns, alias=undefined, annotations=[], withEntityContainer=true)
  {
    let props = Object.create(null);
    props.Namespace = ns;
    if(alias != undefined)
      props.Alias = alias;
    let schema = super.create(v, props);
    schema.set( { _annotations: annotations, _actions: {} } );
    schema.setXml( { xmlns: (schema.v2) ? "http://schemas.microsoft.com/ado/2008/09/edm" : "http://docs.oasis-open.org/odata/ns/edm" } );

    if(withEntityContainer)
    {
      let ecprops = { Name: 'EntityContainer' };
      let ec = EntityContainer.create(v, ecprops );
      if(schema.v2)
        ec.setXml( { 'm:IsDefaultEntityContainer':  true } );
      // append for rendering, ok ec has Name
      schema.append(ec);
      // set as attribute for later access...
      schema.set({ _ec : ec })
    }
    return schema
  }

  // hold actions and functions in V4
  addAction(action)
  {
    if(this._actions[action.Name])
      this._actions[action.Name].push(action);
    else
      this._actions[action.Name] = [action];
  }

  setAnnotations(annotations)
  {
    if(annotations instanceof Array && annotations.length > 0)
      this._annotations.push(...annotations);
  }
    
  innerXML(indent, what)
  {
    let xml = '';
    if(what=='metadata' || what=='all')
    {
      xml += super.innerXML(indent);
      glue.forAll(this._actions, actionArray => {
        actionArray.forEach(action => {
          xml += action.toXML(indent, what) + '\n'; });
      });
    }
    if(what=='annotations' || what=='all')
    {
      if(this._annotations.length > 0) {
        this._annotations.filter(a => a.Term).forEach(a => xml += a.toXML(indent) + '\n');
        this._annotations.filter(a => a.Target).forEach(a => xml += a.toXML(indent) + '\n');
      }
    }
    return xml;
  }

  // no $Kind
  toJSON()
  {
    let json = Object.create(null);
    this.toJSONattributes(json);
    this.toJSONchildren(json);
    glue.forAll(this._actions, (actionArray, actionName) => {
      json[actionName] = [];
      actionArray.forEach(action => {
        json[actionName].push(action.toJSON());
      });
    });
    return json;
  }

  // no $Namespace
  toJSONattributes(json)
  {
    for (let p in this)
    {
      if (p != 'Name' && p != 'Namespace')
        json[p[0] == '@' ? p : '$' + p] = this[p];
    }
    return json;
  }

  toJSONchildren(json)
  {
    // 'edmx:DataServices' should not appear in JSON
    super.toJSONchildren(json);
    if(this._annotations.length > 0) {
      this._annotations.filter(a => a.Term).forEach(a => json['@'+a.Term] = a.toJSON());
      let json_Annotations = Object.create(null);
      this._annotations.filter(a => a.Target).forEach(a => json_Annotations[a.Target] = a.toJSON());
      json['$Annotations'] = json_Annotations;
    }
    return json;
  }

}

class DataServices extends Node
{
  static
  create(v, schema)
  {
    let node = super.create(v);
    node.append(schema);
    if(node.v2)
      node.setXml( { 'm:DataServiceVersion': '2.0' } )
    return node;
  }

  get kind() { return 'edmx:DataServices'; }

  toJSONchildren(json)
  {
    // 'edmx:DataServices' should not appear in JSON
    this._children.forEach(s => json[s.Namespace] = s.toJSON());
    return json;
  }
}

  /* <edmx:Edmx> must contain exactly one <edmx:DataServices> with 1..n <edm:Schema> elements
                may contain 0..n <edmx:Reference> elements

    For Odata 1.0..3.0 EDMX is an independent container with its own version 1.0.
    The OData version can be found at the DataServices Version attribute.
    From OData 4.0 onwards, EDMX is no longer a separate 'container' object but
    is used for OData exclusively. Therefore the version attribute reflects the
    OData version
  */

class EDM extends Node
{
  static
  create(v, service)
  {
    let edm = super.create(v, { Version : (v[1]) ? '4.0' : '1.0' });
    edm.set( { _service: service, _defaultRefs: [] } );

    let xmlProps = Object.create(null);
    if(edm.v4)
    {
      xmlProps['xmlns:edmx']   = "http://docs.oasis-open.org/odata/ns/edmx";
    }
    else
    {
      xmlProps['xmlns:edmx'] = "http://schemas.microsoft.com/ado/2007/06/edmx";
      xmlProps['xmlns:m']    = "http://schemas.microsoft.com/ado/2007/08/dataservices/metadata";
      xmlProps['xmlns:sap']  = "http://www.sap.com/Protocols/SAPData";
    }
    edm.setXml(xmlProps);

    return edm;
  }

  setDefaultReferences()
  {
    // default refs are necessary only if edm has annotations
    // existing EDMs render default refs always in V4
    this._defaultRefs = [];
    if(this.v4 || (this.v2 && this.hasAnnotations()))
    {
      let r = Reference.create(this._v, { Uri : "https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml" });
      r.append(Include.create(this._v, {Alias : "Core", Namespace : "Org.OData.Core.V1"} ))
      this._defaultRefs.push(r);

      r = Reference.create(this._v, { Uri : "https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Measures.V1.xml" });
      r.append(Include.create(this._v, {Alias : "Measures", Namespace : "Org.OData.Measures.V1"} ))
      this._defaultRefs.push(r);

      r = Reference.create(this._v, { Uri : "https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml" });
      r.append(Include.create(this._v, {Alias : "Capabilities", Namespace : "Org.OData.Capabilities.V1"} ))
      this._defaultRefs.push(r);

      r = Reference.create(this._v, { Uri : "https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Aggregation.V1.xml" });
      r.append(Include.create(this._v, {Alias : "Aggregation", Namespace : "Org.OData.Aggregation.V1"} ))
      this._defaultRefs.push(r);

      r = Reference.create(this._v, { Uri : "https://wiki.scn.sap.com/wiki/download/attachments/462030211/Analytics.xml?api=v2" });
      r.append(Include.create(this._v, {Alias : "Analytics", Namespace : "com.sap.vocabularies.Analytics.v1"} ))
      this._defaultRefs.push(r);

      r = Reference.create(this._v, { Uri : "https://wiki.scn.sap.com/wiki/download/attachments/448470974/Common.xml?api=v2" });
      r.append(Include.create(this._v, {Alias : "Common", Namespace : "com.sap.vocabularies.Common.v1"} ))
      this._defaultRefs.push(r);

      r = Reference.create(this._v, { Uri : "https://wiki.scn.sap.com/wiki/download/attachments/448470971/Communication.xml?api=v2" });
      r.append(Include.create(this._v, {Alias : "Communication", Namespace : "com.sap.vocabularies.Communication.v1"} ))
      this._defaultRefs.push(r);

      r = Reference.create(this._v, { Uri : "https://wiki.scn.sap.com/wiki/download/attachments/448470968/UI.xml?api=v2" });
      r.append(Include.create(this._v, {Alias : "UI", Namespace : "com.sap.vocabularies.UI.v1"} ))
      this._defaultRefs.push(r);
    }
  }

  get kind() { return 'edmx:Edmx' }

  hasAnnotations()
  {
    let rc = false;
    this._service._children.forEach(c =>
      { if(c._annotations.length > 0) rc = true; } )
    return rc;
  }

  getSchemaCount()
  {
    return this._service._children.length;
  }

  getAnnotations(schemaIndex=0)
  {
    if(this._service && this._service._children[schemaIndex])
      return this._service._children[schemaIndex]._annotations;
    else
      return undefined;
  }
   
  setAnnotations(annotations, schemaIndex=0)
  {
    if(this._service && this._service._children[schemaIndex])
      this._service._children[schemaIndex]._annotations = annotations;
  }
    
  toJSON()
  {
    this.setDefaultReferences();

    let schema = this._service._children[0];

    let json = Object.create(null);
    json['$Version'] = this.Version;
    json['$EntityContainer'] = schema.Namespace + '.' + schema._ec.Name;

    let reference_json = Object.create(null);
    this._defaultRefs.forEach(r => reference_json[r.Uri] = r.toJSON());
    this._children.forEach(r => reference_json[r.Uri] = r.toJSON());

    if(Object.keys(reference_json).length)
      json['$Reference'] = reference_json;

    this._service.toJSONattributes(json);
    this._service.toJSONchildren(json);
    return json;
  }

  // all(default), metadata, annotations
  toXML(what='all')
  {
    this.setDefaultReferences();
    return '<?xml version="1.0" encoding="utf-8"?>\n' + super.toXML('', what);
  }

  innerXML(indent, what)
  {
    let xml = "";

    if(this.v4 || (this.v2 && (what == 'all' || what == 'annotations')))
      this._defaultRefs.forEach(r => xml += r.toXML(indent) + '\n');
    this._children.forEach(e => xml += e.toXML(indent) + '\n');
    xml += this._service.toXML(indent, what) + '\n';
    return xml;
  }
}

class EntityContainer extends Node {}
class EntitySet extends Node
{
  static
  create(v, details, csn)
  {
    let node = super.create(v, details, csn);
    return node;
  }

    // virtual
  setSapVocabularyAsAttributes(csn)
  {
    if(csn)
    {
      for (let p in csn._EntitySetAttributes)
      {
        if (p.match(/^@sap./))
          this.setXml( { ['sap:' + p.slice(5).replace(/\./g, '-')] : csn._EntitySetAttributes[p] } );
      }
    }
  }

  toJSONattributes(json)
  {
    for (let p in this)
    {
      if (p != 'Name')
      {
        if(p == 'EntityType') // it's $Type in json
          json['$Type'] = this[p];
        else
          json[p[0] == '@' ? p : '$' + p] = this[p];
      }
    }
    return json;
  }

  toJSONchildren(json)
  {
    let json_navPropBinding = Object.create(null);
    this._children.forEach(npb => json_navPropBinding[npb.Path] = npb.Target);
    if(Object.keys(json_navPropBinding).length > 0)
      json['$NavigationPropertyBinding'] = json_navPropBinding;

    return json;
  }
}

class Key extends Node
{
  static create(v, keys)
  {
    let node = undefined;
    if (keys && keys.length > 0)
    {
      node = super.create(v);
      keys.forEach(k => node.append(PropertyRef.create(v, k)));
    }
    return node;
  }

  toJSON()
  {
    let json = [];
    this._children.forEach(c => json.push(c.Name));
    return json;
  }
}

/* Base class to Action/Function that provides
overloaded XML and JSON rendering of parameters and
return type. Parameters are _children.
_returnType holds the eventually existing ReturnType in V4.
In V2 the return type is a direct attribute called ReturnType
to the FunctionImport. See comment in class FunctionImport.
 */

class ActionFunctionBase extends Node
{
  static
  create(v, details)
  {
    let node = super.create(v, details);
    node.set( { _returnType: undefined });
    return node;
  }

  innerXML(indent)
  {
    let xml = super.innerXML(indent);
    if(this._returnType != undefined)
      xml += this._returnType.toXML(indent) + '\n';
    return xml
  }

  toJSONchildren(json)
  {
    let json_parameters = [];
    this._children.forEach(p => json_parameters.push(p.toJSON()));
    if(json_parameters.length > 0)
      json['$Parameter'] = json_parameters;
    if(this._returnType)
    {
      json['$ReturnType'] = this._returnType.toJSON();
    }
    return json;
  }
}
// FunctionDefinition should be named 'Function', but this would
// collide with a method 'Function' of the Istanbul/NYC tool
class FunctionDefinition extends ActionFunctionBase
{
  get kind()  { return 'Function'; }
}
class Action extends ActionFunctionBase {}

/* FunctionImport is derived from ActionFunctionBase
because in V2 Parameters need to be rendered as sub elements
to Function Import. The ReturnType property is set in the 
assembly code above (the invisible returnType is left undefined)
*/
class FunctionImport extends Node {} //ActionFunctionBase {}
class ActionImport extends Node {}

/* ReturnType is only used in v4, mapCdsToEdmType can be safely
called with V2=false */
class ReturnType extends Node
{
  static
  create(v, csn, fullQualified)
  {
    let type = csn.type || csn.items.type;
    if(type && type.startsWith('cds.'))
      type = glue.mapCdsToEdmType(type, false, false);
    else
      type = fullQualified(type);
    let node = super.create(v, { Type: type });
    glue.addTypeFacets(node, csn);
    
    node.set( { _type: type, _isCollection: csn.items != undefined, _nullable: true });

    if(node._isCollection)
      node.Type = `Collection(${node.Type})`
    return node;
  }

  // we need Name but NO $kind, can't use standard to JSON()
  toJSON()
  {
    let rt = Object.create(null);
     // use the original type, not the decorated one
    if(this._type != 'Edm.String')
      rt['$Type'] = this._type;
    if(this._isCollection)
      rt['$Collection'] = this._isCollection;

    // !this._nullable if Nullable=true become default
    if(this._nullable)
      rt['$Nullable'] = this._nullable;
    return rt;
  }
}

class TypeBase extends Node 
{
  static
  create(v, attributes, csn, typeName='Type')
  {
    if(!(csn instanceof Object))
      throw "Please debug me: csn must be an object"

    // ??? Is CSN still required? NavProp?
    let node = super.create(v, attributes, csn);
    node.set({ _isCollection: csn.items != undefined, _typeName: typeName });

    if(node[typeName] == undefined)
    {
      let typecsn = csn.items || csn;
      // Complex/EntityType are derived from TypeBase
      // but have no type attribute in their CSN
      if(typecsn.type)
      {
        if(typecsn.type.startsWith('cds.'))
        {
          node[typeName] = glue.mapCdsToEdmType(typecsn.type, node.v2, csn['@Core.MediaType']);
          // CDXCORE-CDXCORE-173 ignore type facets for Edm.Stream
          if(node[typeName] != 'Edm.Stream')
            glue.addTypeFacets(node, typecsn);
        }
        else
          node[typeName] = typecsn.type;

        // CDXCORE-245:
        // map type to @odata.Type
        // optionally add @odata.MaxLength but only in combination with @odata.Type
        // In absence of checks restrict @odata.Type to 'Edm.String'
        let odataType = csn['@odata.Type'];
        let odataTypeMaxLen = csn['@odata.MaxLength'];

        if(odataType === 'Edm.String')
        {
          node[typeName] = odataType;
          if(odataTypeMaxLen)
            node['MaxLength'] = odataTypeMaxLen;
        }

        // store undecorated type for JSON
        node.set( { _type : node[typeName] });
      
        // decorate for XML (not for Complex/EntityType)
        if(node._isCollection)
          node[typeName] = `Collection(${node[typeName]})`
      }
    }
    return node;
  }
  
  toJSONattributes(json)
  {
    // $Type Edm.String, $Nullable=false MAY be omitted
    // @ property and parameter for performance reasons
    if(this._type != 'Edm.String' && this._type)   // Edm.String is default)
      json['$'+this._typeName] = this._type;

    for (let p in this)
    {
      if (p != 'Name' && p != this._typeName
        // remove this line if Nullable=true becomes default
        && !(p == 'Nullable' && this[p] == false))
      {
        json[p[0] == '@' ? p : '$' + p] = this[p]
      }
    }

    if(this._isCollection)
      json['$Collection'] = this._isCollection;

    return json;

  }
}

class ComplexType extends TypeBase { }
class EntityType extends ComplexType
{
  static
  create(v, details, properties, csn)
  {
    let node = super.create(v, details, csn);
    node.append(...properties);
    let keys = Key.create(v, properties.filter(c => c.isKey).map(c => c.Name));
    node.set( { _keys: keys } );
    return node;
  }

  innerXML(indent)
  {
    let xml = "";
    if(this._keys)
      xml += this._keys.toXML(indent) + '\n';
    return xml + super.innerXML(indent);
  }

  toJSONattributes(json)
  {
    super.toJSONattributes(json);
    if(this._keys)
    {
      json['$Key'] = this._keys.toJSON();
    }
    return json;
  }
}

class TypeDefinition extends TypeBase
{
  static
  create(v, attributes, csn)
  {
    let node = super.create(v, attributes, csn, 'UnderlyingType');
    return node
  }

  toJSONattributes(json)
  {
    super.toJSONattributes(json);
    json['$UnderlyingType'] = this._type;
    return json;
  }
}

class EnumType extends TypeDefinition
{
  static
  create(v, attributes, csn)
  {
    let node = super.create(v, attributes, csn);

    // array of enum not yet allowed
    let enumValues = /*(csn.items && csn.items.enum) ||*/ csn.enum;
    glue.forAll(enumValues, (e, en) =>  {
      node.append(Member.create(v, { Name: en, Value: e.value } ));
    });
    return node
  }

  toJSONattributes(json)
  {
    super.toJSONattributes(json);
    return json;
  }

  toJSONchildren(json)
  {
    this._children.forEach(c => c.toJSONattributes(json));
    return json;
  }
}

class Member extends Node
{
  static create(v, attributes)
  { return super.create(v, attributes); }

  toJSONattributes(json)
  {
    json[this.Name] = this.Value;
    return json;
  }
}

class PropertyBase extends TypeBase {
  static
  create(v, attributes, csn)
  {
    let node = super.create(v, attributes, csn);
    node.set({ _csn: csn });
    if(node.v2)
    {
      let typecsn = csn.items || csn;

      // see glue.mapsCdsToEdmType => add sap:display-format annotation
      // only if Edm.DateTime is the result of a cast from Edm.Date
      // but not if Edm.DateTime is the result of a regular cds type mapping
      if(node.Type == 'Edm.DateTime' 
      && (typecsn.type != 'cds.DateTime' && typecsn.type != 'cds.Timestamp'))
        node.setXml( { 'sap:display-format' : "Date" } );

    }
    node.setNullable();
    return node
  }

  setNullable()
  {
    // Nullable=true is default, mention Nullable=false only in XML
    // Nullable=false is default for EDM JSON representation 4.01
    // When a key explicitly (!) has 'notNull = false', it stays nullable
    if(this.isNotNullable())
    {
      this.Nullable = false;
    }
  }

  isNotNullable(csn=undefined) {
    let nodeCsn = csn || this._csn;
    // Nullable=true is default, mention Nullable=false only in XML
    // Nullable=false is default for EDM JSON representation 4.01
    // When a key explicitly (!) has 'notNull = false', it stays nullable
    return ((nodeCsn.key && !(nodeCsn.notNull === false)) || nodeCsn.notNull == true);
  }

  toJSONattributes(json)
  {
    super.toJSONattributes(json);
    // mention all nullable elements explictly, remove if Nullable=true becomes default
    if(this.Nullable == undefined || this.Nullable == true)
    {
      json['$Nullable'] = true;
    }
    return json;
  }
}

class Property extends PropertyBase {
  static
  create(v, attributes, csn)
  {
    // the annotations in this array shall become exposed as Property attributes in
    // the V2 metadata.xml
    Property.SAP_Annotation_Attribute_WhiteList = [
      '@sap.hierarchy.node.for',                  //-> 	sap:hierarchy-node-for
      '@sap.hierarchy.parent.node.for',           // -> 	sap:hierarchy-parent-node-for
      '@sap.hierarchy.level.for',               	// -> 	sap:hierarchy-level-for
      '@sap.hierarchy.drill.state.for',           // -> 	sap:hierarchy-drill-state-for
      '@sap.hierarchy.node.descendant.count.for'	// -> 	sap:hierarchy-node-descendant-count-for
    ];

    let node = super.create(v, attributes, csn);
    // TIPHANACDS-4180
    if(node.v2)
    {
      if(csn['@odata.etag'] == true)
        node.ConcurrencyMode='Fixed'

      // translate the following @sap annos as xml attributes to the Property
      for (let p in csn)
      {
        if (Property.SAP_Annotation_Attribute_WhiteList.includes(p)) 
          node.setXml( { ['sap:' + p.slice(5).replace(/\./g, '-')] : csn[p] });
      }
    } 
    node.set({isKey: csn.key != undefined });
    return node;
  }

  // required for walker to identify property handling....
  // static get isProperty() { return true }
}

class PropertyRef extends Node
{
  static create(v, Name) { return super.create(v, { Name }); }
}

class Parameter extends PropertyBase
{
  static
    create(v, attributes, csn={}, mode=null)
    {
      let node = super.create(v, attributes, csn);
      if(mode != null)
        node.Mode = mode;
      return node;
    }

  toJSON()
  {
    // we need Name but NO $kind, can't use standard to JSON()
    let json = Object.create(null);
    for (let p in this)
      json[p[0] == '@' ? p : '$' + p] = this[p]
    return json;
  }
}

class NavigationPropertyBinding extends Node {}

class NavigationProperty extends Property {
  static
  create(v, attributes, csn)
  {
    NavigationProperty.DOLLAR_SELF = '$self'

    let navProp = super.create(v, attributes, csn);
    navProp.set( { _type: attributes.Type, _isCollection: glue.isToMany(csn), _referentialConstraints: navProp.getReferentialConstraints(), } );
    if (navProp.v4) {
      // either csn has multiplicity or we have to use the multiplicity of the backlink
      if(navProp._isCollection || navProp._referentialConstraints.multiplicity[1] == '*') {
        navProp.Type = `Collection(${attributes.Type})`
      }

      /*
        1) If this navigation property belongs to an EntityType for a parameterized entity
        ```entity implemented in calcview (P1: T1, ..., Pn: Tn) { ... }```
        and if the csn.containsTarget for this NavigationProperty is true,
        then this is the generated 'Results' association to the underlying entityType.
        Only this special association may have an explicit ContainsTarget attribute.
        See csn2edm.createParmeterizedEntityTypeAndSet() for details
        2) ContainsTarget stems from the @odata.contained annotation
      */
      if(csn['@odata.contained'] == true || csn.containsTarget)
        navProp.ContainsTarget = true;

      // if backlink has established partner before this underlying NavProp is created, use it
      if(csn.$Partner)
        navProp.Partner = csn.$Partner;
    }
    if (navProp.v2 && navProp.isNotNullable()) {
        // in V2 not null must be expressed with target cardinality of 1 or more, 
        // store Nullable=false and evaluate in determineMultiplicity()
      delete navProp.Nullable;
    }

    // store NavProp reference in the model for bidirectional $Partner tagging (done in getReferentialConstraints())
    csn._NavigationProperty = navProp;

    // we don't want NavProps in the <KEY> list
    delete navProp.isKey;

    // TODO: Possible V4 Attributes: Partner, ContainsTarget
    //       Possible subelement <OnDelete>, may be specified via @odata.OnDelete annotation...
    return navProp;
  }

  // if the backlink association is annotated with @odata.contained or the underlying association
  // is marked with _isToContainer, then the association is a Containment relationship
  isContainment() {
    return this._csn._isToContainer || this._csn['@odata.contained'];
  }

  isNotNullable(csn=undefined) {
    let nodeCsn = csn || this._csn;
    // Set Nullable=false only if 'NOT NULL' was specified in the model
    // Do not derive Nullable=false from key attribute.
    return (nodeCsn.notNull == true);
  }

  toJSONattributes(json)
  {
    // use the original type, not the decorated one
    super.toJSONattributes(json);
    json['$Type'] = this._type;
    return json;
  }

  toJSONchildren(json)
  {
    let json_constraints = Object.create(null);
    this._children.forEach(c => json_constraints[c.Property] = c.ReferencedProperty);
    // TODO Annotations
    if(Object.keys(json_constraints).length > 0)
      json['$ReferentialConstraint'] = json_constraints;
    return json;
  }

  createNavigationPropertyBinding(namespace)
  {
    return NavigationPropertyBinding.create(this._v,
      { Path: this.Name, Target: this._csn.target.name.replace(namespace, '') }
    );
  }

  addReferentialConstraintNodes()
  {
    glue.forAll(this._referentialConstraints.constraints,
      c => this.append(ReferentialConstraint.create(this._v,
        { Property: c[0], ReferencedProperty: c[1] }
      ) ) );
  }

  getReferentialConstraints(assocCsn = undefined)
  {
    let result = { multiplicity: ['*', '0..1' ], constraints: Object.create(null) };

    assocCsn = assocCsn || this._csn;
    let prefix = assocCsn.name + '.';

    // If this association points to a redirected Parameter EntityType, do not calculate any constraints,
    // continue with multiplicity
    if(!assocCsn.target.isParamEntity)
    {
      if(assocCsn.onCond)
      {
        // fill constraint array with [prop, depProp]
        getExpressionArguments(assocCsn.onCond);

        // if self assoc, refill constraints from target assoc
        if(result.constraints[NavigationProperty.DOLLAR_SELF])
        {
          let originAssocCsn = assocCsn.target.elements[result.constraints[NavigationProperty.DOLLAR_SELF]];

          if(glue.isAssociationOrComposition(originAssocCsn))
          {
            // mark this association as backlink to surpress edm:Association generation in V2 mode
            result._originAssocCsn = originAssocCsn;

            // remove $SELF
            delete result.constraints[NavigationProperty.DOLLAR_SELF];

            // remove all other non key target elements
            glue.foreach(result.constraints, c => !assocCsn.target.elements[c[1]].key,
              (c, cn) => { delete result.constraints[cn]; } );

            // if the assoc is marked as primary key, add all its foreign keys as constraint
            // as they are primary keys of the other entity as well
            if(originAssocCsn.key)
            {
              glue.forAll(originAssocCsn.foreignKeys, fk => {
                let c = [fk.path, fk.generatedFieldName];
                result.constraints[c] = c;
              });
            }

            // Side-Effect: Set the Partner attribute with the name of the opposite
            // association to the two corresponding csn's and to this NavProp
            // (but only if originAssoc is navigable (undefined !== false) still evaluates to true)
            if(this.v4 && originAssocCsn['@odata.navigable'] !== false)
            {
              this.Partner = assocCsn.$Partner = originAssocCsn.name;

              // if the other NavProp has been created already, set NavProp.Partner
              if(originAssocCsn._NavigationProperty)
                originAssocCsn._NavigationProperty.Partner = assocCsn.name;
              // if not, Partner will be set during creation of other NavProp
              originAssocCsn.$Partner = assocCsn.name;
            }
          }
          else
          {
            /*
              entity E  {
                key id : Integer;
                toMe: associaton to E on toMe.id = $self; };
              */
            throw "Backlink association element is not an association or composition: " + originAssocCsn.name;
          }
        }
        else // ordinary ON condition
        {
          // remove all non key target elements
          glue.foreach(result.constraints, c => !assocCsn.target.elements[c[1]] || !assocCsn.target.elements[c[1]].key,
            (c, cn) => { delete result.constraints[cn]; } );
        }
      }
      // this is a managed association
      else
      {
        // If FK is key in target => constraint
        // Don't consider primary key associations (fks become keys on the source entity) as
        // this would impose a constraint against the target.
        // FIXME: If path is something structured, perform a path resolution (or use augmented CSN)
        glue.foreach(assocCsn.foreignKeys,
          fk => assocCsn.target.elements[fk.path].key,
          fk => {
            let c = [fk.generatedFieldName, fk.path];
            result.constraints[c] = c;
          }
        );
      }
    }

    determineMultiplicity(result._originAssocCsn);
    return result;

    // nested functions
    function getExpressionArguments(expr)
    {
      if(Array.isArray(expr)) // expression in parentheses
        expr = expr[0];
      if(expr.op == '=')
      {
        let lhs = expr.args[0]['='];
        let rhs = expr.args[1]['='];
        if(lhs && rhs)
        {
          // if exactly one operand starts with the prefix then this is potentially a constraint
          if((lhs.startsWith(prefix) &&
            !rhs.startsWith(prefix)) ||
            (!lhs.startsWith(prefix) &&
            rhs.startsWith(prefix)))
          {
            // order is always [ property, referencedProperty ]
            //backlink         [ self, assocName ]
            let c;
            if(lhs.startsWith(prefix))
              c = [ rhs, lhs.replace(prefix, '') ];
            else
              c = [ lhs, rhs.replace(prefix, '') ];

            // do we have a $self or optionally a 'self' id?
            // if so, store partner with key $self, multiple $self's should be illegal
            if(c[0] === NavigationProperty.DOLLAR_SELF || (NavigationProperty.OLDSTYLE_SELF && c[0] === NavigationProperty.OLDSTYLE_SELF))
            {
              result.constraints[NavigationProperty.DOLLAR_SELF] = c[1];
            }
            else
              result.constraints[c] = c;
          }
        }
      }
      else if(expr.op == 'and')
      {
        expr.args.forEach(sub => 
          { if(sub.op) getExpressionArguments(sub) });
      }
      else // any other operator will lead to reset of constraints (OR, !=, <>, ...) and return
      {
        result.constraints = Object.create(null);
        return;
      }
    }

    function determineMultiplicity(originCsn)
    {
      /*
        =>  SRC Cardinality
        CDS   => EDM
        ------------
        undef =>  '*' // CDS default mapping
        1     => 0..1
        n     => '*'
        n/a   => 1   // not expressable
        *     => *

        => TGT Cardinality
        CDS   => EDM
        ------------
        undef      => 0..1 // CDS default mapping
        0..1       => 0..1
        1          => 0..1
        1 not null => 1  (targetMin=1 is set by transform/toOdata.js)
        1..1       => 1
        0..m       => '*'
        m          => '*'
        1..n       => '*'
        n..m       => '*'
        *          => '*'
      */

      let csn = originCsn || assocCsn;

      // reverse the default cardinality for a backlink
      //let srcCardinality = '*';
      //let tgtCardinality = '0..1';

      if(!csn.cardinality)
        csn.cardinality = Object.create(null);
      if(!csn.cardinality.sourceMax)
        csn.cardinality.sourceMax = '*';
      if(!csn.cardinality.targetMin)
        csn.cardinality.targetMin = 0;
      if(!csn.cardinality.targetMax)
        csn.cardinality.targetMax = 1;

      let  srcCardinality = (csn.cardinality.sourceMax == 1) ? '0..1' : '*';
      let  tgtCardinality = (csn.cardinality.targetMax > 1 || csn.cardinality.targetMax == '*') ? '*' : 
                              (csn.cardinality.targetMin == 1) ? '1' : '0..1';

      // if originCsn was provided, reverse multiplicity for backlink
      result.multiplicity = originCsn ? [tgtCardinality, srcCardinality] : [srcCardinality, tgtCardinality];
    }
  }
}

class ReferentialConstraint extends Node
{
  innerXML(indent)
  {
    if(this._d && this._p)
    {
      return this._p.toXML(indent) + '\n' + this._d.toXML(indent) + '\n';
    }
    else
      return super.innerXML(indent);
  }
}

// Annotations below
class AnnotationBase extends Node
{
  toJSON() // no $Kind
  {
    let json = Object.create(null);
    this.toJSONattributes(json);
    this.toJSONchildren(json);
    return json
  }

  getConstantExpressionValue()
  {
    // short form: key: value
    let inlineConstExpr = [ 'Bool', 'Float', 'String' ];
    // if not inline, represented as object (exceptions apply (INF/NAN))
    let constExpr = [ 'Binary', 'Bool', 'Date', 'DateTimeOffset',
      'Decimal', 'Duration', 'EnumMember', 'EnumMember@odata.type', 'Float',
      'Guid', 'Int', 'String', 'TimeOfDay',
      'Path', 'AnnotationPath', 'ModelElementPath',
      'NavigationPropertyPath', 'PropertyPath' ];

    // call this for 'all' properties and for JSON only properties
    // eihter 'all' props or JSON only props must be filled but not both!

    let expr = glue.intersect(constExpr, Object.keys(this));
    let jsonOnlyExpr = glue.intersect(constExpr, Object.keys(this._jsonOnlyAttributes))

    if(expr.length + jsonOnlyExpr.length == 0)
      throw "Please debug me: neither child nor constant expression found on annotation";

    if(expr.length > 0 && jsonOnlyExpr.length > 0)
      throw "Please debug me: either expr or jsonOnlyExpr must be used but not together" + expr + " " + jsonOnlyExpr;

    if(expr.length > 0)
      return addExpressions(expr, this);
    if(jsonOnlyExpr.length > 0)
      return addExpressions(jsonOnlyExpr, this._jsonOnlyAttributes);

    return undefined;

    function addExpressions(expr, dict)
    {
      let json = Object.create(null);
      let inline = glue.intersect(expr, inlineConstExpr);
      if(inline.length==1)
      {
        let v = dict[inline[0]];
        switch(inline[0])
        {
          case 'Bool':
            return (v=='true'?true:(v=='false'?false:v));
          case 'Float':
            if(v=='INF'||v=='-INF'||v=='NaN')
            {
              json['$Float'] = v;
              return json;
            }
            else
              return v;
          case 'String':
            return v;
          default:
            throw "Please debug me: default not reachable";
        }
      }
      else
      {
        for(let i = 0; i < expr.length; i++)
          json['$' + expr[i]] = dict[expr[i]]
        return json;
      }
    }
  }
}

class Annotations extends AnnotationBase
{
  static
  create(v, target)
  {
    let node  = super.create(v, { Target: target });
    if (node.v2) 
      node.setXml( { xmlns : "http://docs.oasis-open.org/odata/ns/edm" } );
    return node;
  }

  toJSONattributes(json)
  {
    for (let p in this)
      if (p != 'Target')
        json[p[0] == '@' ? p : '$' + p] = this[p]
    return json;
  }

  toJSONchildren(json)
  {
    this._children.forEach(a => json['@' + a.Term] = a.toJSON())
  }
}

// An Annotation must contain either children or a constant value
// The value attribute is rendered by getConstantExpressionValue().
// However, in case the constant expression value differs for XML an JSON
// (EnumMember & EnumMember@odata.type) then the value properties must
// be separated by using setJSON(attibute) and setXML(attribute).
// See genericTranslation::handleValue() for details (especially the code
// that sets the EnumMember code). All this has been done because the
// Annotation object is passed around in genericTranslation and the
// properties are set all over the place. The initial assumption was that
// the constant expression value is the same for both XML and JSON. But
// since it was discovered, that in JSON the EnumMember type must be
// transported this is no longer the case....
class Annotation extends AnnotationBase
{
  static
  create(v, termName)
  {
    let node  = super.create(v, { Term: termName } );
    return node;
  }

  toJSON()
  {
    if(this._children.length == 0) // must be a constant expression
      return this.getConstantExpressionValue();
    else
      // annotation must have exactly one child (=record or collection)
      return this._children[0].toJSON();
  }
}

class Collection extends AnnotationBase
{
  toJSON()
  {
    let json = [];
    this._children.forEach(a => json.push(a.toJSON()));
    return json;
  }
}

class Record extends AnnotationBase
{
  toJSONattributes(json)
  {
    let keys = Object.keys(this).filter(k => k != 'Type');
    for(let i = 0; i < keys.length; i++)
      json['$'+keys[i]] = this[keys[i]];
  }

  toJSONchildren(json)
  {
    this._children.forEach(a => {
      let name;
      switch(a.kind)
      {
        case 'Annotation':
          name = '@' + a.Term;
          break;
        case 'PropertyValue':
          name = a.Property;
          break;
        default:
          throw "Please debug me: default not reachable";
      }
      json[name] = a.toJSON()
    });
  }
}

class PropertyValue extends AnnotationBase
{
  static create(v, property)
  {
    let node = super.create(v);
    node.Property = property;
    return node;
  }

  toJSON()
  {
    if(this._children.length == 0)
      return this.getConstantExpressionValue();
    else
    {
      return this._children[0].toJSON();
    }
  }
}

class Thing extends AnnotationBase
{
  static create(v, kind, details)
  {
    let node = super.create(v, details);
    node.setKind(kind);
    return node;
  }

  setKind(kind)
  {
    Object.defineProperty(this, 'kind', 
    { get: function() { return kind; }});
  }
}

class ValueThing extends Thing 
{
  static create(v, kind, value)
  {
    let node = super.create(v, kind);
    node.set( { _value : value });
    return node;
  }

  toXML(indent='')
  {
    let kind = this.kind;
    let xml = indent + "<" + kind + this.toXMLattributes();
    xml +=  (this._value ? ">" + escapeString(this._value) + "</" + kind + ">" :  + "/>");
    return xml;

    function escapeString(s) {
      // first regex: replace & if not followed by apos; or quot; or gt; or lt; or amp; or #
      return (typeof s === 'string') ? s.replace(/&(?!(?:apos|quot|[gl]t|amp);|#)/g, '&amp;').replace(/>/g, '&gt;').replace(/</g, '&lt;') : s;
    }
  }

  toJSONattributes(json)
  {
    json['$'+this.kind] = this._value;
  }
}


// V2 specials
class End extends Node {}
class Association extends Node
{
  static
  create(v, details, f, t, m)
  {
    let node = super.create(v, details);
    node.set( { _end: [] });
    node._end.push(
      End.create(v, { Role: f[0], Type: f[1], Multiplicity: m[0] } ),
      End.create(v, { Role: t[0], Type: t[1], Multiplicity: m[1] } )
    );
    return node;
  }

  innerXML(indent)
  {
    let xml = "";
    this._end.forEach(e => xml += e.toXML(indent) + '\n');
    xml += super.innerXML(indent);
    return xml;
  }
}

class AssociationSet extends Node
{
  static
  create(v, details, fromRole, toRole, fromEntitySet, toEntitySet)
  {
    let node = super.create(v, details);
    node.append(
        End.create(v, { Role: fromRole, EntitySet: fromEntitySet } ),
        End.create(v, { Role: toRole,   EntitySet: toEntitySet } )
      );
    return node;
  }
}

class Dependent extends Node {}
class Principal extends Node {}
ReferentialConstraint.createV2 =
  function(v, from, to, c)
  {
    let node = ReferentialConstraint.create(v, {});
    node.set({ _d: Dependent.create(v, { Role: from } ) });
    node.set({ _p: Principal.create(v, { Role: to } ) });

    glue.forAll(c, cv => {
      node._d.append(PropertyRef.create(v, cv[0]));
      node._p.append(PropertyRef.create(v, cv[1]));
    });
    return node;
  }

module.exports = Object.assign(EDM, {
  Reference,
  Include,
  Schema,
  DataServices,
  EntityContainer,
  EntitySet,
  TypeDefinition,
  EnumType,
  ComplexType,
  EntityType,
  Key,
  //ActionFunctionBase,
  FunctionDefinition,
  Action,
  FunctionImport,
  ActionImport,
  ReturnType,
  // PropertyBase,
  Property,
  PropertyRef,
  Parameter,
  NavigationPropertyBinding,
  NavigationProperty,
  ReferentialConstraint,
  // Annotations
  Annotations,
  Annotation,
  Collection,
  Record,
  Thing,
  ValueThing,
  PropertyValue,
  // V2 specials
  End,
  Association,
  AssociationSet,
  Dependent,
  Principal
})
