'use strict';

/*
  Helper functions for
  - converting an xml string into a js object representation
  - converting a js object representation of an xml document into an xml string

  We use the following format for the js object representation of xml:
  - a xml element is represented by a js object
  - the element name is stored in the property "$kind" of the js object
  - attributes of the xml element are represented by properties of the js object
  - if the xml element has subelements, the js object has a property "$elements", which is an array
      and contains the js objects representing the respective subelements
  - if the xml element has a value instead of subelements, this is stored in property "$value"
      of the js object

  Example:

  <kindA a1=val a2=val>
    <kindB b1=val b2=val/>
    <kindC>val</kindC>
  </kindA>

  {
    "$kind": "kindA",
    "a1": val,
    "a2": val
    "$elements": [
      {
        "$kind": "kindB",
        "b1": val,
        "b2": val
      },
      {
        "$kind": "kindC",
        "$value": cal
      }
    ]
  }
*/

var parser = require('xml2js');

/**************************************************************************************************
  convert xml string into (our own) js object representation

  We use xml2js to parse xml files. xml2js produxes a js object representation of the xml that
  has the following form:

  An xml element is represented by a js object O. If the xml element has attributes, O has
  a property "$" which is an object itself, and the xml element's attributes are represented
  by properties of "$".  If the xml element has subelements, they are grouped by the element
  names. For each group O has a property of the corresponding name, which is an array and
  contains the js objects representing the subelements.
  Note that in the js representation the name of an element is not part of the object that
  represents the element, but of the superordinate object. As a consequence, at the top level
  there is a deviation from this schema: at the top level there is an object with a single
  property that has the name of the top level xml element, and the value of that property is
  a single object that is the representation of the element.

  <kindA a1=val a2=val>
    <kindB b1=val b2=val/>
    <kindC>val</kindC>
  </kindA>

  {
    "kindA": {
      "$": {
        "a1": <val>,
        "a2": <val>
      },
      "kindB": [
        {
          "$": {
            "b1": <val>,
            "b2": <val>
          }
        }
      ],
      "kindC": [
        <val>
      ]
    }
  }

  I don't like this representation, so we immediately transform it into the format described above.
**************************************************************************************************/

function xmlToJs(xml) {
  let result = null;

  parser.parseString(xml, function (err, jsXml) {
    // expect result to be a js object with a single property
    if (err != undefined) {
      throw "error when parsing xml string: " + err;
    }

    let k = Object.keys(jsXml);
    if (k.length != 1)
      throw "at top level only one property is expected";

    let topObject = jsXml[k[0]];
    result = constructElement(k[0], topObject);
  });

  return result;
}

// input: element name and js object representation of an xml element as produced by xml2js
// output: js object representation of xml element as described at the top of this file
function constructElement(elemName, elemObjIn) {
  let resultElem = {"$kind" : elemName};

  if (typeof(elemObjIn) == "string" && elemObjIn == "") {
    resultElem["$elements"] = [];
    return resultElem;    
  }

  if (typeof(elemObjIn) != "object") {
    resultElem["$value"] = elemObjIn;
    return resultElem;
  }

  // handle attributes
  let attribs = elemObjIn["$"];
  if (attribs != undefined) {
    for (let a in attribs) {
      resultElem[a] = attribs[a];
    }
  }

  // handle subelements
  let subElemNames = Object.keys(elemObjIn).filter( x => x != "$");
  if (subElemNames.length > 0) {
    resultElem["$elements"] = [];
    for (let subElemName of subElemNames) {
      let subElemArray = elemObjIn[subElemName];
      // is expected to be an array
      if (!Array.isArray(subElemArray)) throw subElemName + " is not an array";

      for (let subElem of subElemArray) {
        let elem = constructElement(subElemName, subElem);
        resultElem["$elements"].push(elem);
      }
    }
  }

  return resultElem;
}

/**************************************************************************************************
  exports
**************************************************************************************************/

module.exports = { xmlToJs };
