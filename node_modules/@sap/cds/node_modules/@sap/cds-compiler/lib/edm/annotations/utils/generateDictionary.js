//
// read odata vocabulary xml files and produce Dictionary.json
//
'use strict';

var fs = require('fs');
var xmlParser = require('../xmlParser')

let dict = { terms : {}, types : {} };

function buildDictionary() {
  const vocabularyNames = ["Aggregation", "Analytics", "Capabilities", "Common", "Communication", "Core", "Measures", "UI"];
  const fileNames = vocabularyNames.map(x => "lib/edm/annotations/vocabularies/" + x + ".xml");

  for (let fileName of fileNames) {
    let xml = fs.readFileSync(fileName, 'utf8');
    let xmljs = xmlParser.xmlToJs(xml);
    addToDictionary(xmljs);
  }

  postProcess();
}

module.exports = { buildDictionary, dict };


//
// this function takes as input the js representation of a vocabulary xml file
//   and adds the contained info to the dict
//
function addToDictionary(input) {
  // top level should be only one object of kind edmx:Edmx
  if (input["$kind"] != "edmx:Edmx") throw "top level is wrong";
  let edmxElements = input["$elements"];

  // there should be a single element of kind edmx:DataServices
  let dsArray = edmxElements.filter( x => x["$kind"] == "edmx:DataServices");
  if (dsArray.length != 1) throw "single element of kind edmx:DataServices expected";
  let dataserv = dsArray[0];

  // there should be a single element of kind Schema
  let sArray = dataserv["$elements"].filter( x => x["$kind"] == "Schema");
  if (sArray.length != 1) throw "single element of kind Schema expected";
  let schema = sArray[0];
    
  let alias = schema.Alias;

  for (let definition of schema["$elements"]) {
    let fullName = alias + "." + definition.Name;

    let kind = definition["$kind"];
    // remove all elements of kind Annotation
    let elements = definition["$elements"].filter( x => x["$kind"] != "Annotation");

    if (kind == "Annotation" || kind == "Function") {
      // ignore
    }
    else if (kind == "Term") {
      // term definition
      if (dict.terms[fullName]) throw "Dictionary already contains term " + fullName;

      // a term should only have elements of kind annotation
      if (elements && elements.length > 0) throw "term has other element than annotation";

      // remove $kind and $elements
      delete definition["$kind"];
      delete definition["$elements"];
      delete definition["Name"];
      delete definition["DefaultValue"];
      delete definition["BaseTerm"];
      delete definition["Nullable"];
      dict.terms[fullName] = definition;
    }
    else {
      if (dict.types[fullName]) throw "Dictionary already contains type " + fullName;

      if (kind == "EnumType") {
        // all elements should have kind Member
        if (elements.find( x => x["$kind"] != "Member")) {
          throw "unexpected element in EnumType, " + JSON.stringify(definition, null, 2);
        }
        definition.Members = elements.map( x => x.Name);
      }
      else if (kind == "ComplexType") {
        // all elements should have kind Property
        if (elements.find( x => x["$kind"] != "Property")) {
          throw "unexpected element in ComplexType, " + JSON.stringify(definition, null, 2);
        }

        definition.Properties = {};
        for (let elem of elements) {
          // property should only have elements of kind Annotation
          if (elem["$elements"] && elem["$elements"].find( x => x["$kind"] != "Annotation")) {
            throw "complex type with nested non-annotation elements: " + JSON.stringify(definition, null, 2);
          }
          definition.Properties[elem.Name] = elem.Type;
        }
      }
      else if (kind == "TypeDefinition") {
        // there should be no further elements
        if (elements.length > 0) {
          throw "unexpected element in TypeDefinition, " + JSON.stringify(definition, null, 2);
        }
      }
      else {
        throw "unexpected kind " + kind + " in " + JSON.stringify(definition, null, 2);
      }

      delete definition["$elements"];
      delete definition["Name"];
      dict.types[fullName] = definition;
    }
  }
}

// postprocessing
//   for complex types, add properties of base types to Properties dictionary
function postProcess() {

  for (let t in dict.types) {
    let type = dict.types[t];
    if (type["$kind"] === "ComplexType") {
      let baseName = type.BaseType;
      while (baseName && dict.types[baseName]) {
        Object.assign(type.Properties, dict.types[baseName].Properties);
        baseName = baseName.BaseType;
      }
    }
  }
}
