'use strict';
/* eslint max-statements-per-line:off */

function validateOptions(_options)
{
  if(!_options.isV2 && !_options.isV4)
  {
    const options = Object.assign({ version: 'v4'}, _options);

    const v2 = options.version.match(/v2/i) != undefined;
    const v4 = options.version.match(/v4/i) != undefined;

    options.v = [v2, v4];

    if(options.v.filter(v=>v).length != 1)
      throw `Please debug me: EDM V2:${v2}, V4:${v4}`

    options.isV2 = function() { return this.v[0] == true; }
    options.isV4 = function() { return this.v[1] == true; }
    return options;
  }
  else
    return _options;
}

// returns intersection of two arrays
function intersect(a,b)
{
  return [...new Set(a)].filter(x => new Set(b).has(x));
}

// Call func(art, name) for each artifact 'art' with name 'name' in 'dictionary' that returns true for 'filter(art)'
function foreach(dictionary, filter, func) {
  if (dictionary != undefined) {
    for (let name in dictionary) {
      if (dictionary[name] && filter(dictionary[name])) {
        func(dictionary[name], name);
      }
    }
  }
}

// Call func(art, name) for each artifact 'art' with name 'name' in 'dictionary'
function forAll(dictionary, func) {
  foreach(dictionary, ()=>true, func);
}

// true if _containerEntity is unequal to artifact name (non-recursive containment association)
//      or if artifact belongs to an artificial parameter entity
function isContainee(artifact) {
  // if _containerEntity is present, it is guarranteed that it has at least one entry
  return (artifact._containerEntity && (artifact._containerEntity.length > 1 || artifact._containerEntity[0] != artifact.name));
}

// Return true if 'artifact' has an association type
function isAssociation(artifact) {
  return (artifact.type == "cds.Association" || artifact.type == "Association") &&  artifact.target != undefined;
  //return artifact.target != undefined;
}

function isComposition(artifact) {
  return (artifact.type == "cds.Composition" || artifact.type == "Composition") &&
    artifact.target != undefined;
}

function isAssociationOrComposition(artifact)
{
  return isAssociation(artifact) || isComposition(artifact);
}

function isManagedAssociation(artifact)
{
  return isAssociation(artifact) && artifact.onCond == undefined;
}

// Return true if the association 'assoc' has cardinality 'to-many' 
function isToMany(assoc) {
  if (!assoc.cardinality) {
    return false;
  }
  // Different representations possible: array or targetMax property
  let targetMax = assoc.cardinality[1] || assoc.cardinality.targetMax;
  if (!targetMax) {
    return false;
  }
  return targetMax == '*' || Number(targetMax) > 1;
}

function isEntityOrView(artifact)
{
  return artifact.kind == 'entity' || artifact.kind == 'view';
}

function isParameterizedEntityOrView(artifact) {
  return isEntityOrView(artifact) && artifact.params;
}

// Return true if 'artifact' is a real structured type (not an entity)
function isStructuredType(artifact) {
  return isStructuredArtifact(artifact) && !isEntityOrView(artifact);
}

// Return true if 'artifact' is structured (i.e. has elements, like a structured type or an entity)
function isStructuredArtifact(artifact) {
  // FIXME: No derived types etc yet
  return (artifact.items && artifact.items.elements || artifact.elements);
}

function isDerivedType(artifact)
{
  return artifact.kind == 'type' && !isStructuredType(artifact);
}

function isActionOrFunction(artifact)
{
  return artifact.kind == 'action' || artifact.kind == 'function';
}

// Initialize 'model' in place for odata-preprocessing. Return a service from 'model' or undefined if there is none.
// FIXME: Should move to some more ODATA-specific location 
function initializeModel(model, options) 
{
  if(options == undefined)
    throw "Please debug me: initializeModel must be invoked with options"
  
  // make sure options are complete
  options = validateOptions(options);

    // First attach names to all definitions in the model
  forAll(model.definitions, (a, n) => {
    a.name = n;
  });

  foreach(model.definitions, isActionOrFunction, a => {
    forAll(a.params, (p,n) => {
      p.name = n;
    })
  });

  let service;
  // Fetch service object
  foreach(model.definitions, a => a.kind == 'service', a => { 
    service = a; });

  // Initialize entities with parameters (add Parameter entity)
  foreach(model.definitions, isParameterizedEntityOrView, initializeParameterizedEntityOrView);
  // Initialize structures
  foreach(model.definitions, isStructuredArtifact, initializeStructure);
  // Initialize associations
  foreach(model.definitions, isStructuredArtifact, initializeAssociation);
  // Attach name to actions and their parameters
  return service;

  function initializeParameterizedEntityOrView(entityCsn, entityName) {
    const deepCopy = require('../base/deepCopy.js');

    // Naming rules
    // Parameters: EntityType <ViewName>Parameters, EntitySet <ViewName>
    //             with NavigationProperty "Results" pointing to the entity set of type <ViewName>Type
    // Result:     EntityType <ViewName>Result, EntitySet <ViewName>Results

    let parameterCsn = { name: entityName+'Parameters', kind: 'entity', isParamEntity:true, elements: Object.create(null) };

    // propagate containment information, if containment is recursive, use parameterCsn.name as _containerEntity
    if(entityCsn._containerEntity) {
      parameterCsn._containerEntity = [];
      for(let c of entityCsn._containerEntity) {
        parameterCsn._containerEntity.push((c==entityCsn.name)?parameterCsn.name:c);
      }
    }
    entityCsn._containerEntity = [ parameterCsn ];

    let idx = 0;
    forAll(entityCsn.params, (p,n) => {
      let elt = deepCopy(p);
      elt.name = n;
      delete elt.kind;
      elt.key = true; // params become primary key in parameter entity
      parameterCsn.elements[n] = elt;
      idx = (p.indexNo > idx) ? p.indexNo : idx;
    });
    entityCsn.name = entityName+'Result';
    // add assoc to result set, FIXME: is the cardinality correct?
    parameterCsn.elements['Results'] = {
      '@odata.contained':true,
      name: 'Results',
      target: entityCsn,
      type: 'cds.Association',
      indexNo: ++idx,
      cardinality: { sourceMax: 1, targetMin: 0, targetMax: '*' }
    };
    model.definitions[parameterCsn.name] = parameterCsn;
  }
  // Initialize structured artifact (type or entity) 'struct' by doing the
  // following:
  // - attach attributes 'name', 'Name' to elements (FIXME: We currently really require both 'Name' and 'name'!)
  // - create a property 'keys' with all its primary key elements
  // - optionally add the magic ValueList association
  // - call 'initializeAssociation' for each element that has an association type
  // - attach attribute 'name' to all actions and their parameters.  
  function initializeStructure(struct) {

    const appSpecificLateCsnTranformations = require('./appSpecificLateCsnTranformations');

    let keys = Object.create(null);
    // Iterate all struct elements
    forAll(struct.elements, (element, elementName) => {
      // Attach name and Name (Name is used in function ForeignKey4(assoc))
      element.name = element.Name = elementName;

      // Collect keys
      if (element.key) {
        keys[elementName] = element;
      }

      if(options.tntFlavor && !options.tntFlavor.skipValueListMagic)
        addValueListAssociation(element, struct);

      appSpecificLateCsnTranformations.atElement(options, element, struct);
    });

    // create dictionary to hold attributes that should belong to the
    // resulting EntitySet
    let newAttributes = Object.create(null);
    newAttributes['_EntitySetAttributes'] = {
      value: Object.create(null),
      configurable: true,
      enumerable: false,
      writable: true
    }
    Object.defineProperties(struct, newAttributes)

    appSpecificLateCsnTranformations.atStructure(options, struct);

    struct['key'] = keys;
    initializeActions(struct.actions);

  }

  function initializeActions(actions)
  {
    // Attach name to actions and their parameters
    forAll(actions, (a, n) => {
      a.name = n;
      forAll(a.params, (a, n) => {
        a.name = n;
        if(options.tntFlavor && !options.tntFlavor.skipValueListMagic)
        {
          let valueListType = a['@Common.ValueList.type'];
          if(valueListType && valueListType['#'] || valueListType === 'fixed')
            a['@sap:value.list'] = 'fixed-values';
        }
      });
    });
  }

  // Resolve the association type of 'element' in 'struct' by doing the following:
  // - collect the foreign key elements for the target into attribute 'elements'
  // - replace the String attribute 'target' by the actual target artifact
  function initializeAssociation(struct)
  {
    foreach(struct.elements, isAssociationOrComposition, element => {
      if(typeof element.target === "string") {
        let targetEntity = model.definitions[element.target];

        if(targetEntity._containerEntity && targetEntity.params)
          targetEntity = targetEntity._containerEntity[0];

        if (targetEntity == undefined) {
          throw 'Target ' + element.target + ' of association ' + struct.name + '.' + element.name + ' cannot be resolved';
        }

        // Replace target name by its artifact
        element.target = targetEntity;
      }

      //forward annotations from managed association element to its foreign keys
      if(!element.onCond)
      {
        forAll(element.foreignKeys, fk => {
          forAll(element, (attr, attrName) => {
            if(attrName[0] == '@')
              struct.elements[fk.generatedFieldName][attrName] = attr;
          });
        });
      }
    });
  }

  /*
  If an element is annotated with @Common.ValueList.entity, an additional
  unmanaged association is added to the entity type named 'to_' + element.name.
  The value of @Common.ValueList.entity is the association target.
  */
  function addValueListAssociation(element, struct)
  {
    let valueListType = element['@Common.ValueList.type'];
    if(valueListType)
    {
      let valueListEntityName = element['@Common.ValueList.entity'] || element.name;
      let valueListEntity = model.definitions[service.name + '.' + valueListEntityName];

      // TODO: throw error if not found?
      if(valueListEntity)
      {
        if((valueListType['#'] || valueListType) === 'fixed')
          element['@sap.value-list'] = "fixed-values";

        let assocName = 'to_' + element.name;

        let pkn;
        // last key wins, must be only one key, error?
        foreach(valueListEntity.elements, e => e.key,
          (key, keyName) => { pkn = keyName; });
        pkn = assocName + '.' + pkn;

        // add the value list association as new element into struct.elements
        struct.elements[assocName] = {
          name: assocName,
          target: valueListEntity,
          type: 'cds.Association',
          indexNo: Object.keys(struct.elements).length + 1,
          on: element.name + " = " + pkn, 
          onCond: { args: [ { '=' : element.name }, { '=' : pkn } ], op: "=" }
        }
      }
    }
  }
}

function mapCdsToEdmType(cdsType, isV2=false, isMediaType=false)
{
  let edmType = {
    'cds.String': 'Edm.String',
    'cds.LargeString': 'Edm.String',
    'cds.Boolean': 'Edm.Boolean',
    'cds.Integer': 'Edm.Int32',
    'cds.Integer16': 'Edm.Int16',
    'cds.Integer32': 'Edm.Int32',
    'cds.Integer64': 'Edm.Int64',
    'cds.Float': 'Edm.Single',
    'cds.Double': 'Edm.Double',
    'cds.Decimal': 'Edm.Decimal',
    'cds.DecimalFloat': 'Edm.Decimal',
    'cds.Date': 'Edm.Date',
    'cds.Time': 'Edm.TimeOfDay',
    'cds.DateTime':  (isV2 && false) ? 'Edm.DateTime': 'Edm.DateTimeOffset', // eslint-disable-line no-constant-condition
    'cds.Timestamp': (isV2 && false) ? 'Edm.DateTime' : 'Edm.DateTimeOffset', // eslint-disable-line no-constant-condition
    'cds.UTCTimestamp': 'Edm.DateTimeOffset',
    'cds.Binary': 'Edm.Binary',
    'cds.LargeBinary': 'Edm.Binary',
    'cds.UUID': 'Edm.Guid',
  }[cdsType];
  if (edmType == undefined)
    throw "No edm type found for " + cdsType;
  if(isV2)
  {
    if (edmType == 'Edm.Date') 
      edmType = 'Edm.DateTime';
    if (edmType == 'Edm.TimeOfDay')
      edmType = 'Edm.Time';
  }
  else // isV4
  {
    // CDXCORE-CDXCORE-173
    if(isMediaType)
      edmType = 'Edm.Stream';
  }
  return edmType;
}

function addTypeFacets(node, csn)
{
  if (csn.length)
    node.MaxLength = csn.length;
  if (csn.scale)
    node.Scale = csn.scale;
  if (csn.precision)
    node.Precision = csn.precision;
  // Unicode/SRID unused today
  if(csn.unicode)
    node.Unicode = csn.unicode;
  if(csn.srid)
    node.SRID = csn.srid;
}

module.exports = {
  validateOptions,
  intersect,
  foreach,
  forAll,
  isContainee,
  isAssociation,
  isManagedAssociation,
  isComposition,
  isAssociationOrComposition,
  isToMany,
  isEntityOrView,
  isStructuredType,
  isStructuredArtifact,
  isDerivedType,
  isActionOrFunction,
  initializeModel,
  mapCdsToEdmType,
  addTypeFacets
}
