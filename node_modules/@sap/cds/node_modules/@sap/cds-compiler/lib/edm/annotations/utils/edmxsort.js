'use strict';

/* eslint no-console:off */

const program = require('commander');
const fs = require('fs');
const xmlParser = require('../xmlParser')
const xmlWriter = require('../xmlWriter')

program
  .version('0.0.1')
  .parse(process.argv);

//
// read and parse xml file
//
const fileName = program.args[0];
let xml = fs.readFileSync(fileName, 'utf8');
let xmljs = xmlParser.xmlToJs(xml);
//console.log(JSON.stringify(xmljs, null, 2))

//
// do the sort based on the json
//
let xmljs_sorted = doSort(xmljs);
//console.log(JSON.stringify(xmljs_sorted, null, 2))

//
// convert json back to xml and write to output
//
let xml_sorted = xmlWriter.jsToXml(xmljs_sorted);
console.log(xml_sorted);

//
// ------------------------------------------------------------------------------------------------
//

function doSort(js) {
  handle(js);
  return js;
}

function handle(obj) {
  if (!(typeof obj === 'object')) throw obj + " is not an object";

  // sort the object itself
  sortO(obj);

  // recursively sort the elements of object
  if (obj["$elements"]) {
    for (let e of obj["$elements"]) {
      handle(e);
    }
  }
}

// obj is sorted in-place
function sortO(obj) {
  const sortSpec = {
    'Schema': {
      'kind'    : ['EntityContainer', 'EntityType', 'Association', 'Annotations'],
      'sortBy1' : ['Name',            'Name',       'Name',        'Target']
    },
    'EntityContainer' : {
      'kind'    : ['EntitySet', 'FunctionImport', 'AssociationSet'],
      'sortBy1' : ['Name',      'Name',           'Name']
    },
    'Annotations' : {
      'kind'    : ['Annotation'],
      'sortBy1' : ['Term'],
      'sortBy2' : ['Qualifier']
    },
    'Record' : {
      'kind'    : ['PropertyValue', 'Annotation'],
      'sortBy1' : ['Property',      'Term']
    }
  };
  if (sortSpec[obj["$kind"]]) {
    obj["$elements"].sort((e1, e2) => compareBySpec(e1, e2, sortSpec[obj["$kind"]]));
  }
}

function compareBySpec(e1, e2, spec) {
  // spec is an object that specifies how to sort, it has 2 or 3 attributes:
  //   "array" contains all expected element kinds in the order they should appear in the result
  //   "sortBy1" and "sortBy2" (optional) contain the attribute(s) by which elements
  //     of same kind are sorted

  let i1 = spec.kind.indexOf(e1["$kind"]);
  if (i1 < 0) throw "unexpected kind " + e1["$kind"] + " of e1";
  let i2 = spec.kind.indexOf(e2["$kind"]);
  if (i2 < 0) throw "unexpected kind " + e2["$kind"] + " of e2";

  // sort by kind
  if (i1 != i2) return i1-i2;
  // sort by attribute(s)
  let attr = spec.sortBy1[i1];
  if ((e1[attr] != e2[attr]) || !spec.sortBy2) return (e1[attr] < e2[attr]) ? -1 : 1;
  attr = spec.sortBy2[i1];
  return (e1[attr] < e2[attr]) ? -1 : 1;
}
