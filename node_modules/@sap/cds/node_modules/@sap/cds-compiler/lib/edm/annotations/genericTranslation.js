'use strict';

const Edm = require('../edm.js');
const glue = require('../glue.js');
const preprocessAnnotations = require('./preprocessAnnotations.js');
const g_dict = require('./vocabularies/Dictionary.json');
const alerts = require('../../base/alerts');

/**************************************************************************************************
 * csn2annotationEdm
 *
 * options:
 *   v - array with two boolean entries, first is for v2, second is for v4
 *   tntFlavor
 *   embeddedV2
 */
function csn2annotationEdm(csn, options=undefined) {

  // annotation preprocessing, partially tnt specific
  //   the only option used in preprocessAnnotations is tntFlavor
  preprocessAnnotations.preprocessAnnotations(csn, options);

  if(!options)
    throw "Please debug me: csn2annotationsEdm must be invoked with options"

  // FIXME: Omitting the record type is theoretically valid but UIs don't like it, so we always enforce writing it
  let  g_enforceRecordType = true;
  let  g_annosArray = [];

  let v = options.v;

  const { error, signal } = alerts(csn);

  // Note: only works for single service
  // Note: we assume that all objects ly flat in the service, i.e. objName always
  //       looks like <service name, can contain dots>.<id>
  // Note: it is NOT safe to assume that the service itself is the first definition in the csn
  //       -> in general "serviceName" is NOT correctly set during processing of other objects
  let serviceName = null;
  for (let objName in csn.definitions) {
    let object = csn.definitions[objName];
    if (object.kind == "service") {
      serviceName = objName;
    }

    if (object.kind == "action" || object.kind == "function") {
      handleAction(objName, object, null);
    }
    else { // service, entity, anything else?
      // handle the annotations directly tied to the object
      handleAnnotations(objName, object);
      // handle the annotations of the object's elements
      handleElements(objName, object);
      // handle the annotations of the object's actions
      handleBoundActions(objName, object);
    }
  }

  let schema = Edm.Schema.create(v, serviceName, serviceName, g_annosArray, false);
  let service = Edm.DataServices.create(v, schema);
  let edm = Edm.create(v, service);
  return edm;

  // helper to determine the OData version
  //   tnt is always v2
  // TODO: improve option handling and revoce this hack for tnt
  function isV2() {
    return options.tntFlavor || (v && v[0]);
  }

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------



  //
  // this function is called in the translation code to issue an error message
  //    messages are reported via the alerts attribute of csn
  //
  function errorMessage(context, message) {
    let fullMessage = "in annotation translation: " + message;
    if (context) {
      let loc = "target: " + context.target + ", annotation: " + context.term;
      if (context.stack.length > 0) {
        loc += context.stack.join('');
      }
      fullMessage += ", " + loc;
    }
    signal(error`${fullMessage}`);
  }


  // there are 4 possible kinds of targets for annotations
  // csn: annotation at entity
  //      depending on the term, the target in edm is the corresponding
  //      -  entity type 
  //       - or entity set
  // csn: annotation at element of entity
  //      target in edm is the corresponding element of the entity type
  // csn: annotation at parameter of action of entity
  //      target in edm is the action parameter in the EntityContainer



  // handle the annotations of the elements of an object
  // in: objname : name of the object
  //     object : the object itself
  function handleElements(objname, object) {
    if (!object.elements) return;
    for (let elemName in object.elements) {
      let element = object.elements[elemName];

      // determine the name of the target in the resulting edm
      //   for non-assoc element, this simply is "<objectName>/<elementName>"
      let edmTargetName = objname + "/" + elemName;
      handleAnnotations(edmTargetName, element);

      // handle sub elements
      if (element.elements) {
        handleNestedElements(objname, elemName, element.elements);
      }
    }
  }

  // handling annotations at nested elements is not yet supported
  // => issue an error, but only if there actually are annotations
  function handleNestedElements(objname, baseElemName, elementsObj) {
    for (let elemName in elementsObj) {
      let element = elementsObj[elemName];

      if (Object.keys(element).filter( x => x.substr(0,1) == "@" ).filter(filterKnownVocabularies).length > 0) {
        errorMessage(null, "annotations at nested elements are not yet supported, object " + objname + ", element " + baseElemName + "." + elemName);
      }

      if (element.elements) {
        handleNestedElements(objname, baseElemName + "." + elemName, element.elements);
      }
    }
  }


  // annotations for actions and functions (and their parameters)
  // v2, unbound:          Target = <service>.EntityContainer/<action/function>
  // v2, bound:            Target = <service>.EntityContainer/<entity>_<action/function>
  // v4, unbound action:   Target = <service>.<action>()
  // v4, bound action:     Target = <service>.<action>(<service>.<entity>)
  // v4, unbound function: Target = <service>.<function>(<1st param type>, <2nd param type>, ...)
  // v4, bound function:   Target = <service>.<function>(<service>.<entity>, <1st param type>, <2nd param type>, ...)

  // handle the annotations of cObject's (an entity) bound actions/functions and their parameters
  // in: cObjectname : qualified name of the object that holds the actions
  //     cObject     : the object itself
  function handleBoundActions(cObjectname, cObject) {
    // service name -> remove last part of the object name
    // only works if all objects ly flat in the service
    let nameParts = cObjectname.split(".")
    let entityName = nameParts.pop();
    let serviceName = nameParts.join(".");

    for (let n in cObject.actions) {
      let action = cObject.actions[n];
      let actionName = serviceName + "." + (isV2() ? entityName + '_' : '') + n;
      handleAction(actionName, action, cObjectname);
    }
  }

  // handle the annotations of an action and its parameters
  //   called by handleBoundActions and directly for unbound actions/functions
  // in: cActionName       : qualified name of the action
  //     cAction           : the action object
  //     entityNameIfBound : qualified name of entity if bound action/function
  function handleAction(cActionName, cAction, entityNameIfBound) {
    let actionName = cActionName;
    if (isV2()) { // insert before last "."
      actionName = actionName.replace(/\.(?=[^.]*$)/, '.EntityContainer/')
    }
    else { // add parameter type list
      actionName += relParList(cAction, entityNameIfBound);
    }

    handleAnnotations(actionName, cAction);
    for (let n in cAction.params) { // handle parameters
      let edmTargetName = actionName + "/" + n;
      handleAnnotations(edmTargetName, cAction.params[n]);
    }
  }

  function relParList(action, bindingParam) {
    // we rely on the order of params in the csn being the correct one
    let params = [];
    if (bindingParam) params.push(bindingParam);
    if (action.kind === 'function') {
      for (let n in action.params) {
        let p = action.params[n];
        let otype = p.type.startsWith('cds.') ? glue.mapCdsToEdmType(p.type, false /*is only called for v4*/) : p.type;
        params.push(otype);
      }
    }
    return '(' + params.join(',') + ')';
  }


  // note: in csn, all annotations are flattened out
  // => values can be
  //    - primitive values (string, number)
  //    - pseudo-records with "#" or "="
  //    - arrays


  // handle the annotations for a specific object or element or action parameter,
  //   here called carrier
  //   edmCarrierName : string, name of the annotated object in edm,
  //                    element path is separated from object name by "/"
  //            TODO: handling of nested elements?
  //   carrier: object, the annotated object, contains all the annotations
  //                    as properties with names starting with @
  function handleAnnotations(edmCarrierName, carrier) {
    // collect the names of the carrier's annotation properties
    // keep only those annotations that start with a known vocabulary name
    let annoNames = Object.keys(carrier).filter( x => x.substr(0,1) == "@" );
    let knownAnnos = annoNames.filter(filterKnownVocabularies);
    if (knownAnnos.length == 0) return

    // build prefix tree for the annotations attached to the carrier
    let prefixTree = {};
    for (let a of knownAnnos) {
      // remove leading @ and split at "."
      //   stop splitting at ".@" (used for nested annotations)
      let sa = a.split(".@");
      let steps = sa[0].slice(1).split(".");
      if (sa[1]) {
        steps.push('@' + sa[1]);
      }
      mergePathStepsIntoPrefixTree(prefixTree, steps, 0, carrier);
    }

    // figure out where to put the annotations
    let addAnnotation = function() {
      let appliesTest = null;
      let stdName = edmCarrierName;
      let altName = null;
      if (carrier.kind === 'entity' || carrier.kind === 'view') {
        // if annotated object is an entity, annotation goes to the EntityType,
        //   except if AppliesTo contains EntitySet but not EntityType, then annotation goes to EntitySet
        appliesTest = (x => x.match(/EntitySet/) && !x.match(/EntityType/));
        // find last . in name and insert "EntityContainer/"
        altName = edmCarrierName.replace(/\.(?=[^.]*$)/, '.EntityContainer/');
      }
      else if (carrier.kind === 'service') {
        // if annotated object is a service, annotation goes to EntityContainer,
        //   except if AppliesTo contains Schema but not EntityContainer, then annotation goes to Schema
        appliesTest = (x => x.match(/Schema/) && !x.match(/EntityContainer/));
        stdName = edmCarrierName + '.EntityContainer';
        altName = edmCarrierName;
      }

      // result objects that holds all the annotation objects to be created
      let newAnnosStd = Edm.Annotations.create(v, stdName);
      g_annosArray.push(newAnnosStd);
      let newAnnosAlt = null;

      return function(annotation, appliesTo) {
        if (appliesTest && appliesTo && appliesTest(appliesTo)) {
          if (carrier.kind === 'service') {
            g_annosArray.push(annotation); // for target Schema: no <Annotations> element
          }
          else {
            if (!newAnnosAlt) { // only create upon insertion of first anno
              newAnnosAlt = Edm.Annotations.create(v, altName);
              g_annosArray.push(newAnnosAlt);
            }
            newAnnosAlt.append(annotation);
          }
        }
        else {
          newAnnosStd.append(annotation);
        }
      }
    }();

    // now create annotation objects for all the annotations of carrier
    //   and put them into the elements property of the result object
    handleAnno2(addAnnotation, edmCarrierName /*used for error messages*/, prefixTree);
  }


  // tree: object where to put the next level of names
  // path: the parts of the annotation name
  // index: index into that array pointing to the next name to be processed
  //   0  : vocabulary
  //   1  : term
  //   2+ : record properties
  //
  // example:
  //   @v.t1
  //   @v.t2.p1
  //   @v.t2.p2
  //   @v.t3#x.q1
  //   @v.t3#x.q2
  //   @v.t3#y.q1
  //   @v.t3#y.q2
  // 
  //   { v : { t1 : ...,
  //           t2 : { p1 : ...,
  //                  p2 : ...   },
  //           t3#x : { q1 : ..., 
  //                    q2 : ... }
  //           t3#y : { q1 : ...,
  //                    q2 : ... } } }
  function mergePathStepsIntoPrefixTree(tree, pathSteps, index, carrier) {
    // TODO check nesting level > 3
    let name = pathSteps[index];
    if (index+1 < pathSteps.length ) {
      if (!tree[name]) {
        tree[name] = {};
      }
      mergePathStepsIntoPrefixTree(tree[name], pathSteps, index+1, carrier);
    }
    else {
      tree[name] = carrier["@" + pathSteps.join('.')];
    }
  }


  function handleAnno2(addAnnotationFunc, edmCarrierName, prefixTree) {
    // first level names of prefix tree are the vocabulary names
    // second level names are the term names
    // create an annotation object for each term
    for (let voc of Object.keys(prefixTree)) {
      for (let term of Object.keys(prefixTree[voc])) {
        let fullTermName = voc + "." + term;

        // anno is the full <Annotation Term=...>
        let context = { target: edmCarrierName,  term: fullTermName, stack: [] };
        let anno = handleTerm(fullTermName, prefixTree[voc][term], context);

        // addAnnotationFunc needs AppliesTo info from dictionary to decide where to put the anno
        fullTermName = fullTermName.replace(/#(\w+)$/g, "");
        let dictTerm = g_dict.terms[fullTermName]; // message for unknown term issued in handleTerm
        addAnnotationFunc(anno, dictTerm && dictTerm.AppliesTo);
      }
    }
  }


  // annoValue : the annotation value from the csn
  //             if the csn contains flattened out elements of a structured annotation,
  //             they are regrouped here
  // context :   for error messages
  // return :    object that represents the annotation in the result edmx
  function handleTerm(termName, annoValue, context) {
    let newAnno = Edm.Annotation.create(v, termName);

    // termName may contain a qualifier: @UI.FieldGroup#shippingStatus
    // -> remove qualifier from termName and set Qualifier attribute in newAnno
    let p = termName.split('#');
    let termNameWithoutQualifiers = p[0];
    if (p.length>1) {
      newAnno.Term = termNameWithoutQualifiers;
      newAnno.Qualifier = p[1];
    }
    if (p.length>2) {
      errorMessage(context, "multiple qualifiers (" + p[1] + "," + p[2] +  (p.length>3?',...':'') + ")")
    }

    // get the type of the term from the dictionary
    let termTypeName = null;
    let dictTerm = g_dict.terms[termNameWithoutQualifiers];
    if (dictTerm) {
      termTypeName = dictTerm.Type;
    }
    else {
      errorMessage(context, "unknown term " + termNameWithoutQualifiers);
    }

    handleValue(annoValue, newAnno, termNameWithoutQualifiers, termTypeName, 0, context);
    return newAnno;
  }

  // found an enum value ("#"), check whether this fits
  //  the expected type "expectedTypeName"
  function checkEnumValue(enumValue, expectedTypeName, context) {
    let expectedType = g_dict.types[expectedTypeName];
    if (!expectedType && !isPrimitiveType(expectedTypeName)) {
      // TODO: test for this error?
      errorMessage(context, "internal error: dictionary inconsistency: type '" + expectedTypeName + "' not found");
    }
    else if (isComplexType(expectedTypeName)) {
      errorMessage(context, "found enum value, but expected complex type " + expectedTypeName);
    }
    else if (isPrimitiveType(expectedTypeName) || expectedType["$kind"] != "EnumType") {
      errorMessage(context, "found enum value, but expected non-enum type " + expectedTypeName);
    }
    else if (!expectedType["Members"].includes(enumValue)) {
      errorMessage(context, "enumeration type " + expectedTypeName + " has no value " + enumValue);
    }
    return;
  }

  // found an expression value ("=") "expr"
  //   expected type is dTypeName
  // note: expr can also be provided if an enum/complex type/collection is expected
  function handleExpression(expr, dTypeName, context) {
    let typeName = "Path";
    if (dTypeName == "Edm.PropertyPath" ||
        dTypeName == "Edm.AnnotationPath" ||
        dTypeName == "Edm.NavigationPropertyPath") {
      typeName = dTypeName.split('.')[1];
    }

    let val = expr;
    if (!expr) {
      errorMessage(context, "empty expression value");
    }
    else {
      // replace all occurrences of '.' by '/' up to first '@'
      val = expr.split('@').map((o,i) => (i==0 ? o.replace(/\./g, '/') : o)).join('@');
    }

    return {
      name : typeName,
      value : val
    }
  }


  // found a simple value "val"
  //  expected type is dTypeName
  //  mappping rule for values:
  //    if expected type is ... the expression to be generated is ...
  //      floating point type except Edm.Decimal -> Float
  //      Edm.Decimal -> Decimal
  //      integer tpye -> Int
  function handleSimpleValue(val, dTypeName, context) {
    // caller already made sure that val is neither object nor array
    dTypeName = resolveType(dTypeName);

    let typeName = "String";

    if (typeof val === 'string') {
      if (dTypeName == "Edm.AnnotationPath") {
        typeName = "AnnotationPath";
      }
      else if (dTypeName == "Edm.PropertyPath") {
        typeName = "PropertyPath";
      }
      else if (dTypeName == "Edm.String") {
        typeName = "String";
      }
      else if (dTypeName == "Edm.Boolean") {
        if (val == "true" || val == "false") {
          typeName = "Bool";
        }
        else {
          errorMessage(context, "found String, but expected type " + dTypeName);
        }
      }
      else if (dTypeName == "Edm.Decimal") {
        if (isNaN(val) || isNaN(parseFloat(val))) {
          errorMessage(context, "found non-numeric string, but expected type " + dTypeName);
        }
        else {
          typeName = "Decimal";
        }
      }
      else if (dTypeName == "Edm.Double") {
        if (isNaN(val) || isNaN(parseFloat(val))) {
          errorMessage(context, "found non-numeric string, but expected type " + dTypeName);
        }
        else {
          typeName = "Float";
        }
      }
      else if (isComplexType(dTypeName)) {
        errorMessage(context, "found String, but expected complex type " + dTypeName);
      }
      else if (isEnumType(dTypeName)) {
        errorMessage(context, "found String, but expected enum type " + dTypeName);
        typeName = "EnumMember";
      }
      else {
        // TODO
      }
    }
    else if (typeof val === 'boolean') {
      typeName = "Bool";
      if (dTypeName == "Edm.Boolean") {
        val = val ? "true" : "false";
      }
      else if (dTypeName == "Edm.String") {
        typeName = "String";
      }
      else {
        errorMessage(context, "found Boolean, but expected type " + dTypeName);
      }
    }
    else if (typeof val === 'number') {
      if (isComplexType(dTypeName)) {
        errorMessage(context, "found number, but expected complex type " + dTypeName);
      }
      else if (dTypeName === 'Edm.String') {
        typeName = "String";
      }
      else if (dTypeName == "Edm.PropertyPath") {
        errorMessage(context, "found number, but expected " + dTypeName);
      }
      else if (dTypeName == "Edm.Boolean") {
        errorMessage(context, "found number, but expected type " + dTypeName);
      }
      else if (dTypeName == "Edm.Decimal") {
        typeName = "Decimal";
      }
      else if (dTypeName == "Edm.Double") {
        typeName = "Float";
      }
      else {
        typeName = Number.isInteger(val) ? 'Int' : 'Float';
      }
    }
    else {
      errorMessage(context, "expected simple value, but found value '" + val + "' with type '" + typeof val + "'");
    }

    return {
      name : typeName,
      value : val
    };
  }



  // handle the actual value cAnnoValue
  //   oTarget: the result object
  //   oTermName: current term
  //   dTypeName: expected type of cAnnoValue according to dictionary, may be null
  function handleValue(cAnnoValue, oTarget, oTermName, dTypeName, depth, context) {
    // value can be: array, expression, enum, pseudo-record, record, simple value

    if (Array.isArray(cAnnoValue))
    {
      if (isEnumType(dTypeName))
      {
        // if we find an array although we expect an enum, this may be a "flag enum"
        // oTarget.EnumMember = generateMultiEnumValue(cAnnoValue, dTypeName, context);
        checkMultiEnumValue(cAnnoValue, dTypeName, context);
        oTarget.setJSON({ "EnumMember@odata.type" : '#'+dTypeName, EnumMember: generateMultiEnumValue(cAnnoValue, dTypeName, false) });
        oTarget.setXml({ "EnumMember": generateMultiEnumValue(cAnnoValue, dTypeName, true) });

      }
      else
      {
        oTarget.append(generateCollection(cAnnoValue, oTermName, dTypeName, depth+1, context));
      }
    }
    else if (cAnnoValue && typeof cAnnoValue === 'object') {
      if (Object.keys(cAnnoValue).length == 0) {
        errorMessage(context, "empty record");
      }
      else if ("=" in cAnnoValue) {
        let res = handleExpression(cAnnoValue["="], dTypeName, context);
        oTarget[res.name] = res.value;
      }
      else if (cAnnoValue["#"] != undefined)
      {
        if (dTypeName)
        {
          checkEnumValue(cAnnoValue["#"], dTypeName, context);
          oTarget.setJSON({ "EnumMember@odata.type" : '#'+dTypeName, EnumMember: cAnnoValue["#"] });
          oTarget.setXml({ "EnumMember": dTypeName + "/" + cAnnoValue["#"] });
        }
        else
        {
          oTarget.setJSON({ "EnumMember@odata.type" : '#'+oTermName + "Type/", EnumMember: cAnnoValue["#"] });
          oTarget.setXml({ "EnumMember": oTermName + "Type/" + "/" + cAnnoValue["#"] });
        }
      }
      else if (cAnnoValue["$value"]) {
        // "pseudo-structure" used for annotating scalar annotations
        handleValue(cAnnoValue["$value"], oTarget, oTermName, dTypeName, depth, context);

        let k = Object.keys(cAnnoValue).filter( x => x.charAt(0) == "@");
        if (!k || k.length == 0) {
          errorMessage(context, "pseudo-struct without nested annotation");
        }
        for (let nestedAnnoName of k) {
          let nestedAnno = handleTerm(nestedAnnoName.slice(1), cAnnoValue[nestedAnnoName], context);
          oTarget.append(nestedAnno);
        }
      }
      else if (cAnnoValue["$edmJson"]) {
        // "pseudo-structure" used for embedding a piece of JSON that represents "OData CSDL, JSON Representation"
        oTarget.append(handleEdmJson(cAnnoValue["$edmJson"], context));
      }
      else {
        // regular record
        oTarget.append(generateRecord(cAnnoValue, oTermName, false, dTypeName, depth+1, context));
      }
    }
    else {
      let res = handleSimpleValue(cAnnoValue, dTypeName, context);
      oTarget[res.name] = res.value;
    }
  }


  // cAnnoValue: array
  // dTypeName: expected type, already identified as enum type
  //   array is expected to contain enum values
  function checkMultiEnumValue(cAnnoValue, dTypeName, context) {
    // we know that dTypeName is not null
    let type = g_dict.types[dTypeName];
    if (!type || type["IsFlags"] != "true") {
      errorMessage(context, "enum type '" + dTypeName + "' doesn't allow multiple values");
    }

    let index = 0;
    for (let e of cAnnoValue) {
      context.stack.push("[" + index++ + "]");
      if (e["#"]) {
        checkEnumValue(e["#"], dTypeName, context);
      }
      else {
        // TODO improve message: but found ...
        errorMessage(context, "expected an enum value");
      }
      context.stack.pop();
    }
  }

  function generateMultiEnumValue(cAnnoValue, dTypeName, forXml=true)
  {
    // remove all invalid entries (error message has already been issued)
    // replace short enum name by the full name
    // concatenate all the enums to a string, separated by spaces
    return cAnnoValue.filter( x => x["#"] != undefined ).map( x => (forXml ? dTypeName + "/" : "") + x["#"] ).join(forXml ? ' ' : ',');
  }


  // obj:       object representing the record
  // dictRecordTypeName : name of the expected record type according to vocabulary, may be null
  // 
  // can be called for a record directly below a term, or at a deeper level
  //   if the corresponding complex type is unique, it needs not to be written into the
  //   record; if it is abstract or part of a type hierarchy, it must be written
  //   into the record as attribute "Type"
  function generateRecord(obj, termName, inCollection, dictRecordTypeName, depth, context) {
    let newRecord = Edm.Record.create(v);
    let actualTypeName = null;

    if (dictRecordTypeName && !isComplexType(dictRecordTypeName)) {
      errorMessage(context, "found complex type, but expected type '" + dictRecordTypeName + "'");
      return newRecord;
    }

    if (obj["$Type"]) {
      // type is explicitly specified
      actualTypeName = obj["$Type"];
      if (!g_dict.types[actualTypeName]) {
        // this type doesn't exist
        errorMessage(context, "explicitly specified type '" + actualTypeName + "' not found in vocabulary");
        newRecord.Type = actualTypeName;
      }
      else if (dictRecordTypeName && !isDerivedFrom(actualTypeName, dictRecordTypeName)) {
        // this type doesn't fit the expected one
        errorMessage(context, "explicitly specified type '" + actualTypeName
                            + "' is not derived from expected type '" + dictRecordTypeName + "'");
        actualTypeName = dictRecordTypeName;
        newRecord.Type = actualTypeName;
      }
      else if (isAbstractType(actualTypeName)) {
        // this type is abstract
        errorMessage(context, "explicitly specified type '" + actualTypeName + "' is abstract, specify a concrete type");
        actualTypeName = dictRecordTypeName;
        newRecord.Type = actualTypeName;
      }
      else {
        // ok
        if (actualTypeName != dictRecordTypeName || g_enforceRecordType) {
          newRecord.Type = actualTypeName;
        }
      }
    }
    else if (dictRecordTypeName) {
      // convenience for common situation:
      //   if DataFieldAbstract is expected and no explicit type is provided, automatically choose DataField
      if (dictRecordTypeName == "UI.DataFieldAbstract") {
        actualTypeName = "UI.DataField";
      }
      else {
        actualTypeName = dictRecordTypeName;
      }

      if (isAbstractType(actualTypeName)) {
        errorMessage(context, "type '" + dictRecordTypeName + "' is abstract, use '$Type' to specify a concrete type");
        newRecord.Type = actualTypeName;
      }

      if (!g_dict.types[actualTypeName]) {
        // TODO: test?
        errorMessage(context, "internal error: dictionary inconsistency, type '" + actualTypeName + "' not found");
      }

      // do not set Type attribute unless explicitly requested
      if (g_enforceRecordType || (options.tntFlavor && !options.tntFlavor.skipAnnosEnforceRecordType)) {
        newRecord.Type = actualTypeName;
      }
    }
    else if (depth == 1) {
      newRecord.Type = termName + "Type";
    }

    let dictProperties = getAllProperties(actualTypeName);

    // loop over elements
    for (let i in obj) {
      context.stack.push("." + i);

      if (i == "$Type") {
        // nop
      }
      else if (i.charAt(0) == "@") {
        let newAnno = handleTerm(i.substring(1, i.length), obj[i], context);
        newRecord.append(newAnno);
      }
      else {
        let dictPropertyTypeName = null;
        if (dictProperties) {
          dictPropertyTypeName = dictProperties[i];
          if (!dictPropertyTypeName){
            errorMessage(context, "record type '" + actualTypeName + "' doesn't have a property '" + i + "'");
          }
        }

        let newPropertyValue = Edm.PropertyValue.create(v, i);
        handleValue(obj[i], newPropertyValue, termName, dictPropertyTypeName, depth, context);
        newRecord.append(newPropertyValue);
      }

      context.stack.pop();
    }

    return newRecord;
  }


  // annoValue is an array
  // dTypeName : Collection(...) according to dictionary
  //
  function generateCollection(annoValue, termName, dTypeName, depth, context) {
    let newCollection = Edm.Collection.create(v);

    let innerTypeName = null;
    if (dTypeName) {
      var match = dTypeName.match(/^Collection\((.+)\)/);
      if (match) {
        innerTypeName = match[1];
      }
      else {
        errorMessage(context, "found collection value, but expected non-collection type " + dTypeName);
      }
    }

    let index = 0;
    for (let value of annoValue) {
      context.stack.push("[" + index++ + "]");

      if (Array.isArray(value)) {
        errorMessage(context, "nested collections are not supported");
      }
      else if (value && typeof value === 'object') {
        if (value["="]) {
          let res = handleExpression(value["="], innerTypeName, context);
          let newPropertyPath = Edm.ValueThing.create(v, res.name, res.value );
          newCollection.append(newPropertyPath);
        }
        else if (value["#"]) {
          // TODO test
          errorMessage(context, "collections of enums are not yet supported");
        }
        else {
          let rec = generateRecord(value, termName, true, innerTypeName, depth+1, context);
          newCollection.append(rec);
        }
      }
      else {
        let res = handleSimpleValue(value, innerTypeName, context);
        let newThing = Edm.ValueThing.create(v, res.name, value );
        newCollection.append(newThing);
      }

      context.stack.pop();
    }

    return newCollection;
  }

  function handleEdmJson(obj, context) 
  {
    let specialProperties = [ '$Apply', '$LabeledElement' ];
    let subset = glue.intersect(specialProperties, Object.keys(obj));
    
    if(subset.length > 1) { // doesn't work for three or more...
      errorMessage(context, "edmJson code contains more than one special property: " + subset);
      return null;
    }
    if(subset.length == 0) {
      // only one property (that is not a special property)
      if (Object.keys(obj) != undefined && Object.keys(obj).length==1) {
        let k = Object.keys(obj)[0];
        return Edm.ValueThing.create(v, k.slice(1), obj[k] );
      }
      errorMessage(context, "edmJson code contains no special property  out of: " + specialProperties);
      return null;
    }

    // name of special property determines element kind
    let newElem = Edm.Thing.create(v, subset[0].slice(1));
    let mainAttribute = null;

    for (let p in obj) {
      // copy all '$' attributes that are not $Apply or $LabeledElement to Thing
      if(specialProperties.every(v => 
        { return p != v })) 
      {
        if (p.charAt(0) == "$") {
          // simple attribute
          newElem[p.slice(1)] = obj[p];
        }
      } 
      else { // we are either $Apply or $LabeledElement
        // handle value of special property
        let val = obj[p];
        if (Array.isArray(val)) {
          for (let a of val) {
            if (a && typeof a === 'object' && !Array.isArray(a)) {
              newElem.append(handleEdmJson(a, context));
            }
            else if (Array.isArray(a)) {
              errorMessage(context, "verbatim code contains nested array");
            }
            else {
              if (typeof a === 'string') {
                a = a.replace(/&/g, '&amp;')
              }
              newElem.append(Edm.ValueThing.create(v, getTypeName(a),  a));
            }
          }
        }
        else if (val && typeof val === 'object') {
          if (Object.keys(val) != undefined && Object.keys(val).length==1) {
            let k = Object.keys(val)[0];
            mainAttribute = { name: k.slice(1), val: val[k] };
          }
          else {
            let el = handleEdmJson(val, context);
            if (el) {
              newElem.append(el);
            }
          }
        }
        else {
          mainAttribute = { name: getTypeName(val), val: val };
        }
      }
    }

    // special property has a simple value:
    //   value is added as attribute to the element; we add it
    //   only after the other attributes in order to reproduce order
    //   (which is semantically insignificant, but it's nicer this way)
    if (mainAttribute) {
      newElem[mainAttribute.name] = mainAttribute.val;
    }

    return newElem;

    function getTypeName(val) {
      let typeName = "String";
      if (typeof val === 'boolean') {
        typeName = "Bool";
      }
      else if (typeof val === 'number') {
        typeName = Number.isInteger(val) ? 'Int' : 'Decimal';
      }
      return typeName;
    }
  }

  // filter function, assumed to be used for array of string
  //   accepts those strings that start with a knwon vocabulary name
  function filterKnownVocabularies(name) {
    let knownVocabularies = ['Analytics', 'Core', 'Common', 'UI', 'Communication', 'Capabilities', 'Measures'];
    var match = name.match(/^(@)(\w+)/);
    if (match == null) return false;
    return knownVocabularies.includes(match[2]);  // second match group
  }



  //-------------------------------------------------------------------------------------------------
  //-------------------------------------------------------------------------------------------------
  //-------------------------------------------------------------------------------------------------

  // resolve "derived types"
  // -> if dTypeName is a TypeDefinition, replace by
  //    underlying type
  function resolveType(dTypeName) {
    let type = g_dict.types[dTypeName];
    if (type && type.UnderlyingType && type["$kind"] == "TypeDefinition") {
      return type.UnderlyingType;
    }
    return dTypeName;
  }

  function isPrimitiveType(typeName) {
    return typeName.split('.')[0] == "Edm";
  }

  function isEnumType(dTypeName) {
    let type = g_dict.types[dTypeName];
    return type && type["$kind"] == "EnumType";
  }

  function isComplexType(dTypeName) {
    let type = g_dict.types[dTypeName];
    return type && type["$kind"] == "ComplexType";
  }

  function isAbstractType(dTypeName) {
    let type = g_dict.types[dTypeName];
    return type && type["Abstract"] === "true";
  }

  // return true if derived has baseCandidate as direct or indirect base type
  function isDerivedFrom(derived, baseCandidate) {
    while (derived) {
      if (derived == baseCandidate) return true;
      derived = g_dict.types[derived].BaseType;
    }
    return false;
  }


  // return dictionary of all properties of typeName, including those of base types
  function getAllProperties(typeName) {
    if (!typeName || !g_dict.types[typeName]) return null;
    return g_dict.types[typeName].Properties;
  }
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

module.exports = { csn2annotationEdm };
