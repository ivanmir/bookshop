'use strict';

const glue = require('../glue');
const alerts = require('../../base/alerts');


/**************************************************************************************************
 * preprocessAnnotations
 *
 * options:
 *   tntFlavor
 *
 */
function preprocessAnnotations(csn, options) {
  const { error, signal } = alerts(csn);
  let fkSeparator = (options && options.tntFlavor && !options.tntFlavor.skipGeneratedFKsWithout_) ? '' : '_';


  if (options && options.tntFlavor) {
    addCommonTextAndCommonValueListToAssociations();
    moveAnnotationsFromAssocToForeignKeys();
  }
  // for resolveShortcuts... the check for tntFlavor is done inside the function,
  //   because not all transformations are TnT specific
  resolveShortcutsAndTNTspecificModifications();


  // ----------------------------------------------------------------------------------------------


  // helper functions
  function getTargetOfAssoc(assoc) {
    // assoc.target can be the name of the target or the object itself
    return (typeof assoc.target === 'object') ? assoc.target      : csn.definitions[assoc.target];
  }

  function getKeyOfTargetOfManagedAssoc(assoc) {
    // assoc.target can be the name of the target or the object itself
    let targetName = (typeof assoc.target === 'object') ? assoc.target.name : assoc.target;
    let target     = (typeof assoc.target === 'object') ? assoc.target      : csn.definitions[assoc.target];

    let keyNames = Object.keys(target.elements).filter(x => target.elements[x].key);
    if (keyNames.length == 0)
      throw "target " + targetName + " has no key";
    if (keyNames.length > 1)
      signal(error`in annotation preprocessing: target ${targetName} has multiple key elements`);

    // let fkElement = target.elements[keyNames[0]];
    // if(glue.isAssociationOrComposition(fkElement))
    //   // FIXME: throw Error, not string - or do you meant to add an Error to messages?
    //   throw "target " + targetName + " has assoc as key";
    return keyNames[0];
  }



  function addCommonTextAndCommonValueListToAssociations() {

    // TNT - TextAndCommonValueListToAssociations
    if (!(options && options.tntFlavor && options.tntFlavor.skipAnnosTextAndValueListForAssocs)) {
      glue.forAll(csn.definitions, (art) => {
        glue.forAll(art.elements, (elt, eltName) => {
          handleAnnotations(eltName, elt, art);
        })
      });
    }

    function handleAnnotations(elemName, elem, object) {
      if(!((object.kind == 'entity' || object.kind == 'view') &&
          (elem.type == "cds.Association" || elem.type == "Association") && elem.on == undefined))
        return;

      let assoc = elem;

      if (assoc["@odata.navigable"] != undefined && assoc["@odata.navigable"] == false) {
        return;
      }

      let targetName = assoc.target.name;
      let targetNameShort = targetName.split(".").pop();
      let fkName = getKeyOfTargetOfManagedAssoc(assoc);

      let targetEntity = assoc.target; // csn.definitions[targetName];

      // ValueList.Label
      // 1) Common.Label of assoc
      // 2) Common.Label of target entity
      // 3) name of target entity
      let label = "UNKNOWN1";
      if (assoc["@Common.Label"] != undefined) {
        label = assoc["@Common.Label"];
      }
      else if (targetEntity["@Common.Label"] != undefined) {
        label = targetEntity["@Common.Label"];
      }
      else {
        label = targetNameShort;
      }

      // for Common.Text and DisplayOnly
      let uiId = null;
      let tEId = targetEntity["@UI.Identification"];
      if (tEId && tEId[0])
      {
        if (tEId[0]["="]) {
          uiId = tEId[0]["="];
        }
        else if (tEId[0]["Value"] && tEId[0]["Value"]["="]) {
          uiId = tEId[0]["Value"]["="];
        }
      }

      // @Common.Text
      if (uiId != null) {
        assoc["@Common.Text"] = {
          "$value": { "=": elemName + "/" + uiId },
          "@UI.TextArrangement": { "#": "TextOnly" }
        };
      }

      assoc["@Common.ValueList.Label"] = label;
      assoc["@Common.ValueList.CollectionPath"] = targetNameShort;
      assoc["@Common.ValueList.Parameters"] = [
        {
          "$Type": "Common.ValueListParameterInOut",
          "LocalDataProperty": { "=": elemName + fkSeparator + fkName },
          "ValueListProperty": fkName
        }
      ];

      if (uiId != null) {
        assoc["@Common.ValueList.Parameters"].push(
          {
            "$Type": "Common.ValueListParameterDisplayOnly",
            "ValueListProperty": uiId
          }
        );
      }
    }
  }


  // resolve shortcuts and do some TNT specific modifications
  function resolveShortcutsAndTNTspecificModifications() {
    let art = null;

    glue.forAll(csn.definitions, (artifact, artifactName) =>{
      art = artifactName;
      handleAnnotations(artifactName, artifact);
      glue.forAll(artifact.elements, (element, elementName) => {
        handleAnnotations(elementName, element);
      });
      glue.forAll(artifact.actions, (action) => {
        glue.forAll(action.params, (param, paramName) => {
          handleAnnotations(paramName, param);
        });
      });
    });

    function handleAnnotations(carrierName, carrier) {

      function replaceManagedAssocByFK(ae) {
        let path = ae["="];
        let steps = path.split('.');
        let ent = carrier;
        for (let i in steps) {
          if (!ent || ent.kind != 'entity') return;
          let el = ent.elements[steps[i]];
          if (el && glue.isAssociation(el)) {
            if (i < steps.length-1) {
              ent = getTargetOfAssoc(el);
            }
            else { //last step
              if (!el.onCond) { // only for managed
                ae["="] += fkSeparator + getKeyOfTargetOfManagedAssoc(el);
              }
            }
          }
        }
      }

      // collect the names of the carrier's annotation properties
      let annoNames = Object.keys(carrier).filter( x => x.substr(0,1) == "@")

      for (let aName of annoNames) {
        let aNameWithoutQualifier = aName.split("#")[0];
        let a = carrier[aName];

        // Always - FixedValueListShortcut
        //   expand shortcut form of ValueList annotation
        if (aNameWithoutQualifier == "@Common.ValueList.entity") {
          try {
            // if CollectionPath is explicitly given, no shortcut expansion is made
            if (carrier["@Common.ValueList.CollectionPath"]) {
              throw "leave";
            }

            //for error messages
            let ctx = "target: " + art + "/" + carrierName;

            // check on "type"? e.g. if present, it must be #fixed ... ?

            // the value list entity
            let entityName = carrier["@Common.ValueList.entity"]; // name of value list entity
            if (entityName["="]) {
              signal(error`in annotation preprocessing/value help shortcut: 'entity' must be a string, ${ctx}`);
            }
            let ename = entityName["="] || entityName;
            let nameprefix = art.replace(/.[^.]+$/, ''); // better way of getting the service name?
            let vlEntity = csn.definitions[nameprefix + '.' + ename];
            if (!vlEntity) {
              signal(error`in annotation preprocessing/value help shortcut: entity ${ename} does not exist, ${ctx}`);
              throw "leave";
            }

            // label
            //   explicitly provided label wins
            //   TODO: once TnT excpetion for nonexisting vlEntity is removed, simplify condition
            let label = carrier["@Common.ValueList.Label"] ||
                        carrier["@Common.Label"] || (vlEntity && vlEntity["@Common.Label"]) || ename;

            // localDataProp
            //   name of the element carrying the value help annotation
            //   if this is a managed assoc, use fk field instead (if there is a single one)
            let localDataProp = carrierName.split("/").pop();
            if (glue.isManagedAssociation(carrier)) {
              localDataProp = localDataProp + fkSeparator + getKeyOfTargetOfManagedAssoc(carrier);
            }

            // valueListProp: the (single) key field of the value list entity
            //   if no key or multiple keys -> error
            let valueListProp = null;
            let keys = Object.keys(vlEntity.elements).filter( x => vlEntity.elements[x].key );
            if (keys.length == 0) {
              signal(error`in annotation preprocessing/value help shortcut: entity ${ename} has no key, ${ctx}`);
              throw "leave";
            }
            else if (keys.length > 1)
              signal(error`in annotation preprocessing/value help shortcut: entity ${ename} has more than one key, ${ctx}`);
            valueListProp = keys[0];

            // textField:
            //   first entry of @UI.Identification
            //     can be an expression (tnt shortcut before expansion)
            //     can be a record with property 'Value' and expression as its value
            // OR
            //   the (single) non-key string field, if there is one
            let textField = null;
            let Identification = vlEntity['@UI.Identification'];
            if (Identification && Identification[0] && Identification[0]['=']) {
              textField = Identification[0]['='];
            } else if (Identification && Identification[0] && Identification[0]["Value"] && Identification[0]["Value"]['=']) {
              textField = Identification[0]["Value"]['='];
            }
            else {
              let stringFields = Object.keys(vlEntity.elements).filter(
                x => !vlEntity.elements[x].key && vlEntity.elements[x].type == "cds.String")
              if (stringFields.length == 1)
                textField = stringFields[0];
            }

            // explicitly provided parameters win
            let parameters = carrier["@Common.ValueList.Parameters"];
            if (!parameters) {
              parameters = [{
                "$Type": "Common.ValueListParameterInOut",
                "LocalDataProperty" : { "=" : localDataProp },
                "ValueListProperty" : valueListProp
              }];
              if (textField) {
                parameters[1] = {
                  "$Type": "Common.ValueListParameterDisplayOnly",
                  "ValueListProperty" : textField
                };
              }
            }

            let newObj = Object.create( Object.getPrototypeOf(carrier) );
            for (let e in carrier) {
              if (e == "@Common.ValueList.entity") {
                newObj["@Common.ValueList.Label"] = label;
                newObj["@Common.ValueList.CollectionPath"] = entityName;
                newObj["@Common.ValueList.Parameters"] = parameters;
                if (textField && options && options.tntFlavor) {
                  newObj["@Common.Text"] = {
                    // here we rely on ValueListMagic: an association has been created based on @Common.ValueList.fixed
                    "$value": { "=": "to_" + carrierName + "/" + textField },
                    "@UI.TextArrangement": { "#": "TextOnly" }
                  };
                }
              }
              else if (e == "@Common.ValueList.type" ||
                      e == "@Common.ValueList.Label" ||
                      e == "@Common.ValueList.Parameters") {
                // nop
              }
              else {
                newObj[e] = carrier[e];
              }
              delete carrier[e];
            }
            Object.assign(carrier, newObj);
          }
          catch (e) {
            // avoid subsequent errors
            delete carrier["@Common.ValueList.entity"];
            delete carrier["@Common.ValueList.type"];
          }
        }

        // TNT - TextArrangementReordering
        //   convert TextArrangement annotation that is on same level as
        //     Text annotation into a nested annotation
        if ((aNameWithoutQualifier == "@UI.TextArrangement" ||
            aNameWithoutQualifier == "@Common.TextArrangement")
            && (options && options.tntFlavor && !options.tntFlavor.skipAnnosTextArrangementReordering)) {
          // can only occur if there is a @Common.Text annotation at the
          //   same target
          let textAnno = carrier["@Common.Text"];
          if (textAnno == undefined) throw "TextArrangement without Text"
          //change the scalar anno into a "pseudo-structured" one

          // TNT: this fixes a bug in the TNT model where a string is
          //     given instead of an enum
          let value = carrier[aName];
          if (value === "TextFirst") {
            value = { "#": value };
          }

          let newTextAnno = { "$value": textAnno, "@UI.TextArrangement": value };
          carrier["@Common.Text"] = newTextAnno;
          delete carrier[aName];
        }

        // TNT - SubstitutingFKeysForAssocs
        if (options && options.tntFlavor && !options.tntFlavor.skipAnnosSubstitutingFKeysForAssocs) {
          // replace association by fk field, mind nested annotatinos
          if (aNameWithoutQualifier == "@UI.LineItem"       || aNameWithoutQualifier == "@UI.LineItem.$value" ||
              aNameWithoutQualifier == "@UI.Identification" || aNameWithoutQualifier == "@UI.Identification.$value" ||
              aNameWithoutQualifier == "@UI.FieldGroup"     || aNameWithoutQualifier == "@UI.FieldGroup.$value") {
            for (let ae of a) {
              if (ae["Value"] && ae["Value"]["="]) {
                replaceManagedAssocByFK(ae["Value"]);
              }
            }
          }

          // replace association by fk field
          if (aNameWithoutQualifier == "@UI.SelectionFields") {
            for (let ae of a) {
              if ("=" in ae) {
                replaceManagedAssocByFK(ae);
              }
            }
          }
        }
      }
    }
  }

  /*
  Forward all annotations from the association element to its generated foreign key elements
  and remove the annotations from the association afterwards (move)
  Input: OData preprocessed CSN with entity definitions
  */
  function moveAnnotationsFromAssocToForeignKeys() {
    // managed association
    // (not at compositions, because we think they never are managed ... ???)

    glue.foreach(csn.definitions, obj => (obj.kind == 'entity' || obj.kind == 'view'), entity => {
      glue.foreach(entity.elements, e => glue.isManagedAssociation(e), element =>
      {
        // copy annotations from assoc to all generated foreign key fields
        // FIXME: This should actually be done always, regardless of TNT (the ODATA preprocesor has already
        // done it for all existing annotations, but all creation/modification magic happening during this
        // post-processing needs to go to the foreign key fields as well). Alternatively, one could make
        // sure that all magic happening here is directly applied to foreign key fields, too.
        glue.forAll(element.foreignKeys, fk => {
          glue.forAll(element, (attr, attrName) => {
            if(attrName[0] == '@')
              entity.elements[fk.generatedFieldName][attrName] = attr;
          });
        });
        // remove annotations from assoc (separated from copy because there might be multiple foreign keys)
        if (!(options && options.tntFlavor && options.tntFlavor.skipAnnosRemoveManagedAssociationAnnos)) {
          for (let a in element) {
            if (a[0] == "@") {
              delete element[a];
            }
          }
        }
      });
    });
  }

}

module.exports = {
  preprocessAnnotations,
};
