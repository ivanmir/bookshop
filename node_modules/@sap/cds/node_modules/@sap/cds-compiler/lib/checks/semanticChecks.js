'use strict';

// Main entry for the CDS semantic checks

const baseModel = require('../base/model');
const alerts = require('../base/alerts');
const checkAnnotationAssignments = require('./checkAnnotationAssignments');
const getFunctionAndActionChecks = require('./checkFunctionsActions');
const { checkArtifactImplementedIn, checkNotEmptyOrOnlyVirtualElems, checkNoUnmanagedAssocsInGroupByOrderBy } = require('./checkArtifacts');
const { checkVirtualElement, checkManagedAssoc, checkCardinality } = require('./checkElements');

// Note: For the organization of these checks, we distinguish the following terms:
// - a 'construct' is something that has a 'kind' (so this is the the most general term)
// - an 'artifact' is a construct that lives in 'model.definitions' (e.g. an entity or an unbound function)
// - a 'member' is a construct that lives in an artifact, possibly nested (e.g. an element, function or parameter)
// - a 'container' is an artifact that can contain other artifacts (e.g. a context or service)

// Generally, the main 'semanticCheck' function ensures that for each construct, the appropriate
// check functions are called according to 'kind', from generic to specific.
// For example, an entity is an artifact, which is a construct, so the following
// function would be called:
// - checkGenericConstruct(art)
// - checkGenericArtifact(art)
// - checkEntity(art)
// To keep things simple, the actual check functions are intended to be leafs in this call hierarchy,
// so please do not call specific check functions from generic ones, and do not iterate members within
// artifact check functions (or artifacts within containers) just in order to call sub-checks. It is
// of course OK to iterate content if that is part of the actual check itself.

// Perform semantic check on all artifacts within (augmented) model. Report errors to model.messages.
function semanticCheck(model) {
  let options = model.options;
  const { error, signal } = alerts(model);
  const { checkBoundActionOrFunction, checkUnboundActionOrFunction,
          checkActionOrFunctionParameter} = getFunctionAndActionChecks(model);

  // Iterate the model and call generic/specific checkers on each construct
  // (please do not put any actual checks here)
  baseModel.forEachDefinition(model, artifact => {
    checkGenericConstruct(artifact);
    checkGenericArtifact(artifact);
    if (artifact.kind == 'context' || artifact.kind == 'service' || artifact.kind == 'namespace' || artifact.kind == 'accesspolicy') {
      checkGenericContainer(artifact);
    }
    callKindSpecificCheck(artifact);
    baseModel.forEachMemberRecursively(artifact, member => {
      checkGenericConstruct(member);
      checkGenericMember(member);
      callKindSpecificCheck(member);
    }); 
  });

  // Call the appropriate kind-specific check function for 'construct'
  function callKindSpecificCheck(construct) {
    // For each kind, there must be a check function (so that we don't forget one)
    const checkFunctions = {
      context: nothingToCheckYet,
      service: nothingToCheckYet,
      namespace: nothingToCheckYet,
      accesspolicy: nothingToCheckYet,
      entity: checkEntity,
      annotation: nothingToCheckYet,
      type: checkType,
      element: checkElement,
      param: checkParam,
      enum: nothingToCheckYet,
      const: nothingToCheckYet,
      key: nothingToCheckYet,
      function: checkActionOrFunction,
      action: checkActionOrFunction,
      query: nothingToCheckYet,
      view: checkView,
      role: nothingToCheckYet,
      aspect: nothingToCheckYet,
      package: nothingToCheckYet,
    }
    let func = checkFunctions[construct.kind];
    if (!func) {
      throw Error('No check function defined for kind ' + construct.kind);
    }
    func(construct);
  }

  // ----------------------------------------------------------------------------------
  // Generic check functions. Please put only common checks here and do not iterate
  // or dispatch further (should be done above in semanticCheck)

  // Called for every 'construct', i.e for artifacts and members alike
  function checkGenericConstruct(construct) {
    if (construct.name.id.indexOf('.') != -1) {
      signal(error`The character '.' is not allowed in an identifier: "${construct.name.id}"`, construct.name.location);
    }
    checkAnnotationAssignments(construct, model);
  }

  // Called for each main artifact (no need to iterate its members)
  function checkGenericArtifact(art) {
    // user defined objects must not live in namespace cds,
    //   exception: they can live in cds.foundation
    if (art.kind != 'namespace' &&
        (art.name.absolute == 'cds' ||
        (art.name.absolute.match(/^cds\./) && !art.name.absolute.match(/^cds\.foundation\./)))) {
      signal(error`The namespace "cds" is reserved for CDS builtins`, art.name.location);
    }
    if (options.toHana) {
      checkNotEmptyOrOnlyVirtualElems(art, model);
    }
  }

  // Called for each member (no need to iterate sub-members)
  // eslint-disable-next-line no-unused-vars
  function checkGenericMember(member) {
    // No checks yet
  }

  // Called for each container (no need to iterate contained artifacts)
  // eslint-disable-next-line no-unused-vars
  function checkGenericContainer(container) {
    // No checks yet
  }

  // ----------------------------------------------------------------------------------
  // Specific check functions, normally one per kind (exceptions are OK where kinds are
  // too similar)

  function checkEntity(entity) {
    if (entity.impl) {
      checkArtifactImplementedIn(entity, model);
    }
    if (entity.source) { // projection
      checkProjection(entity, model);
    }
  }

  function isAbstractEntity(entity) {
    return entity && entity.abstract && entity.abstract.val===true;
  }

  function checkProjection(entity, model) {
    let sourceEntity = model.definitions[entity.source.absolute];
    if(sourceEntity && isAbstractEntity(sourceEntity)) {
      signal(error`Projection ${entity.name.absolute} on abstract entity ${sourceEntity.name.absolute}`, entity.source.location);
    }
  }

  function checkView(view) {
    if (view.impl) {
      checkArtifactImplementedIn(view, model);
    }
    if (view.source) {
      let sourceEntity = model.definitions[view.source.absolute];
      if(sourceEntity && isAbstractEntity(sourceEntity)) {
        signal(error`View ${view.name.absolute} on abstract entity ${sourceEntity.name.absolute}`, view.source.location);
      }
    }
    checkNoUnmanagedAssocsInGroupByOrderBy(view, model);
  }

  function checkType(type) {
    checkManagedAssoc(type, model);
  }

  function checkElement(elem) {
    checkVirtualElement(elem, model);
    checkManagedAssoc(elem, model);
    checkCardinality(elem, model);
  }

  // Actions and functions are almost identical, so we use only one check function
  function checkActionOrFunction(act) {
    if (act._parent && (act._parent.kind == 'entity' || act._parent.kind == 'view')) {
      checkBoundActionOrFunction(act);
    } else {
      checkUnboundActionOrFunction(act);
    }
  }

  function checkParam(param) {
    if (param._parent && (param._parent.kind == 'action' || param._parent.kind == 'function')) {
      checkActionOrFunctionParameter(param, param._parent);
    }
  }

  // Dummy for things that we don't check yet
  function nothingToCheckYet() {
    // Intentionally empty
  }
}

module.exports = semanticCheck;
