//

'use strict';

const kindProperties = {
  // TODO: also foreignKeys ?
  namespace: { artifacts: true }, // on-the-fly context
  context: { artifacts: true, normalized: 'namespace' },
  service: { artifacts: true, normalized: 'namespace' }, // actions: true with "service-bound" actions
  entity: { elements: true, actions: true, params: () => false },
  view: { elements: true, actions: true, params: () => false }, // elements disabled via special check
  query: { elements: true },
  $tableAlias: { normalized: 'alias', $navigation: true }, // table alias in select
  $navElement: { normalized: 'element', $navigation: true },
  type:  { elements: propExists, enum: propExists },
  annotation: { elements: propExists, enum: propExists },
  const: {},
  enum: { normalized: 'element' },
  package: {},
  accesspolicy: { artifacts: true },
  role: {},
  aspect: {},
  element: { elements: propExists, enum: propExists, dict: 'elements' },
  action: { params: () => false, elements: () => false, enum: () => false, dict: 'actions' }, // no extend params, only annotate
  function: { params: () => false, elements: () => false, enum: () => false, normalized: 'action' }, // no extend params, only annotate
  key: { normalized: 'element' },
  param: { elements: () => false, enum: () => false, dict: 'params' },
  source: { artifacts: true },
  block: { artifacts: true },
  using: {},
  extend: { isExtension: true },
  annotate: { isExtension: true, elements: true, enum: true, actions: true, params: true },
  builtin: {},                  // = CURRENT_DATE, TODO: improve
}

const queryOps = {
  query: true,                  // TODO: rename to SELECT
  union: true,
  unionAll: true,
  intersect: true,
  except: true,
  subquery: true,               // for (subquery) with ORDER BY or LIMIT/OFFSET
}

function propExists( prop, parent ) {
  let obj = parent.returns || parent;
  return (obj.items || obj)[prop];
}

// Apply function `callback` to all artifacts in dictionary
// `model.definitions`.  See function `forEachGeneric` for details.
function forEachDefinition( model, callback ) {
  forEachGeneric( model, 'definitions', callback );
}

// Apply function `callback` to all members of object `obj` (main artifact or
// parent member).  Members are considered those in dictionaries `elements`,
// `enum`, `actions` and `params` of `obj`, `elements` and `enums` are also
// searched inside property `items` (array of).  See function `forEachGeneric`
// for details.
function forEachMember( construct, callback ) {
  let obj = construct.returns || construct; // why the extra `returns` for actions?
  obj = obj.items || obj;
  forEachGeneric( obj, 'elements', callback );
  forEachGeneric( obj, 'enum', callback );
  forEachGeneric( obj, 'foreignKeys', callback );
  forEachGeneric( construct, 'actions', callback );
  forEachGeneric( construct, 'params', callback );
}

// Apply function `callback(member, memberName)` to each member in `construct`,
// recursively (i.e. also for sub-elements of elements).
function forEachMemberRecursively( construct, callback ) {
  forEachMember( construct, ( member, memberName ) => {
    callback( member, memberName );
    // Descend into nested members, too
    forEachMember( member, callback );
  });
  // If 'construct' has more than one query, descend into the elements of the remaining ones, too
  if (construct.queries && construct.queries.length > 1) {
    construct.queries.slice(1).forEach(query => forEachMemberRecursively(query, callback));
  }
}

// Apply function `callback` to all objects in dictionary `dict`, including all
// duplicates (found under the same name).  Function `callback` is called with
// the following arguments: the object, the name, and -if it is a duplicate-
// the array index and the array containing all duplicates.
function forEachGeneric( obj, prop, callback ) {
  let dict = obj[prop];
  for (let name in dict) {
    let obj = dict[name];
    if (obj instanceof Array) // redefinitions
      obj.forEach( (o, i, a) => callback( o, name, prop, i, a ) )
    else
      callback( obj, name, prop );
  }
}

const forEachInOrder = forEachGeneric;

// Call function `callback` with arguments `target` and `source` where `source`
// is calculated by `sourceRef(target)._artifact`, make sure that `callback`
// had been called with `source` as `target` before, and so on.  To do so, we
// set property `_status` of the objects involved to value `status`.
function applyLinearly( status, target, sourceRef, callback ) {
  if (!target)
    return;
  let chain = [];
  let obj;
  while ((obj = sourceRef(target)) && obj._status !== status && obj._artifact) {
    setProp( obj, '_status', status );
    chain.push( target );
    target = obj._artifact;
  }
  let source = target;
  for (target of chain.reverse()) {
    callback( target, source );
    source = target;
  }
}

// Like `obj.prop = value`, but not contained in JSON / CSN
function setProp (obj, prop, value) {
  Object.defineProperty( obj, prop, { value, configurable: true, writable: true } );
}

// Clone 'node', transforming nodes therein recursively. Object 'transformers' is expected
// to contain a mapping of property 'key' names to transformer functions. The node's properties
// are walked recursively, calling each transformer function on its corresponding property
// 'key' of 'node', replacing 'value' in 'resultNode' with the function's return value
// (returning 'undefined' will delete the property).
// If no transformation function is found for 'key', the first letter of 'key' is tried
// instead (this seems to be intended for handling annotations that start with '@' ?)
// FIXME: Do we really need this ?
// Regardless of their names, transformers are never applied to dictionary elements.
//
// The transformer functions are called with the following signature:
//   transformer(value, node, resultNode, key)
function cloneWithTransformations(node, transformers) {

  return transformNode(node);

  // This general transformation function will be applied to each node recursively
  function transformNode(node) {
    // Return primitive values and null unchanged, but let objects and dictionaries through
    // (Note that 'node instanceof Object' would be false for dictionaries).
    if (node == null || typeof node !== 'object') {
      return node
    }
    // Transform arrays element-wise
    if (node instanceof Array) {
      return node.map(transformNode);
    }
    // Things not having 'proto' are dictionaries
    let proto = Object.getPrototypeOf(node);
    // Iterate own properties of 'node' and transform them into 'resultNode'
    let resultNode = Object.create(proto);
    for (let key of Object.keys(node)) {
      // Dictionary always use transformNode(), other objects their transformer according to key
      let transformer = (proto == undefined) ? transformNode : transformers[key] || transformers[key.charAt(0)];
      // Apply transformer, or use transformNode() if there is none
      let resultValue = (transformer || transformNode)(node[key], node, resultNode, key);
      if (resultValue !== undefined) {
        resultNode[key] = resultValue;
      }
    }
    return resultNode;
  }
}


module.exports = {
  kindProperties,
  queryOps,
  forEachDefinition,
  forEachMember,
  forEachMemberRecursively,
  forEachGeneric,
  forEachInOrder,
  applyLinearly,
  setProp,
  cloneWithTransformations,
};
