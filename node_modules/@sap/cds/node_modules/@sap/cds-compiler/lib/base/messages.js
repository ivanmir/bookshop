// Functions and classes for syntax messages

'use strict';

// For messageIds, where no severity has been provided via code (central def)
const standardSeverities = {
  'syntax-anno-after-struct': 'Warning',
  'syntax-anno-after-enum': 'Warning',
  'syntax-anno-after-params': 'Warning', // very ugly!
}

// For messageIds, where no text has been provided via code (central def)
const standardTexts = {
  'syntax-anno-after-struct': 'Avoid annotation assignments after structure definitions',
  'syntax-anno-after-enum': 'Avoid annotation assignments after enum definitions',
  'syntax-anno-after-params': 'Avoid annotation assignments after parameters',
}

function hasErrors( messages ) {
  return messages && messages.some( m => m.severity === 'Error' );
}

// Return gnu-style error string for location `loc`:
//  - 'File:Line:Col' without `loc.end`
//  - 'File:Line:StartCol-EndCol' if Line = start.line = end.line
//  - 'File:StartLine.StartCol-EndLine.EndCol' otherwise
function locationString( loc, normalizeFilename ) {
  if (!loc)
    return '<???>';
  let filename = (loc.filename && (normalizeFilename || normalizeFilename === 0))
      ? loc.filename.replace( /\\/g, '/' )
      : loc.filename;
  if (!(loc instanceof Object) || !loc.start)
    return loc;
  return (!loc.end)
    ? `${filename}:${loc.start.line}:${loc.start.column}`
    : (loc.start.line == loc.end.line)
    ? `${filename}:${loc.start.line}:${loc.start.column}-${loc.end.column}`
    : `${filename}:${loc.start.line}.${loc.start.column}-${loc.end.line}.${loc.end.column}`;
}

// Class for combined compiler errors.  Additional members:
//  `errors`: vector of errors (CompileMessage and errors from peg.js)
//  `model`: the CSN model
class CompilationError extends Error {
  constructor(errs, model, ...args) {
    super(...args);
    this.errors = errs;
    this.model = model;
  }
}

// Class for individual compile errors.
// TODO: an error code would be good in future (configuration, translation, â€¦)
class CompileMessage extends Error {
  constructor(location, msg, severity = 'Error', id) {
    super(msg);
    this.location = location;
    this.severity = severity;
    if (id)
      this.messageId = id;
  }
  toString() {                  // should have no argument...
    return messageString(this);
  }
}

function handleMessages( model ) {
  if (model.messages && model.messages.length) {
    model.messages.sort( compareMessage );
    if (hasErrors( model.messages ))
      throw new CompilationError( model.messages, model );
  }
}

const severitySpecs = {
  error: { name: 'Error', level: 0 },
  warning: { name: 'Warning', level: 1 },
  info: { name: 'Info', level: 2 },
  debug: { name: 'Debug', level: 3 }
}

function normalizedSeverity( severity ) {
  if (typeof severity !== 'string')
    return (severity === null) ? 'Debug' : 'Error';
  let s = severitySpecs[ severity.toLowerCase() ];
  return s && s.name || 'Error';
}

function getMessageFunction( model ) {
  if (!model.messages)
    model.messages = [];
  let config = model.options && model.options.severities || {};

  return function message( id, location, params = {}, severity = undefined, texts = undefined ) {
    if (!severity)              // TODO: check that they are always eq per messageId
      severity = standardSeverities[id];
    let s = normalizedSeverity( severity );
    if ((s !== 'Error' || severity instanceof Array) && id && id in config )
      s = normalizedSeverity( config[id] );
    let text = (typeof params === 'string')
        ? params
        : messageText( texts || standardTexts[id], params );
    let msg = new CompileMessage( location, text, s, id );
    model.messages.push( msg );
    return msg;
  }
}

const paramsTransform = {
  alias: n => msgName(n),
  anno: transformAnno,
  art: transformArg,
  code: n => '`' + n + '`',
  name: n => msgName(n),
  id: n => msgName(n)
};

function transformAnno( anno ) {
  return (anno.charAt() === '@') ? msgName( anno ) : msgName( '@' + anno );
  // if (anno.charAt() === '@')
  //   anno = anno.slice(1);
  // return (!anno || /[^A-Za-z_0-9.]/.test(anno)) ? msgName( '@' + anno ) : '@' + anno;
}

function transformArg( arg, r, args, texts ) {
  if (!arg || typeof arg !== 'object' || !texts.elem || args.elem != null)
    return msgName( arg );
  if (arg._artifact)
    arg = arg._artifact;
  if (arg.name)
    arg = arg.name;
  if (!arg.element)
    return msgName( arg );
  r['#'] = 'elem';              // text variant 'elem'
  r.elem = msgName( arg.element );
  return msgName( arg, true );
}

function messageText( texts, params ) {
  if (typeof texts === 'string')
    texts = { std: texts };
  let args = {};
  for (let p in params) {
    let t = paramsTransform[p];
    args[p] = (t) ? t( params[p], args, params, texts ) : params[p];
  }
  let variant = args['#'];
  return replaceInString( variant && texts[ variant ] || texts.std, args );
}

function replaceInString( text, params ) {
  let pattern = /\$\(([A-Z]+)\)/g;
  let parts = [];
  let start = 0;
  for (let p = pattern.exec( text ); p; p = pattern.exec( text )) {
    let prop = p[1].toLowerCase();
    parts.push( text.substring( start, p.index ),
                (prop in params ? params[prop] : p[0]) );
    delete params[prop];
    start = pattern.lastIndex;
  }
  parts.push( text.substring( start ) );
  let remain = Object.keys( params ).filter( n => n !== '#' && params[n] );
  return (remain.length)
         ? parts.join('') + '; ' +
           remain.map( n => n.toUpperCase() + ' = ' + params[n] ).join(', ')
         : parts.join('');
}



// Return message string with location if present
function messageString( err, normalizeFilename, noMessageId ) {
  return (err.location ? locationString( err.location, normalizeFilename ) + ': ' : '') +
         (err.severity||'Error') +
         (err.messageId && !noMessageId ? ' ' + err.messageId + ': ' : ': ') +
         err.message;
}

// Compare two messages `a` and `b`. Return 0 if they are equal, 1 if `a` is
// greater than `b`, and -1 if `a` is less than `b`. Messages without a location
// are considered equal, unless compared to a message with location, in which
// case they are considered larger, so they are put at the end of a sorted list
function compareMessage( a, b ) {
  if (a.location && b.location) {
    let aend = a.location.end || a.location.start;
    let bend = b.location.end || b.location.start;
    return ( c( a.location.filename, b.location.filename ) ||
             c( a.location.start.line, b.location.start.line ) ||
             c( a.location.start.column, b.location.start.column ) ||
             c( aend.line, bend.line ) ||
             c( aend.column, bend.column ) ||
             c( a.message, b.message ) );
  }
  else
    return (!a.location ? (!b.location ? 0 : 1) : -1);

  function c( x, y ) {
    return (x == y) ? 0 : (x > y) ? 1 : -1;
  }
}

// Return string for complete reference
function refString( name, noElement ) {
  // prepare that resolvePath does not set ref.absolute etc:
  if (name._artifact)
    name = name._artifact;
  if (name.name)
    name = name.name;
  let compact = '';
  if (name.alias)
    compact = '.$alias.' + name.alias;
  if (name.action)
    compact = '.$action.' + name.action;
  if (name.param)
    compact += '.$param.' + name.param;
  if (name.element && !noElement)
    compact += (compact ? '.' : '..') + name.element;
  // Yes, omit $query.0 -> test is (name.query), not (name.query != null)
  return name.absolute + (name.query ? '.$query.' + name.query : '') + compact;
}

// TODO: create error tag function which automatically calls msgName() on args,
// or better: named message parameters and having a name-dependent toString()
// function
function msgName( ref, noElement ) {
  let name = (typeof ref === 'string') ? ref : refString( ref, noElement );
  return '"' + name.replace( /"/g, '""' ) + '"'; // sync ";
}

module.exports = {
  hasErrors,
  locationString,
  messageString,
  refString,
  getMessageFunction,
  msgName,
  handleMessages,
  sortMessages: (m => m.sort(compareMessage)),
  CompileMessage,
  CompilationError
}

