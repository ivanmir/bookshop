/**
 * This module is used to perform validation a CSN model.
 * It exposts a validation function which accepts two parameters:
 *  1. csn - model to validate;
 *  2. options - optional parameter which provides parameters to the external validation tool.
 * As result it returns an array of errors which is empty if successful.
 * The utilized external JSON schema tool is "ajv" located under the following links:
 *  - node module: https://www.npmjs.com/package/ajv
 *  - github repository: https://github.com/epoberezkin/ajv
 */

const fs = require("fs");
const Ajv = require("ajv");

const Messages = require("../../base/messages.js");
const removeComments = require("./removeComments.js");

let defaultOptions = {
  useDefaults: true,
  coerceTypes: false,
  extendRefs: "fail", // $ref is a single property,
  jsonPointers: true,
  verbose: true
}

class InvalidCSN extends Error {
  constructor(msg, location, severity = 'Error') {
    super(msg);
    //TODO improve location
    this.location = location;
    this.severity = severity;
  }
  toString() {
    return Messages.messageString(this);
  }
}

// requires a file as text
function readModuleTextFile(path) {
  var filename = require.resolve(path);
  return String(fs.readFileSync(filename, 'utf8'));
}

function validateCSN(csn, options) {
  let avjOptions = defaultOptions;
  if(options && options.ajv) {
    avjOptions = Object.assign({}, defaultOptions, options.ajv)
  }

  var ajv = new Ajv(avjOptions);

  let schemaFile = "./CSN.json";
  if(csn.version && csn.version.csn === "0.1.99" || options && options.newCsn)
    schemaFile = "./CSN2.json";

  let txt = readModuleTextFile(schemaFile);
  let json = removeComments(txt);
  let schema = JSON.parse(json);

  var validateFN = ajv.compile(schema);
  validateFN(csn); // returns true if valid

  // translate ajv errors to cdx errors
  // workaround: as some of the messages are repeated many times, so the duplicates will be removed
  let unique = [];
  let messages = csn.messages;
  let pointer = require('./jsonpoint.js')
  if(validateFN.errors !== null) {
    validateFN.errors.forEach(E => {

      let errorAsString = E.dataPath + " " + E.message;

      // extend the error message with some custom processing

      // no additional properties
      if(E.keyword === "additionalProperties" && E.params.additionalProperty) {
        errorAsString += ": " + E.params.additionalProperty;
      }

      // oneOf - attach the list of suggestions
      if(E.keyword === "oneOf" && E.schema) {
        let oneOf = E.schema.map(X => {
          if(X.$ref) { // schema reference
            let ipath = pointer.parse("/"+X.$ref);
            return ipath[ipath.length-1];
          }
          return X.required;
        })
        errorAsString += ": " + oneOf.join(", ");
      }

      // allowed values - attach the list of them
      if(E.params.allowedValues)
        errorAsString += ": " + E.params.allowedValues.join(", ");

      // const - append expected value
      if(E.parentSchema && E.parentSchema.const)
        errorAsString += ": " + E.parentSchema.const;

      // originator - all toplevel elements have "this"
      if(E.parentSchema && E.parentSchema.this)
        errorAsString += ", origin: " + E.parentSchema.this;

      if(!unique.includes(errorAsString)) {
        unique.push(errorAsString)
        let path = pointer.parse(E.dataPath);
        let location;
        let errorLocation;
        if(csn.locations) {
          try {
            location = csn.locations.getPathLocation(path);
            errorLocation = {
              filename: location.filename,
              start: location.start,
              end: location.stop
            };
          } catch (ex) {
            return;// skip messages for missing paths eg. default values for "kind"
          }
        } else {
          errorLocation = "unknown location";
        }
        messages.push(new InvalidCSN("Invalid CSN: "+errorAsString, errorLocation));
      }
    })
  }
  return messages;
}

module.exports = validateCSN;