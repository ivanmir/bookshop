grammar JSON;

@header {

  function getLoc(ctx,ret) {
    if(ctx.start) {
      ret.start = {
        offset:ctx.start.start,
        start: ctx.start.start,
        stop: ctx.start.stop,
        line: ctx.start.line,
        column: ctx.start.column + 1
      }
    }
    if(ctx.stop) {
      ret.stop = {
        offset: ctx.stop.stop+1,
        start: ctx.stop.start,
        stop: ctx.stop.stop,
        line: ctx.stop.line,
        column: ctx.stop.column + 1 + (ctx.stop.stop - ctx.stop.start) // end of last token
      }
    }
  } // getLoc

  function unquote(s) {
    return JSON.parse(s); // unquote for free
  }

}

json returns [ret={}]
   :
   obj[$ret]
   |
   array[$ret]
   ;

obj[ret]
@init {$ret.type="object"; $ret.value=Object.create(null); getLoc($ctx,$ret) }
@after{getLoc($ctx,$ret)}
   : '{' pair[$ret.value] (',' pair[$ret.value] )* '}'
   | '{' '}'
   ;

pair [ret] locals [$val={}]
@init {getLoc($ctx,$val)}
@after{getLoc($ctx,$val)}
   : STRING {} ':' value[$val] {$ret[unquote($STRING.text)]=$val}
;

array [ret] locals[$val]
@init {$ret.type="array"; $ret.value={}; getLoc($ctx,$ret); let ID=0;}
@after{getLoc($ctx,$ret)}
   : '['
        {$val={}} value[$val] {$ret.value[ID++]=$val}
        (',' {$val={}} value[$val] {$ret.value[ID++]=$val})*
      ']'
   | '[' ']'
   ;

value[ret]
@init {getLoc($ctx,$ret)}
@after{getLoc($ctx,$ret)}
   : STRING {$ret.type="string"; $ret.value=unquote($STRING.text);}
   | NUMBER {$ret.type="number"; $ret.value=unquote($NUMBER.text);}
   | obj[$ret]
   | array[$ret]
   | 'true' {$ret.type="boolean"; $ret.value=true;}
   | 'false' {$ret.type="boolean"; $ret.value=false;}
   | 'null' {$ret.type="null"; $ret.value=null;}
   ;

STRING
   : '"' (ESC | ~ ["\\])* '"'
   ;

fragment ESC
   : '\\' (["\\/bfnrt] | UNICODE)
   ;

fragment UNICODE
   : 'u' HEX HEX HEX HEX
   ;

fragment HEX
   : [0-9a-fA-F]
   ;

NUMBER
   : '-'? INT '.' [0-9] + EXP? | '-'? INT EXP | '-'? INT
   ;

fragment INT
   : '0' | [1-9] [0-9]*
   ;

fragment EXP
   : [Ee] [+\-]? INT
   ;

WHITESPACE
   : [ \t\n\r] + -> skip
   ;

MULTI_LINE_COMMENT
   : '/*' .*? '*/' -> skip
   ;

SINGLE_LINE_COMMENT
   : '//' ~[\r\n]* -> skip
   ;