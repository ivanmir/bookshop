let W = require("./walker");

function createInstance(model) {
  let U = require("./augmentor3utils.js")(model)
  return getTransformers(model,U);
}

function getTransformers(model,U) {

  function augmentNumber(val,path, which=U.WILO_FULL) {
    return {
      val,
      literal: "number",
      location: U.newLocation(path, which)
    }
  }

  function newValue(val, path, name, which=U.WILO_FULL) {
    if(val===undefined)
      return undefined;
    if(U.isAugmented(val))
      return undefined;
    let ret;
    let literal = typeof val; // TODO
    if(val===null) {
      ret = { literal: 'null', val };
    }
    else if(Array.isArray(val)) { // process array
      ret = { literal: 'array',
        val: val.map((V,I) => newValue( V, path.concat(''+I) ) )
      };
    }
    else if(literal !== "object") {  // number, string
      ret = { literal, val };
    }
    else if ('#' in val) {      // TODO: length / other property test?
      ret = { literal: 'enum', symbol: { id: val['#']} };
    }
    else if ('=' in val) {    // TODO: length / other property test?
      let location = U.newLocation(path);
      ret = { path: val['='].split('.').map( id => ({ id, location }) ) };
    }
    else {
      let struct = {};// TODO why not -> Object.create(null);
      ret = { literal: 'struct', struct };
      W.forEach(val, (K,V) => {
        struct[K] = newValue(V, path.concat(K), K);
      })
    }
    if(name) {
      ret.name = {id:name};
      U.setLocation(ret.name, path);
    }
    U.setLocation(ret, path, which);
    if(ret.symbol)
      U.setLocation(ret.symbol, path);
    U.setAugmented(ret)
    return ret;
  }

  function modifyGroupBy(node, name, path) {
    let X = node[name];
    X.forEach( (Y, iY) => augmentExpressionItem(Y, ""+iY, path.concat(name)))
  }

  function modifyCondition(node, name, path) {
    node.onCond = augmentXPR(node.on, path.concat(name));
    delete node["on"]
  }

  function modifyIncludes(node, name, path) {
    let value = node[name];
    let r = value.map( (X,iX) => {
      let location = U.newLocation(path.concat(name, iX), U.WILO_FULL)
      return {
        path: [ { id:X, location } ],
        location
      }
    })
    node[name] = r;
  }

  function modifyValue(node, name, path) {
    let value = newValue(node[name], path.concat(name))
    if(value!==undefined)
      node[name] = value;
  }

  function modifyBoolean(node, name, path) {
    let value = node[name];
    if(value !== undefined) {
      node[name]={val: value};
      U.setLocation(node[name], path.concat(name));
    }
  }

  function annotateExtensions(/*node, name, path*/) {
  }

  function ignore(/*node, name, path*/) {
  }

  function nonEmptyDict(/*node, name, path*/) {
  }

  function insertOrderDict(/*node, name, path*/) {
  }

  function arrayAsDict(node, name, path, xsnName=name) {
    let A = node[name]
    let R = Object.create(null);
    A.forEach((X,I) => {
      let ipath = path.concat([name,I]);
      let location = U.newLocation(ipath, U.WILO_FULL);
      let locationRef = U.newLocation(ipath.concat("ref"), U.WILO_FULL);
      let elementName = U.getLastElement(X.ref);
      let O = {
        kind:"key",
        targetElement: {
          path: X.ref.map((Y,J) => {
            let location = U.newLocation(ipath.concat(["ref",J]), U.WILO_FULL);
            return {id:Y,location};
          }),
          location:locationRef
        },
        location
      }
      //if "as" is present set it as "name" property
      if(X.as !== undefined) {
        elementName = X.as;
        O.name = {
          id:  X.as,
          location: U.newLocation(ipath.concat("as"), U.WILO_LAST)
        }
      }
      R[elementName] = O;
    })
    node[xsnName] = R;
    if (xsnName !== name)
      delete node[name];
  }

  function modifyKind(node) {
    if(node.kind === "view")
      node.kind = "entity";
  }

  function modifyNumber(node, name, path, newName = undefined) {
    if(U.isAugmented(node[name]))
      return;
    let value=node[name];
    if(newName!==undefined) {
      delete node[name]
      name = newName;
    }
    if(value !== undefined) {
      node[name]=augmentNumber(value, path.concat(name), U.WILO_LAST);
      U.setAugmented(node[name]);
    }
  }

  function cardinality(node, name, path) {
    let lpath = path.concat([name]);
    let cardinality= node.cardinality;
    if(cardinality) {
      U.setLocation(cardinality, lpath);
      if(cardinality.src !== undefined) {
        if(cardinality.src === "*")
          cardinality.sourceMax = newValue(cardinality.src, lpath.concat("src"), undefined, U.WILO_LAST);
        else
          modifyNumber(cardinality, "src", lpath, "sourceMax");
        delete cardinality["src"]
      }
      if(cardinality.min !== undefined) {
        if(cardinality.min === "*")
          cardinality.targetMin = newValue(cardinality.min, lpath.concat("min"), undefined, U.WILO_LAST);
        else
          modifyNumber(cardinality, "min", lpath, "targetMin");
        delete cardinality["min"]
      }
      if(cardinality.max !== undefined) {
        if(cardinality.max === "*")
          cardinality.targetMax = newValue(cardinality.max, lpath.concat("max"), undefined, U.WILO_LAST);
        else
          modifyNumber(cardinality, "max", lpath, "targetMax");
        delete cardinality["max"]
      }
    }
  }

  function standard(/*node, name, path*/) {
  }

  function augmentTypeRef(val,path) {
    let location = U.newLocation(path, U.WILO_LAST)
    let ids = [val];
    let newPath;
    if(typeof val == 'string') {
      ids = val.split(".");
      if(ids[0]==="cds") // cds.XYZ
        ids=[val]
      newPath = ids.map(id => {
        return {id, location};
      });
    } else if(val.ref) {
      newPath = refAsPath(val.ref, path.concat("ref"))
    } else
      throw Error ("Unexpected type reference '"+(typeof val)+"' under "+path.join("/"));
    let r = {
      path:newPath,
      location
    }
    if(val.ref) {
      let element = val.ref.slice(1);
      r.element = element.join(".");
    }
    return r;
  }

  function artifactRef(node, name, path) {
    node[name] = augmentTypeRef(node[name],path.concat(name));
  }

  function fromOld(/*node, name, path*/) {
  }

  function condition(/*node, name, path*/) {
  }

  function augmentLiteralValue(val, path) {
    let location = U.newLocation(path)
    let literal = typeof val;
    return {val, literal, location};
  }

  function refAsPath(ref, path) {
    let R = ref.map((id,I) => {
      let location = U.newLocation(path.concat(""+I))
      return {id,location}
    })
    return R;
  }

  function augmentExpressionItem(val, name, Path) {
    let path = Path.concat(name)
    let location = U.newLocation(path)
    if(val === null)
      return {val:null,location}
    let t = typeof val;
    if(t === "string") {
      return val;
    } else if(t === "boolean")
      return {val, literal: 'boolean', location};
    if(val.hasOwnProperty("ref")) {
      return {
        path: refAsPath(val.ref, path.concat("ref")), // TODO remove this later - here 'ref' is renamed to 'path'
        location};
    } else if(val.hasOwnProperty("literal")) {
      if(!val.hasOwnProperty("val"))
        throw Error("Literal without val property")
      val.location = U.newLocation(path);
      return val;
    } else if(val.hasOwnProperty("val")) {
      return augmentLiteralValue(val.val, path)
    } else if(val.hasOwnProperty("func")) {
      return {
        op:{val: "call", location},
        func: {path:[{id:val.func}]}, // to-csn.js has TODO XSN: remove op: 'call', func is no path
        args: augmentExpression(val.args,path.concat("args")),
        location
      }
    } else if(val.hasOwnProperty("#")) {
      return {
        literal:"enum", symbol:{id:val["#"],location},location
      }
    } else if(val.hasOwnProperty("SELECT")) {
      return query(val,undefined,path)
    }
    throw Error("augmentExpressionItem failed: "+JSON.stringify(val)+path.join("/"))
  }

  function modifyValueOrExpression(node, name, path) {
    let X = node[name]
    if(X.val)
      node[name] = augmentExpressionItem(X,"val",path.concat(name))
    else
      modifyExpression(node,name,path);
  }

  function modifyExpression(node, name, path) {
    let X = node[name];
    if(!Array.isArray(X)) {
      node[name] = augmentExpressionItem(X,name,path)
    } else {
      node[name] = augmentExpression(X, name, path);
    }
  }

  function augmentXPR(xpr, path) {
    if(xpr===undefined)
      return undefined;
    let location = U.newLocation(path, U.WILO_FULL)
    return {
      op: { val:"xpr", location },
      args: augmentExpression(xpr, path),
      location
    }
  }

  function augmentExpression(X,path) {
    if(!Array.isArray(X))
      throw Error("Expression should be an array");
    return X.map((Y,I) => augmentExpressionItem(Y, I, path))
  }

  function query(node, name, Path) {
    let path=Path;
    if(name!==undefined)
      path=Path.concat(name);
    let location = U.newLocation(path, U.WILO_FULL)
    let Q;
    if(name===undefined)
      Q=node;
    else
      Q = node[name];
    if(typeof Q !== "object")
      throw Error("Expects object as query");
    if(Q) {
      let SET = Q.SET;
      if(SET !== undefined) {
        if(SET.args.length>1) {
          SET.args.forEach( (X,I) => {
            query(SET.args,""+I, path.concat(["SET","args"]))
          })
          let R = {
            op: {val:"subquery", location},
            location,
            args:SET.args
          };
          delete SET.args;
          node[name] = R;
          U.setAugmented(R)
          if(name!==undefined)
            node[name] = R;
          return R;
        }
        Q=SET.args[0];
        path = path.concat(["SET","args","0"])
      }
    }
    let selectPath = path.concat("SELECT");
    let fromPath = selectPath.concat("from");
    let columnsPath = selectPath.concat("columns");
    let locationFrom = U.newLocation(fromPath, U.WILO_FULL)

    function augmentQuerySourceFrom(q) {
      let qo = q.SELECT;
      if(!qo)
        throw Error("Missing SELECT in query"+JSON.stringify(q)) //TODO move to validator
      if(!qo.from)
        throw Error("Missing FROM in SELECT") //TODO move to validator
      if(qo.from.SELECT) {
        query(qo,"from",path.concat("SELECT"));
        return [qo.from]
      }
      if(qo.from.join) {
        let args=qo.from.args.map(A => {
          let path = A.ref.map(R => {
            return {id:R,location}
          })
          return {path,name:{id:A.as},location}
        })
        let onPath = selectPath.concat(["from","on"]);
        let on = augmentXPR(qo.from.on, onPath)
        return [
          {
            op:{val:"join", location},
            join:"leftOuter",
            args,
            on
          }
        ]
      }
      if(!qo.from.ref)
        throw Error("Missing reference in SELECT.from: "+JSON.stringify(qo)) //TODO move to validator
      if(qo.from.ref) {
        let ref = qo.from.ref;
        let refPath = fromPath.concat("ref")
        let path = ref.map( (X,I) => {
          let R = {
            id:X,
            location:U.newLocation(refPath.concat(I), U.WILO_FULL)
          }
          if(X.id) R.id=X.id; //for filter select from E[a=2] -> ref:[{id:E,where...}]
          if(X.where) {
            R.where=augmentXPR(X.where,refPath.concat(I,"where"))
          }
          //TODO cardinality
          return R;
        })
        return [ {
          path,
          location: locationFrom
        }]
      }
      throw Error("Unknown query: "+JSON.stringify(q))
    }
    let newFrom = augmentQuerySourceFrom(Q);

    let all;
    let columns = Q.SELECT.columns;
    let elements = Object.create(null);
    if(columns!==undefined) {
      columns.forEach((C,iC) => {
        if(C.ref) {
          let refPath = columnsPath.concat([iC,"ref"])
          let elementNameId = U.getLastElement(C.ref)
          let elementNameLocation = U.newLocation(refPath, U.WILO_FULL);
          let path = C.ref.map((E,iE) => {
            return {
              id:E,
              location:U.newLocation(refPath.concat(iE), U.WILO_FULL)
            };
          })
          if(C.as) {
            elementNameId=C.as;
            elementNameLocation = U.newLocation(columnsPath.concat([iC,"as"]), U.WILO_FULL);
          }
          let elementName = {id: elementNameId, location: elementNameLocation};
          if(!C.as)
            elementName.$inferred="as";
          let E = {
            value: {path, location: elementNameLocation},
            name: elementName,
            kind: "element",
            location: elementNameLocation
          };
          elements[elementNameId] = E;
        }
      })

      if(Array.isArray(columns)) {
        let allIndex = columns.indexOf("*");
        if(allIndex!=-1)
          all = {
            val: true,
            location: U.newLocation(columnsPath.concat([allIndex]), U.WILO_FULL)
          };
      }
    }
    let from = Q.SELECT.from;
    let fromName;
    if(from.as) {
      fromName = {
        id:from.as,
        location: U.newLocation(fromPath.concat("as"), U.WILO_FULL)
      }
    }

    let where = augmentXPR(Q.SELECT.where, selectPath.concat("where"))

    let mixin = Q.SELECT.mixin;

    let orderBy = Q.SELECT.orderBy;
    if(orderBy !== undefined) {
      let orderByPath = selectPath.concat("orderBy");
      orderBy = orderBy.map((X,iX) => {
        let sort;
        let nulls;
        if(X.sort) {
          sort = {
            val: X.sort,
            location: U.newLocation(orderByPath.concat(iX,"sort"), U.WILO_FULL)
          }
        }
        if(X.nulls) {
          nulls = {
            val: X.nulls,
            location: U.newLocation(orderByPath.concat(iX,"nulls"), U.WILO_FULL)
          }
        }
        let value;
        if(X.xpr) {
          value = augmentXPR(X.xpr, orderByPath.concat(iX,"xpr"));
        } else {
          value = {
            path:X.ref.map((Y,iY) => {
              return {
                id:Y,
                location: U.newLocation(orderByPath.concat(iX,"ref",iY), U.WILO_FULL)
              }
            }),
            location: U.newLocation(orderByPath.concat(iX), U.WILO_FULL)
          }
        }
        let r = {value};
        if(sort)
          r.sort = sort;
        if(nulls)
          r.nulls = nulls;
        return r;
      });
    }

    let limitOffset = Q.SELECT.limit;
    let limit,offset;
    if(limitOffset !== undefined) {
      let limitPath = selectPath.concat("limit");
      if(limitOffset.rows)
        limit = augmentNumber(limitOffset.rows.val, limitPath.concat("rows","val"), U.WILO_LAST);
      if(limitOffset.offset)
        offset = augmentNumber(limitOffset.offset.val, limitPath.concat("offset","val"), U.WILO_LAST);
    }

    let excluding = Q.SELECT.excluding
    if(excluding != undefined) {
      let r = Object.create(null);
      excluding.forEach((X,iX) => {
        let location = U.newLocation(selectPath.concat("excluding",iX));
        r[X] = {
          name: {id:X,location},
          location
        }
      })
      excluding = r;
    }
    let R = {
      op: {val:"query", location},
      location,
      elements,
      from:newFrom
    };
    if(Q.as) { // query alias
      let location = U.newLocation(path.concat("as"), U.WILO_FULL)
      R.name = {id:node[name].as, location}
    }
    if(columns === undefined)
      R.all = { val: 'implicit', location }
    if (fromName)
      R.from[0].name = fromName;
    // set optional properties
    if(all)
      R.all=all;
    if(where)
      R.where=where;
    if(mixin) {
      R.mixin=mixin;
      Object.setPrototypeOf(mixin,null)
    }
    if(orderBy)
      R.orderBy=orderBy;
    if(limit)
      R.limit=limit;
    if(offset)
      R.offset=offset;
    if(excluding)
      R.exclude = excluding;
    U.setAugmented(R)
    if(name!==undefined)
      node[name] = R;
    return R;
  }

  function modifyAnnotation(node, key, path) {
    node[key] = newAnnotation(key, node[key], path);

    function newAnnotation(anAnno, aValue, path) {
      if (aValue instanceof Object && 'literal' in aValue)
        throw new Error('strange re-run')
      let ret = {};
      if(aValue!==true && aValue!==undefined)
        ret = newValue(aValue, path.concat(anAnno));
      ret.name = { location: U.newLocation(path.concat(anAnno), U.WILO_FIRST) };
      return ret;
    }

  }

  return {
    newValue,
    ///////
    '@': modifyAnnotation,
    '$': ignore,
    $inferred: a => a && true,
    annotationAssignments: ignore, // TODO: make it $annotations
    artifacts: ignore,             // almost just $artifacts
    blocks: ignore,                // TODO: make it $blocks
    indexNo: ignore,               // TODO XSN: remove
    queries: ignore,               // TODO: make it $queries
    location: ignore,
    // future ------------------------------------------------------------------
    extensions: annotateExtensions,           // TODO: list non-applied
    quoted: ignore,               // really?  What about CURRENT_DATE vs "CURRENT_DATE"?
    // members -----------------------------------------------------------------
    actions: nonEmptyDict,
    elements: insertOrderDict,
    enum: insertOrderDict,
    keys: (node, name, path) => arrayAsDict(node, name, path, 'foreignKeys'),
    mixin: insertOrderDict,       // only in queries with special handling
    params: insertOrderDict,
    // different XSN later -----------------------------------------------------
    calculated: ignore,            // later in name: $inferred: 'as'
    implicitForeignKeys: ignore,   // later in assoc: $inferred: { foreignKeys: 'fk' } or $inferred on each fk
    origin: ignore,                // remove (introduce non-enum _origin link)
    projection: ignore,            // later in entity: $syntax: 'projection'
    source: ignore,                // remove
    viaAll: ignore,                // later in elem: $inferred: '*'
    // general properties of constructs ----------------------------------------
    abstract: modifyBoolean,
    localized: modifyBoolean,
    dbType: modifyValue,                // TODO: currently with --hana-flavor only
    default: modifyValueOrExpression,
    impl: ignore,               // obsolete - remove
    key: modifyBoolean,
    kind: modifyKind,
    name: ignore,
    virtual: modifyValue,
    notNull: modifyValue,
    masked: modifyValue,
    returns: standard,            // storing the return type of actions
    // type properties ---------------------------------------------------------
    cardinality,
    includes: modifyIncludes, // also entities
    length: modifyValue,
    on: modifyCondition,
    onCond : ignore,
    precision: modifyValue,
    redirected: ignore,           // TODO: no need for this
    scale: modifyValue,
    target: artifactRef,
    type: artifactRef,
    items: standard,
    // inner properties which should not occur anymore -------------------------
    path: ignore,
    sourceMax: ignore,
    targetMin: ignore,//modifyValue,
    targetMax: ignore,//modifyValue,
    targetElement: ignore,        // special display of foreign key
    // queries -----------------------------------------------------------------
    from: fromOld,
    all: ignore,                  // should not occur
    exclude: (excl, csn) => { csn.excluding = Object.keys(excl); }, // XSN TODO: exclude->excluding
    groupBy: modifyGroupBy,
    having: condition,
    limit: ignore,                // TODO XSN: include offset
    offset: ignore,             // TODO XSN: move into `limit`
    orderBy: ignore, // TODO XSN: make `sort` and `nulls` sibling properties
    query,
    value: ignore,             // do not list for select items as elements
    where: condition,
    // special HANA CDS featues ------------------------------------------------
    sequenceOptions: ignore,    // TODO: currently not in the JSON by HANA
    // direct exports
    modifyNumber,
  }
}

module.exports = createInstance;
