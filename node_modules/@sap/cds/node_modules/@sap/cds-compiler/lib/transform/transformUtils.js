'use strict';

// A "tools" collection of various transformation functions that might be helpful for
// different backends.

const { setProp, cloneWithTransformations, forEachDefinition, forEachGeneric,
        forEachMemberRecursively }  = require('../base/model');
const { addStringAnnotationTo, printableName,
        copyAnnotations, isStructuredElement, hasBoolAnnotation } = require('../model/modelUtils');
const alerts = require('../base/alerts');

// Return the public functions of this module, with 'model' captured in a closure (for options etc).
// Use 'pathDelimiter' for flattened names (e.g. of struct elements or foreign key elements).
function getTransformers(model, pathDelimiter) {
  const { error, signal } = alerts(model);
  let options = model.options;

  return {
    flattenForeignKeys,
    createForeignKeyElement,
    checkForeignKeys,
    flattenStructuredElement,
    flattenStructStepsInPath,
    preprocessAction,
    setServiceProperty,
    checkExposedAssoc,
    toFinalBaseType,
    addImplicitRedirections,
    isBacklinkAssociation,
    isBacklinkComparison,
    collectAllSimpleExpressions,
    createExposingProjection,
    createAndAddDraftAdminDataProjection,
    createScalarElement,
    createAssociationElement,
    createAssociationPathComparison,
    addElement,
    copyAndAddElement,
    createAction,
    addAction,
  };

  // For a dictionary `foreignKeys` of foreign key infos, return a dictionary in flattened form, i.e.
  // replace all foreign keys that are managed associations themselves by their respective foreign keys,
  // recursively, with names flattened using '_' between path components.
  function flattenForeignKeys(foreignKeys) {
    // (TNT only): Use <assoc><key> instead of <assoc>_key>
    let fkSeparator = (options.tntFlavor && !options.tntFlavor.skipGeneratedFKsWithout_) ? '' : pathDelimiter;

    let result = Object.create(null);
    for (let name in foreignKeys) {
      let foreignKey = foreignKeys[name];
      // Sanity checks
      if (!foreignKey.targetElement) {
        throw Error('Expecting foreign key ' + printableName(foreignKey) + ' to have targetElement');
      }
      if (!foreignKey.name.absolute || !foreignKey.name.element) {
        throw Error('Expecting foreign key ' + printableName(foreignKey) + ' to have absolute name and element name');
      }
      let fkArtifact = foreignKey.targetElement._artifact;
      if (!fkArtifact) {
        throw Error('Expecting foreign key ' + printableName(foreignKey) + ' to be resolved');
      }
      if (fkArtifact.target) {
        // Foreign key is itself a managed association: Replace by its target foreign keys
        // (In other words, use the target's generated foreign key fields as foreign keys)
        let targetForeignKeys = flattenForeignKeys(fkArtifact.foreignKeys);
        for (let targetForeignKeyName in targetForeignKeys) {
          let targetForeignKey = targetForeignKeys[targetForeignKeyName];
          let targetGeneratedForeignKeyFieldName = name + fkSeparator + targetForeignKeyName;
          let resultForeignKey = {
            name: {
              id: targetGeneratedForeignKeyFieldName,
              absolute: foreignKey.name.absolute,
              element: name + '.' + targetGeneratedForeignKeyFieldName,
              viaTransform: true
            },
            kind: 'key',
            targetElement: { path: [ { id: targetGeneratedForeignKeyFieldName } ] },
          };
          setProp(resultForeignKey, '_parent', foreignKey._parent);
          setProp(resultForeignKey, '_main', foreignKey._main);
          // FIXME: _artifact should actually point to the generated target foreign key element here (and not
          // (to the corresponding target foreign key itself), but because we generate foreign key elements
          // iteratively, not recursively, we cannot rely on generated foreign key elements in other entities
          // to exist yet. But doing it like this will be quite sufficient as a workaround, because target
          // foreign key and generated target foreign key element have all properties that we might inspect
          // on _artifact in common (type, annotations, ... we only ever inspect them in order to copy them,
          // after all)
          setProp(resultForeignKey.targetElement, '_artifact', targetForeignKey.targetElement._artifact);
          result[name + fkSeparator + targetForeignKeyName] = resultForeignKey;
        }
      } else if (isStructuredElement(fkArtifact)) {
        // Foreign key is structured: Replace by its flattened elements (which unfortunately might not exist yet,
        // because we do the flattening iteratively and the artifact containing the structured key might not have been
        // processed yet. As above, we use the actual key elements as a standin for _artifact)
        let flatKeyElements = flattenStructuredElement(fkArtifact);
        for (let flatElemName in flatKeyElements) {
          let flatElem = flatKeyElements[flatElemName];
          let resultForeignKey = {
            name: {
              id: flatElemName,
              absolute: foreignKey.name.absolute,
              element: flatElemName,
              viaTransform: true
            },
            kind: 'key',
            targetElement: { path: [ { id: flatElemName } ] },
          };
          setProp(resultForeignKey, '_parent', foreignKey._parent);
          setProp(resultForeignKey, '_main', foreignKey._main);
          setProp(resultForeignKey.targetElement, '_artifact', flatElem);
          result[flatElemName] = resultForeignKey;
        }
      } else {
        // Otherwise simply take as it is
        result[name] = foreignKey;
      }
    }
    return result;
  }

  // Create an artificial foreign key element for association 'assoc' (possibly part
  // of nested struct, i.e. containing dots), using foreign key info from 'foreignKey',
  // inserting it into 'elements' of the assoc's main artifact. Add a property
  // 'generatedFieldName' to the corresponding 'foreignKey' of the assoc.
  // Return the newly generated foreign key element.
  function createForeignKeyElement(assoc, foreignKey) {
    let fkArtifact = foreignKey.targetElement._artifact;
    // Sanity checks
    if (!fkArtifact) {
      throw Error('Expecting foreign key for ' + printableName(assoc) + ' to be resolved');
    }
    if (!assoc.name.absolute || !assoc.name.element) {
      throw Error('Expecting association ' + printableName(assoc) + ' to have absolute name and element name');
    }
    if (assoc._main == undefined) {
      throw Error('Expecting association ' + printableName(assoc) + ' to have a main artifact');
    }
    if (fkArtifact.target) {
      throw Error('Not expecting foreign key of association ' + printableName(assoc) + ' to be an association after flattening')
    }
    if (fkArtifact.type == undefined) {
      throw Error('Expecting artifact of foreign key for ' + printableName(assoc) + ' to have a type');
    }

    // (TNT only): Use <assoc><key> instead of <assoc>_key>
    let fkSeparator = (options.tntFlavor && !options.tntFlavor.skipGeneratedFKsWithout_) ? '' : pathDelimiter;

    // Assemble foreign key element name from assoc name, '_' and foreign key name/alias
    let foreignKeyElementName = assoc.name.element.replace(/\./g, pathDelimiter) + fkSeparator + foreignKey.name.id;
    // Assemble artificial foreign key element
    let foreignKeyElement = {
      name:  {
        id: foreignKeyElementName,
        absolute: assoc.name.absolute,
        element: foreignKeyElementName,
        viaTransform: true
      },
      kind: 'element',
      type: {
        path: [ { id: fkArtifact.type.absolute } ],
        absolute: fkArtifact.type.absolute, // TODO: enough?
      },
    };
    // Transfer selected type properties from target key element
    // FIXME: There is currently no other way but to treat the annotation '@odata.Type' as a type property.
    for (let prop of ['length', 'scale', 'precision', 'default', '@odata.Type']) {
      if (fkArtifact[prop]) {
        foreignKeyElement[prop] = fkArtifact[prop];
      }
    }
    setProp(foreignKeyElement.type, '_artifact', fkArtifact.type._artifact);
    setProp(foreignKeyElement.type.path[0], '_artifact', fkArtifact.type._artifact);
    // If the association is non-fkArtifact resp. key, so should be the foreign key field
    for (let prop of ['notNull', 'key']) {
      if (assoc[prop]) {
        foreignKeyElement[prop] = Object.assign({}, assoc[prop]);
      }
    }

    // If the association was a projection or view element (i.e. it has a 'value'), construct a
    // corresponding 'value' for the generated foreign key element
    // FIXME: Can't resolve the corresponding _artifact links because they might not yet be created.
    // We currently live without them.
    if (assoc.value) {
      let valueForeignKeyElementName = assoc.value.element.replace(/\./g, pathDelimiter) + fkSeparator + foreignKey.name.id;
      // For the foreign key element, take the same path as for the assoc, just without the last step
      let valueForeignKeyElementPath = [];
      if (assoc.value.path) {
        valueForeignKeyElementPath = cloneWithTransformations(assoc.value.path, {}).slice(0, -1);
        // Take over _artifact links from original path, because flattenStructStepsInPath requires them
        for (let i = 0; i < valueForeignKeyElementPath.length; i++) {
          valueForeignKeyElementPath[i]._artifact = assoc.value.path[i]._artifact;
        }
      }
      valueForeignKeyElementPath.push({ id: valueForeignKeyElementName });
      foreignKeyElement.value = {
        path: valueForeignKeyElementPath,
        absolute: assoc.value.absolute,
        element: valueForeignKeyElementName,
        viaTransform: true, // FIXME: Do we still need this?
      }
      // FIXME: Remove once the compactor no longer renders 'origin'
      if (assoc.origin) {
        foreignKeyElement.origin = foreignKeyElement.value;
      }
      // The foreign key element name is calculated if the assoc hasn't been renamed
      if (assoc.name.element == assoc.value.element) {
        foreignKeyElement.name.calculated = true;
      }
    }

    // Insert artificial element into assoc's main artifact, with all cross-links (must not exist already)
    let artifact = assoc._main;
    if (artifact.elements[foreignKeyElementName]) {
      signal(error`Generated foreign key element "${foreignKeyElementName}" for association "${assoc.name.absolute}.${assoc.name.element}" conflicts with existing element`, assoc.location);
    }
    artifact.elements[foreignKeyElementName] = foreignKeyElement;
    setProp(foreignKeyElement, '_parent', artifact);
    setProp(foreignKeyElement, '_main', artifact);
    setProp(foreignKeyElement, '_finalType', fkArtifact._finalType);

    // Establish the relationship between generated field and association:
    // - foreign key info has 'generatedFieldName'
    // - generated field has annotation '@odata.foreignKey4'.
    foreignKey.generatedFieldName = foreignKeyElementName;
    addStringAnnotationTo('@odata.foreignKey4', assoc.name.element, foreignKeyElement);
    return foreignKeyElement;
  }

  // For an association 'assoc', check that all foreign keys (if any) actually exist in the
  // target. Must only be applied after flattening structured foreign keys.
  // Note that this may also be called for unmanaged associations with artificially created
  // ON-conditions, because these still retain their foreign key info.
  // FIXME: For all cases except implicit redirection, this should actually be done by the compiler
  function checkForeignKeys(assoc) {
    // FIXME: Because this assumes flattening, it does not work with 'hdbcds' naming mode. Because
    // it will become obsolete soon anyway (compiler checking and rewriting ON-conditions), we
    // don't bother to adapt it.
    if (options.forHana && options.forHana.keepStructsAssocs) {
      return;
    }

    for (let name in assoc.foreignKeys) {
      let foreignKey = assoc.foreignKeys[name]
      // Sanity checks
      if (foreignKey.targetElement.path.length > 1) {
        throw Error('Expecting foreign key ' + + printableName(foreignKey) + ' to be flattened');
      }
      if (!assoc.target._artifact) {
        throw Error('Expecting target of association ' + printableName(assoc) + ' to be resolved');
      }
      if (!assoc.target._artifact.elements) {
        throw Error('Expecting target of association ' + printableName(assoc) + ' to have elements');
      }
      // Try to "resolve" the corresponding element
      let targetElement = assoc.target._artifact.elements[foreignKey.targetElement.path[0].id];
      if (targetElement == undefined) {
        if (assoc.redirected) {
          signal(error`Foreign key "${foreignKey.targetElement.path[0].id}" not found in redirected target "${assoc.target._artifact.name.absolute}" of association "${assoc.name.absolute}.${assoc.name.element}"`, assoc.location);
        } else {
          signal(error`Foreign key "${foreignKey.targetElement.path[0].id}" not found in target "${assoc.target._artifact.name.absolute}" of association "${assoc.name.absolute}.${assoc.name.element}"`, assoc.location);
        }
      }
    }
  }

  // For a structured element 'elem', return a dictionary of flattened elements to
  // replace it, flattening names with '_' and propagating all annotations and the
  // type properties 'key', 'notNull', 'virtual', 'masked' to the flattened elements.
  function flattenStructuredElement(elem) {
    // Sanity check
    if (!isStructuredElement(elem)) {
      throw new Error('Expecting element ' + printableName(elem) + ' to be a structured element');
    }
    // Collect all child elements (recursively) into 'result'
    let result = Object.create(null);
    for (let childName in elem._finalType.elements) {
      let childElem = elem._finalType.elements[childName];
      if (isStructuredElement(childElem)) {
        // Descend recursively into structured children
        let grandChildElems = flattenStructuredElement(childElem);
        for (let grandChildName in grandChildElems) {
          let flatElemName = elem.name.id + pathDelimiter + grandChildName;
          let flatElem = grandChildElems[grandChildName];
          result[flatElemName] = flatElem;
          // If the original element had a value, construct one for the flattened element
          if (elem.value) {
            createFlattenedValue(flatElem, flatElemName, grandChildName);
          }
          // Preserve the generated element name as it would have been with 'hdbcds' names
          setProp(flatElem, '_flatElementNameWithDots', elem.name.id + '.' + grandChildName);
          result[flatElemName] = flatElem;
        }
      } else {
        // Primitive child - clone it and restore its cross references
        let flatElemName = elem.name.id + pathDelimiter + childName;
        let flatElem = cloneWithTransformations(childElem, {});
        flatElem.viaTransform = true; // FIXME: This name is not ideal but used elsewhere, too)
        setProp(flatElem, '_finalType', childElem._finalType);
        setProp(flatElem, '_main', elem._main);
        setProp(flatElem, '_parent', elem._parent);
        if (childElem.foreignKeys) {
          for (let foreignKeyName in childElem.foreignKeys) {
            if (childElem.foreignKeys[foreignKeyName].targetElement._artifact) {
              setProp(flatElem.foreignKeys[foreignKeyName].targetElement, '_artifact', childElem.foreignKeys[foreignKeyName].targetElement._artifact);
            }
          }
        }
        if (childElem.type) {
          flatElem.type = childElem.type;
        }
        if (childElem.target) {
          flatElem.target = childElem.target;
        }
        // FIXME: We just lost all _artifact links in the ON-condition by the cloning above,
        // so we rather take the original ON-condition here
        if (childElem.onCond) {
          flatElem.onCond = childElem.onCond;
        }
        // If the original element had a value, construct one for the flattened element
        if (elem.value) {
          createFlattenedValue(flatElem, flatElemName, childName);
        }
        // Preserve the generated element name as it would have been with 'hdbcds' names
        setProp(flatElem, '_flatElementNameWithDots', elem.name.id + '.' + childName);
        result[flatElemName] = flatElem;
      }
    }
    // Fix all collected flat elements (names, annotations, properties, origin ..)
    for (let name in result) {
      // Adapt names within the element
      let flatElem = result[name];
      flatElem.name.id = name;
      flatElem.name.element = name;
      if (elem.name.calculated) {
        flatElem.name.calculated = true;
      }
      // Copy annotations from struct (not overwriting, because deep annotations should have precedence)
      copyAnnotations(elem, flatElem, false);
      // Copy selected type properties
      for (let p of ['key', 'notNull', 'virtual', 'masked', 'viaAll']) {
        if (elem[p]) {
          flatElem[p] = elem[p];
        }
      }
    }
    return result;

    // Create a flattened 'value' for flattened element 'flatElem' with full name 'flatElemName',
    // appending 'lastPathStep' to the original elem's value path
    function createFlattenedValue(flatElem, flatElemName, lastPathStep) {
      flatElem.value = {
        absolute : elem.value.absolute,
        element : flatElemName,
        viaTransform: true,
      }
      // Just extend 'elem's path by one step, leaving all IDs as they are (will be fixed later by flattenStructStepsInPath)
      if (elem.value.path) {
        flatElem.value.path = cloneWithTransformations(elem.value.path, {});
        // Take over _artifact links from original path, because flattenStructStepsInPath requires them
        for (let i = 0; i < elem.value.path.length; i++) {
          flatElem.value.path[i]._artifact = elem.value.path[i]._artifact;
        }
      }
      flatElem.value.path.push({ id : lastPathStep });
      // FIXME: Cannot restore value._artifact here because it might not exist yet (projection
      // might be processed before entity). We currently live without it.
      // FIXME: Remove once the compactor no longer renders 'origin'
      flatElem.origin = flatElem.value;
    }
  }

  // Return a copy of 'path' where all path steps resulting from struct traversal are
  // fused together into one step, using '_' (so that the path fits again for flattened
  // structs), e.g. 
  //   [ (Entity), (struct1), (struct2), (assoc), (elem) ] should result in
  //   [ (Entity), (struct1_struct2_assoc), (elem) ]
  // FIXME: The resulting path steps have slightly crooked _artifact (for each artificially
  // created flattened element, the path step's _artifact points to the original
  // (primitive) struct member it was generated for.
  function flattenStructStepsInPath(path) {
    let result = [];
    let stack = []; // IDs of path steps not yet processed or part of a struct traversal
    for (let pathStep of path) {
      stack.push(pathStep.id);
      // Current stack makes a new result step if next path step is not a struct traversal
      if (!pathStep._artifact || !isStructuredElement(pathStep._artifact)) {
        let resultStep = Object.assign({}, pathStep, { id : stack.join(pathDelimiter) });
        if (pathStep._artifact) {
          setProp(resultStep, '_artifact', pathStep._artifact);
        }
        result.push(resultStep);
        stack = [];
      }
    }
    // Process remaining stack if not empty
    if (stack.length > 0) {
      let pathStep = path[path.length - 1];
      let resultStep = Object.assign({}, pathStep, { id : stack.join(pathDelimiter) });
      if (pathStep._artifact) {
        setProp(resultStep, '_artifact', pathStep._artifact);
      }
      result.push(resultStep);
    }
    // The path might start with an element that is part of a struct (i.e. enclosing the path owner).
    // This hasn't been handled above simply because the struct is not part of the path.
    // FIXME: Find a simpler solution for this ... really ugly
    if (path[0]._artifact && path[0]._artifact.name.element && path[0]._artifact.name.element.indexOf('.') != -1) {
      result[0].id = path[0]._artifact.name.element.replace(/\./g, pathDelimiter);
    }
    return result;
  }

  // Takes an augmented action/function object and checks if a defined type is used in the declaration, 
  // if yes, then checks if it is from the same service as the action/function
  // used for OData and Swagger transformation
  function preprocessAction(action) {
    // A bound action has a parent - the corresponding entity
    // An unbound action does not have a parent, but a '_service'
    let actionBlock = action._parent ? action._parent._service : action._service;
    // an action can return a builtin, a defined type, an entity, an array of one of the first three or an inline structured type
    // if the action has a return declaration
    // and the returned artifact is not a builtin - check if it is from the current service
    if (action.returns) {
      let returnedTypes = action.returns.elements ?
        Object.keys(action.returns.elements).map(e => action.returns.elements[e].type) :
        action.returns.items
          ? [action.returns.items.type]
          : [action.returns.type];
      returnedTypes.forEach(returnType => {
        if (!returnType.absolute.startsWith('cds.')) {
          let returnTypeBlock = obtainTypesService(returnType);
          if (returnTypeBlock !== actionBlock)
            signal(error`The defined return type ${returnType._artifact.name.absolute} of action ${action.name.absolute}${action.name.action ? '.' + action.name.action : ''} is not from the current service ${actionBlock.name.absolute}`, action.location);
        }
      });
    }

    // if the action has parameters and a paremeter is not a builtin - check if the used type is from the current service
    if (action.params) {
      for (let p in action.params) {
        let param = action.params[p];
        if (param.type.absolute.startsWith('cds.'))
          continue;
        let paramTypeBlock = obtainTypesService(param.type);
        // this can happens if the special magic for @extends is used
        // ugly tnt magic -> to be removed
        if (!actionBlock && paramTypeBlock === 'not in a service') {
          if (/* actionBlock */ action.name.absolute.split('.').slice(0, -1).join('.') !== /* paramTypeBlock */ param.type.absolute.split('.').slice(0, -1).join('.'))
            signal(error`The type ${param.type._artifact.name.absolute} of parameter ${param.name.absolute}.${param.name.id} in action ${action.name.absolute}${action.name.action ? '.' + action.name.action : ''} is not from the current service`, param.location);
        } else if (paramTypeBlock !== actionBlock)
          signal(error`The type ${param.type._artifact.name.absolute} of parameter ${param.name.absolute}.${param.name.id} in action ${action.name.absolute}${action.name.action ? '.' + action.name.action : ''} is not from the current service ${actionBlock && actionBlock.name.absolute}`, param.location);
      }
    }

    // Returns the service where the type is declared or 'not in a service' if the type is outside of such.
    // Covers also the case when an element of defined type is used, for specifying a type.
    function obtainTypesService(type) {
      if (type._artifact._service)
        return type._artifact._service;
      if (type._artifact.kind === 'element' && type._artifact._main._service)
        return type._artifact._main._service;
      else
        return 'not in a service';
    }
  }

  // Takes a model and looks for services inside it.
  // When a non-abstract service is found - adds an attribute '_service' to all artifacts that are exposed
  // in a service (pointing to the service artifact).
  function setServiceProperty(model) {
    forEachDefinition(model, artifact => {
      // If this is a non-abstract service, let all its (recursive) artifacts know
      if (artifact.kind == 'service' && !artifact.abstract) {
        setService(artifact, artifact);
      }
      // Set '_service' for 'artifact' and its sub-artifacts to 'service'.
      function setService(artifact, service) {
        // Services must not be nested
        if (artifact.kind == 'service' && artifact._service != undefined) {
          signal(error`Services cannot be nested: Service "${artifact.name.absolute}" is nested within service "${artifact._service.name.absolute}"`, artifact.location);
        }
        // Contexts cannot be defined within services
        if (artifact.kind == 'context') {
          signal(error`Contexts cannot be defined within services: Context "${artifact.name.absolute}" is defined within service "${service.name.absolute}"`, artifact.location);
        }
        setProp(artifact, '_service', service);
        forEachGeneric(artifact, 'artifacts', subartifact => setService(subartifact, service));
      }
    });
  }

  // Check that exposed associations do not point to non-exposed targets
  function checkExposedAssoc(artifact, association) {
    if (association.target && association.target._artifact && association.target._artifact._service != artifact._service)
      signal(error`Association "${artifact.name.absolute}.${association.name.id}" must be redirected: Target "${association.target.absolute}" is not exposed by service "${artifact._service.name.absolute}"`, association.location);
  }

  // Replace the type of 'node' with its final base type, collecting all annotations on the way
  // (from least to most derived, i.e. giving precedence to those higher in the type chain).
  function toFinalBaseType(node) {
    // Nothing to do if no type (or if array/struct type)
    if (!node || !node.type || node.type._artifact && node.type._artifact.builtin) {
      return;
    }
    // Sanity check
    if (node.type._artifact === undefined) {
      throw Error('Expecting type of ' + printableName(node) + ' to be resolved');
    }
    // Start the chain with the node's type (add in front of type chain, so that most derived one is last)
    let typeChain = [node.type._artifact];
    // Unravel until finding primitive type or type constructor
    while (typeChain[0].type && !typeChain[0].builtin) {
      // Sanity check
      if (typeChain[0].type._artifact === undefined) {
        throw Error('Expecting type of ' + printableName(typeChain[0]) + ' to be resolved');
      }
      typeChain.unshift(typeChain[0].type._artifact);
    }
    // Take the front of the chain as final base type (but keep the location as it was)
    node.type = {
      path: [ { id: typeChain[0].name.absolute } ],
      absolute: typeChain[0].name.absolute,
      location: node.type.location,
      viaTransform: true,
    };
    setProp(node.type, '_artifact', typeChain[0]);
    // Sanity checks
    if (node._finalType && node._finalType.type && node._finalType.type.absolute != node.type.absolute) {
      throw Error('Expecting _finalType ' + node._finalType.type.absolute + ' to equal result of toFinalBaseType: ' + node.type.absolute);
    }
    // Propagate type parameters and all annotations upwards the chain (from chain[1] onwards, i.e. from least to most derived)
    for (let typeDef of typeChain.slice(1)) {
      // Propagate type parameters
      for (let prop of ['length', 'precision', 'scale', 'enum', 'target', 'foreignKeys']) {
        if (typeDef[prop] != undefined) {
          node[prop] = typeDef[prop];
        }
      }
      // Propagate annotations (not overwriting because most derived comes last and should win)
      copyAnnotations(typeDef, node, false);
    }
  }

  // Examine augmented 'model' for exposed associations/compositions having a non-exposed
  // target, and supply appropriate implicit redirections in-place.
  // Expects model to already have '_service' entries as provided by the first step of 'transform4oData'.
  // Report errors in 'model.messages'.
  function addImplicitRedirections(model) {
    // Create a backward exposure mapping for implicit re-targeting of association targets
    let exposedByProjection = createExposedByMapping(model);

    // Walk all artifacts of the model
    forEachDefinition(model, (artifact, artifactName) => {
      // Only affects exposed artifacts
      if (!artifact._service) {
        return;
      }
      // Perform implicit re-targeting of association elements based on exposure:
      forEachMemberRecursively(artifact, (member, memberName) => {
        // If this is an association or composition element that is not explicitly redirected,
        // and its target is not exposed in the same service as this artifact
        if (member.kind == 'element' && member.target && !member.redirected
            && member.target._artifact && member.target._artifact._service != artifact._service) {
          // If no candidate for implicit redirection can be found so far, and if requested by annotation: auto-expose the target
          let implicitlyRedirected = (exposedByProjection[member.target.absolute] || []).filter(p => p._service == artifact._service);
          if (implicitlyRedirected.length == 0 && hasBoolAnnotation(member.target._artifact, '@cds.autoexpose')) {
            let projectionId = member.target._artifact.name.absolute.replace(/\./g, '_').replace(/::/g, '__');
            let projection = createExposingProjection(member.target._artifact, projectionId, artifact._service, member.location, 'auto-exposure');
            if (projection) {
              // Take the just-created projection as the (only!) projection exposing the target in this service
              exposedByProjection[member.target.absolute] = (exposedByProjection[member.target.absolute] || []).filter(p => p._service != artifact._service);
              exposedByProjection[member.target.absolute].push(projection);
              // console.log(`Auto-exposing target ${member.target.absolute} of association ${artifactName}.${memberName} as ${projection.name.absolute}`);            }
            }
          }
          // Attempt implicit redirection
          redirectAssociationImplicitly(member, memberName, artifact, artifactName);
        }
        // FIXME: Should we also rewrite '@Common.ValueList.entity' annotations based on auto-exposure? If so, how?
        // (not clear whether they have a path or a string as value, and how to resolve the name - TNT seems to have service-local
      });
    });

    // Redirect element 'assoc' with name 'assocName' in 'artifact' with name 'artifactName' implicitly
    // by modifying its target and adding a 'redirected' property. Complain if not unique or not exposed
    // in this service.
    function redirectAssociationImplicitly(assoc, assocName, artifact, artifactName) {
      // Only consider exposures in the same service for implicit redirection
      let implicitlyRedirected = (exposedByProjection[assoc.target.absolute] || []).filter(p => p._service == artifact._service);
      // Complain if no implicit redirection or if not unique
      if (implicitlyRedirected.length == 0) {
        signal(error`Association "${artifactName}.${assocName}" cannot be implicitly redirected: Target "${assoc.target.absolute}" is not exposed in service "${artifact._service.name.absolute}" by any projection`, assoc.location);
        return;
      } else if (implicitlyRedirected.length > 1) {
        signal(error`Association "${artifactName}.${assocName}" cannot be implicitly redirected: Target "${assoc.target.absolute}" is exposed in service "${artifact._service.name.absolute}" by multiple projections: ${implicitlyRedirected.map(p => '"' + p.name.absolute + '"').join(', ')}`, assoc.location);
        return;
      }
      // Perform implicit redirection
      assoc.redirected = { val: true };
      assoc.target = {
        absolute: implicitlyRedirected[0].name.absolute,
        path: [ { id : implicitlyRedirected[0].name.absolute } ],
      };
      setProp(assoc.target, '_artifact', implicitlyRedirected[0]);
      setProp(assoc.target.path[0], '_artifact', implicitlyRedirected[0]);
    }
  }

  // Create an "exposed by" artifact name -> [artifact, ...] mapping in augmented 'model'
  // with the following semantics:
  // For each exposed projection P or view V that exposes an otherwise not-exposed "source"
  // S (where "source" means the single artifact in the projection's or view's simple
  // FROM-clause), we add a mapping from the non-exposed source artifact to the exposed
  // projection artifact, i.e. exposedByMapping(S) == [P] resp. [V].
  // Even more magically, we also add mappings for each 'include' of S or P resp. V, i.e.
  // an entity or projection/view also exposes everything it resp. its source inherits from,
  // transitively.
  // For convenience, the mapping keeps all values of P/V in an array (even if there is only
  // one P/V).
  // Returns a dictionary with mappings from names to artifact arrays.
  function createExposedByMapping(model) {
    let result = Object.create(null);
    // For all artifacts, if they are exposed, consider their query source and includes for implicit exposure
    forEachDefinition(model, artifact => {
      if (artifact._service) {
        addToResult(artifact, artifact);
      }
    });

    // Consider 'exposedArtifact', its simple query source (if any) and its includes (if any) as
    // something that is implicitly exposed by 'artifactInService'. Do not take artifacts that
    // are part of a service itself.
    // Add a mapping of name => [artifact]
    function addToResult(exposedArtifact, artifactInService) {
      // A projection or view with a single query and a single, simple source also exposes the source
      if (exposedArtifact.queries && exposedArtifact.queries.length == 1) {
        let from = exposedArtifact.queries[0].from;
        // Sanity check
        if (!from[0].absolute) {
          throw new Error(`Unresolved query source in ${exposedArtifact.name.absolute}`);
        }
        let sourceArtifact = model.definitions[from[0].absolute];
        // Sanity check
        if (!sourceArtifact) {
          throw new Error(`Non-existing query source ${from[0].absolute} in ${exposedArtifact.name.absolute}`);
        }
        addToResult(sourceArtifact, artifactInService);
      }
      // An artifact also exposes everything it includes, transitively
      if (exposedArtifact.includes != undefined) {
        for (let includedArtifact of exposedArtifact.includes.map(include => include._artifact)) {
          addToResult(includedArtifact, artifactInService);
        }
      }
      // Ignore if exposed artifact is part of a service by itself
      if (exposedArtifact._service) {
        return;
      }
      // Always keep right hand side as an array (more convenient if multiple services are involved)
      if (result[exposedArtifact.name.absolute]) {
        // Only add if not yet there
        if (result[exposedArtifact.name.absolute].every(entry => entry.name.absolute != artifactInService.name.absolute)) {
          result[exposedArtifact.name.absolute].push(artifactInService);
        }
      } else {
        result[exposedArtifact.name.absolute] = [artifactInService];
      }
      // console.error('Use ' + artifactInService.name.absolute + ' as replacement for ' + exposedArtifact.name.absolute);
    }
    return result;
  }

  // Return a full projection 'projectionId' of artifact 'art' for exposure in 'service', where the name of the projection
  // is the fully qualified name of 'art', replacing '.' and '::' by '_' resp. '__'.
  // Complain on location 'loc' mentioning 'reason' if such an artifact (other than the autogenerated one) already exists
  function createExposingProjection(art, projectionId, service, loc, reason) {
    let projectionAbsoluteName = service.name.absolute + '.' + projectionId
    // If there already is an artifact with this name, this is either the second attempt or a conflict
    let existingProjection = service.artifacts[projectionId];
    if (existingProjection) {
      if (existingProjection.$generatedByAutoExposure) {
        // Already auto-exposed
        return existingProjection;
      }
      signal(error`Cannot generate projection "${projectionId}" for ${reason} because of name conflict with existing artifact "${service.name.absolute}.$projectionId}"`, loc);
      return null;
    }
    // Create elements matching the artifact's elements
    let elements = Object.create(null);
    for (let elemName in art.elements) {
      let artElem = art.elements[elemName];
      let elem = Object.assign({}, artElem);
      elem.name = Object.assign({}, artElem.name, { calculated: true });
      elem.name.absolute = projectionAbsoluteName;
      elem.value = {
        id : elemName,
        absolute: projectionAbsoluteName,
        element: elemName,
        path: [ { id : art.name.id }, { id : elemName } ]
      }
      setProp(elem.value, '_artifact', artElem);
      // Transfer the original element's final type, unless it was the original element itself (then it becomes the new element itself)
      if (artElem._finalType) {
        setProp(elem, '_finalType', (artElem._finalType == artElem) ? elem : artElem._finalType);
      }
      // FIXME: Remove once the compactor no longer renders 'origin'
      elem.origin = elem.value;
      elem.viaAll = true;
      elements[elemName] = elem;
    }
    // Source is the original artifact
    let source = {
      path: art.name.path,
      name: {
        calculated: true,
        id : art.name.id,
      },
      absolute: art.name.absolute,
    };
    setProp(source, '_artifact', art);
    // Add an artifact link for the last path step (for some reason, the original path does not seem to have it)
    if (!source.path[source.path.length - 1]._artifact) {
      setProp(source.path[source.path.length - 1], '_artifact', art);
    }
    let query = {
      op: { val: 'query', location: loc },
      from: [ source ],
      all: { val: true },
      elements,
      kind: 'query',
    };
    // Assemble the projection itself and add it into the model
    let projection = {
      name: {
        id: projectionId,
        absolute: projectionAbsoluteName
      },
      kind: 'entity',
      query: query,
      projection: {},
      $from: [ source ],
      queries: [ query ],
      source: source,
      elements: query.elements,
      $generatedByAutoExposure: true,
    };
    setProp(projection, '_service', service);
    // Sanity check: Can't already be there (checked above)
    if (model.definitions[projectionAbsoluteName]) {
      throw new Error('Duplicate projection: ' + projectionAbsoluteName);
    }
    model.definitions[projectionAbsoluteName] = projection;
    service.artifacts[projectionId] = projection;
    return projection;
  }

  // Return true if 'assoc' is a backlink association, false if it is not
  function isBacklinkAssociation(assoc, currentArt) {
    if (!assoc.onCond) // managed assoc
      return false;
    let expressions = collectAllSimpleExpressions(assoc.onCond);
    if (expressions.some(expr => isBacklinkComparison(expr, currentArt, assoc)))
      return true;
    return false;
  }

  // For an expression 'expr' checks if it fulfills the conditions the association to be a backlink one
  // and returns true or false respectively
  // The result is false when one of the following is violated:
  // 1. The comparison must be '='
  // 2. Not self part of the expression must be a path
  // 3. Only one operand must be $self
  // 4. Self part must have only '$self', but not '$self.a.b...'
  // 5. Not self path must have at least two steps
  // 6. Not self path must end with an association
  // 7. Not self path must contain two associations
  // 8. The first one from point 7 must be the current association element
  // 9. The second association from point 7 must point back to the current entity
  // 10. The second association from point 7 must not be a backlink assocation
  function isBacklinkComparison(expr, currentArt, currentElem) {
    // 1. comparison must be '='
    if (expr.op.val !== '=')
      return false;
    // 2. operand must be a path
    // in augmented csn '$self' is also a path
    if (expr.args.some(a => !a.path))
      return false;
    if (expr.args.some(a => a.path && a.path[0].id === '$self')) {
      let selfSide = expr.args.find(a => a.path && a.path[0].id === '$self');
      let notSelf = expr.args.find(a => a.path && a.path[0].id !== '$self');
      // 3. only one operand can be '$self'
      if (expr.args.every(a => a.path && a.path[0].id === '$self'))
        return false;
      // 4. operand must be '$self', but not '$self.a.b...'
      if (selfSide.path.length > 1)
        return false;
      // 5. path must have at least two steps
      if (notSelf.path.length < 2)
        return false;
      // 6. <notself> path must end with an association
      if (notSelf.path.slice(-1)[0]._artifact.type.absolute !== 'cds.Association')
        return false;
      let notSelfAssocs = notSelf.path.filter(p => p._artifact.type && p._artifact.type.absolute === 'cds.Association')
      // 7. <notself> path must contain two associations
      if (notSelfAssocs.length !== 2)
        return false;
      // 8. the first one must be the current association element
      if (notSelfAssocs[0]._artifact.name.absolute !== currentElem.name.absolute
        && notSelfAssocs[0]._artifact.name.element !== currentElem.name.element
        && notSelfAssocs[0]._artifact.target !== currentElem.target)
        return false;
      // 9. the second association must point back
      if (currentArt.source ?
        (notSelfAssocs[1]._artifact.target._artifact.name.absolute !== currentArt.source._artifact.name.absolute
          && notSelfAssocs[1]._artifact.target._artifact.name.id !== currentArt.source._artifact.name.id)
        :
        (notSelfAssocs[1]._artifact.target._artifact.name.absolute !== currentArt.name.absolute
          && notSelfAssocs[1]._artifact.target._artifact.name.id !== currentArt.name.id)
      )
        return false;
      // 10. the second association must not be a backlink assocaition
      if (isBacklinkAssociation(notSelfAssocs[1], currentArt))
        return false;
      return true;
    }
    return false;
  }

  // For a condition 'onCond', collect all sub-conditions (recursively) into the array 'simpleConditions'
  // that have at least one path argument
  // FIXME: Rename this to better describe what it does (And couldn't that simply be done by looking for 
  // '=' comparisons where left and right are a path, recursively?)
  function collectAllSimpleExpressions(cond) {
    let simpleExpressions = [];
    if (cond instanceof Array) // on condition in parentheses
      return collectAllSimpleExpressions(cond[0]);
    else if (!cond.args) // on condition with function
      return simpleExpressions;
    if (cond.args.some(a => {
      return a.path ? true : false;
    }))
      simpleExpressions.push(cond); // if some of the arguments has path-> put it into the array for check afterwards if it is a backling assoc
    cond.args.filter(a => {
      return !a.path; // if some of the sides of 'cond' may contain a condition itself -> go into it recursively
    }).forEach(a => {
      simpleExpressions.push(...collectAllSimpleExpressions(a));
    })
    return simpleExpressions;
  }

  // Create a 'DraftAdministrativeData' projection on 'DRAFT.DraftAdministrativeData' in service 'service'
  // and add it to the model.
  function createAndAddDraftAdminDataProjection(service) {
    // Make sure we have a DRAFT.DraftAdministrativeData entity
    let draftAdminDataEntity = model.definitions['DRAFT.DraftAdministrativeData'];
    if (!draftAdminDataEntity) {
      draftAdminDataEntity = createAndAddDraftAdminDataEntity();
      model.definitions['DRAFT.DraftAdministrativeData'] = draftAdminDataEntity;
    }
    // Barf if it is not an entity or not what we expect
    if (draftAdminDataEntity.kind != 'entity' || !draftAdminDataEntity.elements['DraftUUID']) {
      signal(error`Generated entity "DRAFT.DraftAdministrativeData" conflicts with existing artifact`, draftAdminDataEntity.location);
    }

    // Create a projection within this service
    return createExposingProjection(draftAdminDataEntity, 'DraftAdministrativeData', service, service.location, '"@odata.draft.enabled"');

    // Create the namespace 'DRAFT' and the 'DRAFT.DraftAdministrativeData' entity (unless they already exist)
    // and add them to the model.
    // Return the 'DRAFT.DraftAdministrativeData' entity.
    function createAndAddDraftAdminDataEntity() {
      // Make sure we have a DRAFT namespace
      let draftNamespace = model.definitions['DRAFT'];
      if (!draftNamespace) {
        draftNamespace = createAndAddDraftNamespace();
      }
      // Barf if it is not a namespace
      if (draftNamespace.kind != 'namespace') {
        signal(error`Generated namespace "DRAFT" conflicts with existing artifact`, draftNamespace.location);
      }

      // Create the 'DRAFT.DraftAdministrativeData' entity
      let artifact = {
        name: {
          path: [
            { id: 'DRAFT' },
            { id: 'DraftAdministrativeData' },
          ],
          id: 'DraftAdministrativeData',
          absolute: 'DRAFT.DraftAdministrativeData',
        },
        kind: 'entity',
        elements: Object.create(null),
      }
      setProp(artifact.name.path[0], '_artifact', draftNamespace);
      setProp(artifact, '_finalType', artifact);

      // key DraftUUID : UUID
      let draftUuid = createScalarElement('DraftUUID', 'cds.UUID', true, undefined);
      addElement(draftUuid, artifact);

      // CreationDateTime : Timestamp;
      let creationDateTime = createScalarElement('CreationDateTime', 'cds.Timestamp', false, undefined);
      addElement(creationDateTime, artifact);

      // CreatedByUser : String(256);
      let createdByUser = createScalarElement('CreatedByUser', 'cds.String', false,undefined);
      createdByUser.length = { literal: 'number', val: 256 };
      addElement(createdByUser, artifact);

      // DraftIsCreatedByMe : Boolean;
      let draftIsCreatedByMe = createScalarElement('DraftIsCreatedByMe', 'cds.Boolean', false, undefined);
      addElement(draftIsCreatedByMe, artifact);

      // LastChangeDateTime : Timestamp;
      let lastChangeDateTime = createScalarElement('LastChangeDateTime', 'cds.Timestamp', false, undefined);
      addElement(lastChangeDateTime, artifact);

      // LastChangedByUser : String(256);
      let lastChangedByUser = createScalarElement('LastChangedByUser', 'cds.String', false, undefined);
      lastChangedByUser.length = { literal: 'number', val: 256 };
      addElement(lastChangedByUser, artifact);

      // InProcessByUser : String(256);
      let inProcessByUser = createScalarElement('InProcessByUser', 'cds.String', false, undefined);
      inProcessByUser.length = { literal: 'number', val: 256 };
      addElement(inProcessByUser, artifact);

      // DraftIsProcessedByMe : Boolean;
      let draftIsProcessedByMe = createScalarElement('DraftIsProcessedByMe', 'cds.Boolean', false, undefined);
      addElement(draftIsProcessedByMe, artifact);

      // Add to the namespace
      draftNamespace.artifacts[artifact.name.id] = artifact;
      return artifact;
    }

    // Create the namespace 'DRAFT' and add it to the model.
    function createAndAddDraftNamespace() {
      let draftNamespace = {
        name: {
          path: [
            { id: 'DRAFT' },
          ],
          id: 'DRAFT',
          absolute: 'DRAFT',
        },
        kind: 'namespace',
        artifacts: Object.create(null),
      }
      model.definitions['DRAFT'] = draftNamespace;
      return draftNamespace;
    }
  }

  // Create an artificial scalar element 'elemName' with final type 'typeName'.
  // Make the element a key element if 'isKey' is true.
  // Add a default value 'defaultVal' if supplied
  function createScalarElement(elemName, typeName, isKey, defaultVal) {
    let type = model.definitions[typeName];
    if (!type) {
      throw new Error('Expecting valid type name: ' + typeName);
    }
    let elem = {
      name: {
        id : elemName,
        element: elemName,
      },
      kind: 'element',
      type: {
        path: [
          { id: typeName }
        ],
        absolute: typeName,
      },
    };
    setProp(elem.type, '_artifact', type);
    setProp(elem, '_finalType', type);
    if (isKey) {
      elem.key = {
        val: true,
      }
    }
    if (defaultVal !== undefined) {
      elem.default = {
        literal: 'boolean',
        val: defaultVal,
      }
    }
    return elem;
  }

  // Create an articial element 'elemName' of type 'cds.Association',
  // having association target 'target'. If 'isManaged' is true, take all keys
  // of 'target' as foreign keys.
  function createAssociationElement(elemName, target, isManaged) {
    let elem = createScalarElement(elemName, 'cds.Association', false, undefined);
    elem.target = {
      path: [
        { id: target.name.absolute }
      ],
      absolute: target.name.absolute,
    };
    setProp(elem.target, '_artifact', target);
    setProp(elem.target.path[0], '_artifact', target);
    if (isManaged) {
      elem.foreignKeys = Object.create(null);
      for (let keyElemName in target.elements) {
        let keyElem = target.elements[keyElemName];
        if (!keyElem.key) {
          continue;
        }
        let foreignKey = {
          name: {
            id: keyElemName,
            $inferred: 'keys',
            element: elemName + '.' + keyElemName,
          },
          kind: 'key',
          targetElement: {
            path : [
              { id: keyElemName }
            ],
          },
          calculated: true,
          $inferred: 'keys',
        }
        setProp(foreignKey.targetElement, '_artifact', keyElem);
        setProp(foreignKey, '_parent', elem);
        setProp(foreignKey, '_finalType', keyElem._finalType);
        elem.foreignKeys[keyElemName] = foreignKey;
        elem.implicitForeignKeys = true;
      }
    }
    return elem;
  }

  // Create a comparison operation <assoc>.<foreignElem> <op> <elem>.
  function createAssociationPathComparison(assoc, foreignElem, op, elem) {
    let result = {
      op: {
        val: op,
      },
      args: [
        {
          path: [
            { id: assoc.name.id },
            { id: foreignElem.name.id }
          ],
          absolute: foreignElem.name.absolute,
          element: foreignElem.name.id,
        },
        {
          path: [
            { id: elem.name.id }
          ],
          absolute: elem.name.absolute,
          element: elem.name.id,
        }
      ],
    }
    setProp(result.args[0].path[0], '_artifact', assoc);
    setProp(result.args[0].path[1], '_artifact', foreignElem);
    setProp(result.args[0], '_artifact', foreignElem);
    setProp(result.args[1].path[0], '_artifact', elem);
    setProp(result.args[1], '_artifact', elem);
    return result;
  }

  // Add element 'elem' to 'artifact'
  function addElement(elem, artifact) {
    // Sanity check
    if (!artifact.elements) {
      throw new Error('Expecting artifact with elements: ' + JSON.stringify(artifact));
    }
    // Element must not exist
    if (artifact.elements[elem.name.id]) {
      signal(error`"${artifact.name.absolute}.${elem.name.id}": Generated element name conflicts with existing element`, artifact.elements[elem.name.id].location);
      return;
    }
    // Add the element
    artifact.elements[elem.name.id] = elem;
    elem.name.absolute = artifact.name.absolute;
    setProp(elem, '_main', artifact);
    setProp(elem, '_parent', artifact);
    for (let keyName in elem.foreignKeys || {}) {
      elem.foreignKeys[keyName].name.absolute = artifact.name.absolute;
      setProp(elem.foreignKeys[keyName], '_main', artifact);
    }
  }

  // Make a copy of element 'elem' and add it to 'artifact' under the new name 'elemName'.
  // Return the newly created element
  function copyAndAddElement(elem, artifact, elemName) {
    // Sanity check
    if (elem.name.element.includes('.')) {
      // FIXME: Have to figure that out later
      throw new Error('Expected non-structured element');
    }
    if (!artifact.elements) {
      throw new Error('Expected structured artifact');
    }
    // Must not already have such an element
    if (artifact.elements[elemName]) {
      signal(error`"${artifact.name.absolute}.${elemName}": Generated element name conflicts with existing element`, artifact.elements[elemName].location);
    }
    let result = {
      name: {
        id : elemName,
        absolute: artifact.name.absolute,
        element: elemName,
      },
      kind: 'element',
    };
    // FIXME: For now, simply shallow-copy all these properties
    for (let prop of ['type', 'key', 'notNull', 'length', 'precision', 'scale', 'localized', 'target', 'onCond', 'foreignKeys', 'location']) {
      if (elem[prop]) {
        result[prop] = elem[prop];
      }
    }
    setProp(result, '_parent', artifact);
    setProp(result, '_main', artifact);
    setProp(result, '_finalType', elem._finalType == elem ? result : elem._finalType);
    artifact.elements[elemName] = result;
    return result;
  }

  // Create an artificial action 'actionName' with return type artifact 'returnType' optionally with one parameter 'paramName'
  // of type name 'paramTypeName'
  function createAction(actionName, returnType, paramName = undefined, paramTypeName = undefined) {
    // Assemble the action
    let action = {
      name: {
        id: actionName,
        action: actionName,
      },
      kind: 'action',
      returns: {
        type: {
          path: [
            { id: returnType.name.id }
          ],
          absolute: paramTypeName,
        },
      }
    };
    setProp(action.returns.type.path[0], '_artifact', returnType);
    setProp(action.returns.type, '_artifact', returnType);
    setProp(action.returns, '_outer', action);
    setProp(action.returns, '_finalType', returnType);

    // Add parameter if provided
    if (paramName && paramTypeName) {
      let paramType = model.definitions[paramTypeName];
      if (!paramType) {
        throw new Error('Expecting valid parameter type name: ' + paramTypeName);
      }
      action.params = Object.create(null);
      action.params[paramName] = {
        name: {
          id: paramName,
          param: paramName,
          action: actionName,
        },
        kind: 'param',
        type: {
          path: [
            { id: paramTypeName }
          ],
          absolute: paramTypeName,
        },
      }
      setProp(action.params[paramName].type.path[0], '_artifact', paramType);
      setProp(action.params[paramName].type, '_artifact', paramType);
    }

    return action;
  }

  // Add action 'action' to 'artifact'
  function addAction(action, artifact) {
    if (!artifact.actions) {
      artifact.actions = Object.create(null);
    }
    // Element must not exist
    if (artifact.actions[action.name.id]) {
      signal(error`"${artifact.name.absolute}.${action.name.id}": Generated action name conflicts with existing action: `, artifact.actions[action.name.id].location);
      return;
    }
    // Add the action
    artifact.actions[action.name.id] = action;
    action.name.absolute = artifact.name.absolute;
    setProp(action, '_main', artifact);
    setProp(action, '_parent', artifact);
    for (let paramName in action.params || {}) {
      action.params[paramName].name.absolute = artifact.name.absolute;
      setProp(action.params[paramName], '_main', artifact);
    }
  }

}

module.exports = {
  // This function retrieves the actual exports
  getTransformers,
};
