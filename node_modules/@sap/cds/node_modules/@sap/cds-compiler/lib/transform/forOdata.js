'use strict';

const { forEachDefinition, forEachMemberRecursively, setProp } = require('../base/model');
const { compactSorted, compact } = require('../json/compactor');
const deepCopy = require('../base/deepCopy');
const { CompilationError, hasErrors, sortMessages } = require('../base/messages');
const { isManagedAssociationElement, isStructuredElement, isAssociation, isElementWithType,
        renameAnnotation, addBoolAnnotationTo, addStringAnnotationTo, copyAnnotations,
        foreachPath, hasBoolAnnotation, getElementDatabaseNameOf, getArtifactDatabaseNameOf } = require('../model/modelUtils');
const transformUtils = require('./transformUtils');
const { mergeOptions } = require('../model/modelUtils');
const alerts = require('../base/alerts');

// Transformation for ODATA. Expects an augmented 'inputModel', processes it for ODATA.
// The result should be suitable for consumption by EDMX processors (annotations and metadata)
// and also as a final CSN output for the ODATA runtime (when compacted).
// Performs the following transformations:
// - Flatten structured elements (and foreign keys of managed associations pointing to
//   keys that are themselves managed associations).
// - Generate foreign key fields for entities with managed associations (annotated with
//   '@odata.foreignKey4'). Propagate along projections accordingly. Names are built using
//   <assoc>_<key>, conflicts are checked. 
// - Complete the 'foreignKeys' property for all managed associations, so that there
//   is always a 'generatedFieldName' for the corresponding generated foreign key field.
// - Implicitly redirect associations based on exposure
// - Check that exposed associations do not point to non-exposed targets
// - Add an attribute '_service' to all artifacts that are exposed in a service (pointing to
//   the service artifact). This should be used by EDMX processors to detect exposed artifacts.
// - Unravel derived type chains, propagating annotations upwards.
// - Rename annotations according to a fixed list of short-hands
// Returns an (augmented) copy of 'inputModel' with the transformation applied. Does not change the original inputModel.
// Throws a CompilationError on errors. Warnings are stored in the result model.
function transform4odata(inputModel, options) {
  const { error, warning, signal } = alerts(inputModel);
  let model = deepCopy(inputModel);
  model.messages = inputModel.messages;
  options = mergeOptions(inputModel.options, options);
  model.options = options;
  const { flattenForeignKeys, createForeignKeyElement, checkForeignKeys,
          flattenStructuredElement, flattenStructStepsInPath, preprocessAction,
          setServiceProperty, checkExposedAssoc, toFinalBaseType,
          addImplicitRedirections, createAndAddDraftAdminDataProjection,
          createScalarElement, createAssociationElement, createAssociationPathComparison, addElement,
          createAction, addAction } = transformUtils.getTransformers(model, '_');
  // First walk through the model: perform preparations only
  // Set '_service' property for all artifacts and sub-artifacts, for each service in the model
  setServiceProperty(model);

  // Second walk through the model: Do the main part of the work
  forEachDefinition(model, (artifact) => {
    // For entities and views only
    if (artifact.kind == 'entity' || artifact.kind == 'view') {
      // Flatten structs (might result in new elements)
      for (let elemName in artifact.elements) {
        let elem = artifact.elements[elemName];
        if (isStructuredElement(elem)) {
          // Remove the structured element, replace it by its flattened form
          delete artifact.elements[elemName];
          let flatElems = flattenStructuredElement(elem);
          for (let flatElemName in flatElems) {
            if (artifact.elements[flatElemName]) {
              signal(error`"${artifact.name.absolute}.${elemName}": Flattened struct element name conflicts with existing element: "${flatElemName}"`, elem.location);
            }
            artifact.elements[flatElemName] = flatElems[flatElemName];
             // FIXME: Should also adapt indexNo of the newly added elements and all subsequent ones
          }
        }
        if (!isElementWithType(elem)) {
          signal(error`Element "${artifact.name.absolute}.${elemName}" does not have a type: Elements of ODATA entities must have a type`, elem.location);
        }
      }
      // Generate artificial draft fields if requested
      if (hasBoolAnnotation(artifact, '@odata.draft.enabled')) {
        generateDraftForOdata(artifact);
      }
    }
    // Types must not have anonymous structured elements
    else if (artifact.kind == 'type') {
      for (let elemName in artifact.elements) {
        let elem = artifact.elements[elemName];
        if (elem.elements) {
          signal(error`Element "${artifact.name.absolute}.${elemName}" has an anonymous structured type: this is not (yet) supported for ODATA`, artifact.location);
        }
      }
    }
    forEachMemberRecursively(artifact, (member) => {
      // Unravel derived type chains for elements, actions, action parameters (propagating annotations)
      toFinalBaseType(member);
      toFinalBaseType(member.items);
      toFinalBaseType(member.returns);
      // Resolve annotation shorthands for elements, actions, action parameters
      renameShorthandAnnotations(member);
      // check annotations
      checkAnnotations(member);
      // Generate foreign key elements for managed associations
      if (isManagedAssociationElement(member)) {
        // Flatten foreign keys (replacing foreign keys that are managed associations by their respective foreign keys)
        member.foreignKeys = flattenForeignKeys(member.foreignKeys);
        // Generate foreign key elements
        for (let name in member.foreignKeys) {
          let foreignKeyElement = createForeignKeyElement(member, member.foreignKeys[name]);
          toFinalBaseType(foreignKeyElement);
          // Propagate the association's annotations to the foreign key element
          // (Overwriting because they should win over the derived type unraveling)
          copyAnnotations(member, foreignKeyElement, true);
        }
        // If the managed association is NOT NULL, we give it a target min cardinality of 1
        // if it didn't already have an explicitly specified min cardinality.
        // (No need to check again for min <= max cardinality, because max has already been checked to be > 0)
        if (member.notNull) {
          if (!member.cardinality) {
            member.cardinality = {};
          }
          if (!member.cardinality.targetMin) {
            member.cardinality.targetMin = {
              literal: 'number',
              val: 1,
            }
          }
        }
      }

      // Entities only: Flatten structs used in paths
      if (artifact.kind == 'entity') {
        foreachPath(member, (path, pathOwner) => {
          pathOwner.path = flattenStructStepsInPath(path);
        });
      }
    });
    // Unravel derived type chains for types and annotations (propagating annotations)
    if (artifact.kind != 'entity') {
      toFinalBaseType(artifact);
      toFinalBaseType(artifact.items);
    }
    // If the artifact is a derived structured type, unravel that as well
    if (artifact.kind == 'type' && artifact.type && artifact.type._artifact.elements) {
      // Take the final type's elements
      // FIXME: Actually, we should deep-copy here and adapt _parent, _main, name , ...
      artifact.elements = artifact.type._artifact.elements;
      // The artifact's type is now 'cds.struct', which is not shown
      delete artifact.type;
    }
    // Resolve annotation shorthands for entities, types, annotations, ...
    renameShorthandAnnotations(artifact);
    // check annotations
    checkAnnotations(artifact);
  });

  // Perform implicit redirection of non-exposed association targets
  addImplicitRedirections(model);

  // Third walk through the model: Now all artificially generated things are in place
  forEachDefinition(model, artifact => {
    if (artifact.kind == 'entity' || artifact.kind == 'view') {
      for (let elemName in artifact.elements) {
        let elem = artifact.elements[elemName];
        // Check for valid foreign keys
        if (isAssociation(elem.type)) {
          checkForeignKeys(elem);
        }

        // Perform checks and add attributes for "contained" sub-entities:
        // - A container is recognized by having an association annotated with '@odata.contained'.
        // - All targets of such associations ("containees") are marked with a property 
        //   '_containerEntity: []', having as value an array of container names (i.e. of entities
        //   that have a '@odata.contained' association pointing to the containee). Note that this
        //   may be multiple entities, possibly including the container itself.
        // - All associations in the containee pointing back to the container are marked with
        //   a boolean property '_isToContainerEntity : true', except if the association itself
        //   has the annotation '@odata.contained' (indicating the top-down link in a hierarchy).
        // - All associations in the containee pointing back to the container must have a specific
        //   setting for 'NOT NULL': Required if container and containee are different entities
        //   (header/item scenario), not allowed if they are identical (hierarchy scenario).
        //   FIXME: This currently requires that only managed associations can point from containee
        //   back to container in the header/item scenario, because CDS syntax does not allow 'NOT NULL'
        //   for unmanaged associations). If unmanaged associations are also wanted, we would have to
        //   omit this check for them.
        if (hasBoolAnnotation(elem, '@odata.contained') && elem.target) {
          // Retrieve the containee artifact
          let containedArtifact = elem.target._artifact;
          // Sanity check
          if (!containedArtifact) {
            throw new Error('Expected target artifact of @odata.contained assoc to be resolved: ' + JSON.stringify(elem));
          }
          // Let the containee know its container (array because their may be more than one)
          if (!containedArtifact._containerEntity) {
            containedArtifact._containerEntity = [];
          }
          // add container only once
          if (containedArtifact._containerEntity.includes(artifact.name.absolute)) {
            signal(error`"${containedArtifact.name.absolute}": Entity is already recursively contained`, artifact.location);
            continue;
          }
          containedArtifact._containerEntity.push(artifact.name.absolute);
          // Mark associations in the containee pointing to the container (i.e. to this entity)
          for (let containedElemName in containedArtifact.elements) {
            let containedElem = containedArtifact.elements[containedElemName];
            if (isAssociation(containedElem.type)) {
              // Sanity check
              if (!containedElem.target || !containedElem.target._artifact) {
                throw new Error('Expected target artifact of assoc in container to be resolved: ' + JSON.stringify(containedElem));
              }
              // If this is an association that points to a container (but is not by itself contained,
              // which would indicate the top role in a hierarchy) mark it with '_isToContainer'
              if (containedElem.target._artifact.name.absolute == artifact.name.absolute
                  && !hasBoolAnnotation(containedElem, '@odata.contained')) {
                containedElem._isToContainer = true;
                // If this is really a header/item relationship (i.e. two different entities involved), the
                // association to the container must be NOT NULL
                if (containedArtifact.name.absolute != artifact.name.absolute) {
                  // FIXME: See above: We could also omit the check for unmanaged assocs
                  // if (!containedElem.onCond && !containedElem.notNull)
                  if (!containedElem.notNull) {
                    signal(error`"${containedArtifact.name.absolute}.${containedElemName}": Association to container entity must have "NOT NULL`, containedElem.location);
                  }
                }
                // Otherwise (recursive hierarchy relationship, only one entity involved), it must not be NOT NULL
                else {
                  if (containedElem.notNull) {
                    signal(error`"${containedArtifact.name.absolute}.${containedElemName}": Association to container entity in a recursive hierarchy must not have "NOT NULL`, containedElem.location);
                  }
                }
              }
            }
          }
        }

        // Remove '$projection' from paths in the element's ON-condition
        // FIXME: Hack - should actually be done by the compiler, and should only
        // affect the element itself, not the various other places sharing the same
        // ON-condition object, e.g. the MIXIN and the query (there, the ON-condition
        // should actually retain its '$projection').
        foreachPath(elem.onCond || {}, (path, node) => {
          if (path[0].id == '$projection') {
            node.path = node.path.slice(1);
          }
        });
      }
    }
    forEachMemberRecursively(artifact, member => {
      // Check that exposed associations do not point to non-exposed targets
      if (artifact._service && isAssociation(member.type)) {
        checkExposedAssoc(artifact, member);
      }
    });

    // Preprocess bound actions/functions
    if (artifact.kind === 'entity' && artifact.actions && artifact._service) {
      Object.keys(artifact.actions).forEach(actName => preprocessAction(artifact.actions[actName]));
    }

    // Preprocess unbound actions/function
    if ((artifact.kind === 'action' || artifact.kind === 'function') && artifact._service) {
      preprocessAction(artifact);
    }
  });

  // Fourth walk through the model: Check media type and key-ness (requires that containers have been
  // identified in pass 3), annotate DB names
  var illV2Prefix = RegExp('^(_|[0-9])');
  forEachDefinition(model, artifact => {
    // Annotate artifacts, elements, foreign keys, parameters etc with their DB names if requested
    if (options.toOdata.names) {
      // Skip artifacts that have no DB equivalent anyway
      if (!['service', 'context', 'namespace', 'annotation', 'action', 'function'].includes(artifact.kind)) {
        addStringAnnotationTo('@cds.persistence.name', getArtifactDatabaseNameOf(artifact.name.absolute, options.toOdata.names, model), artifact);
      }
      forEachMemberRecursively(artifact, (member, memberName)  => {
        // Only these are actually required
        if (['element', 'key', 'param'].includes(member.kind)) {
          // If we have a 'preserved dotted name' (i.e. we are a result of flattening), use that for the @cds.persistence.name annotation
          if (member._flatElementNameWithDots) {
            memberName = member._flatElementNameWithDots;
          }
          addStringAnnotationTo('@cds.persistence.name', getElementDatabaseNameOf(memberName, options.toOdata.names), member);
        }
      });
    }

    // Perform checks for exposed non-abstract entities and views
    if (artifact._service && !artifact.abstract && (artifact.kind == 'entity' || artifact.kind == 'view')) {
      let keyCount = 0;
      let mediaTypes = [];
      // Walk the elements
      for (let elemName in artifact.elements) {
        let elem = artifact.elements[elemName];

        // For ODATA V2, element names must not start with digit or '_'
        if (options.toOdata.version == 'v2') {
          if (illV2Prefix.test(elemName)) {
            signal(error`"${artifact.name.absolute}.${elemName}: Element name must not begin with '${elemName[0]}' for OData V2`, elem.location);
          }
        }

        // Count keys and elements annotated with @Core.MediaType
        if (elem.key && elem.key.val) {
          keyCount++;
        }
        if (elem['@Core.MediaType']) {
          mediaTypes.push([elemName, elem]);
        }
      }

      // Exposed non-abstract entities in non-contained artifacts must have a key
      if (keyCount == 0 && !artifact._containerEntity) {
        signal(error`Entity "${artifact.name.absolute}" does not have a key: ODATA entities must have a key`, artifact.location);
      }

      // Additional checks for ODATA V2 regarding remaining keys
      if (options.toOdata.version == 'v2') {
        // Elements that are annotated with @Core.HasStream are removed from the entity type.
        // If these are all keys then this would end up with a key-less EntityType wich is illegal in V2
        let mtkeys = mediaTypes.filter(e=>e[1].key && e[1].key.val);
        if (mtkeys.length > 0 && keyCount == mtkeys.length) {
          signal(error`"${artifact.name.absolute}: Key elements [${mtkeys.map(e=>e[0]).join(', ')}] annotated with '@Core.MediaType' are removed from Odata V2 resulting in keyless EntityType`, artifact.location);
        }
        // Today only one MediaType is allowed in V2
        if (mediaTypes.length > 1) {
          signal(error`"${artifact.name.absolute}: Elements [${mediaTypes.map(e=>e[0]).join(', ')}] annotated with '@Core.MediaType', OData V2 allows only one`, artifact.location);
        }
      }

      // Check media type compatibility for all OData versions
      let allowedTypes = ['cds.String', 'cds.Binary', 'cds.LargeBinary'];
      mediaTypes.forEach(e => {
        if (!allowedTypes.includes(e[1]._finalType.type._artifact.name.absolute)) {
          signal(error`"${artifact.name.absolute}.${e[0]}": Element annoted with '@Core.MediaType' must be of either type "${allowedTypes.join(', ')}"`, e[1].location);
        }
      });
    }
  });

  // Throw up if we have errors
  if (hasErrors(model.messages)) {
    throw new CompilationError(sortMessages(model.messages), model);
  }
  return model;

  // Apply checks to all annotations in the model
  // node: artifact/element/action/function/parameter/... that carries the annotations
  function checkAnnotations(node) {
    // currently there is only one check: annotations @sap:... must have a string or boolean value
    //   or no value (as shorcut for boolean value true)
    let annoNames = Object.keys(node).filter(x => x.startsWith('@sap.'));
    for (let name of annoNames) {
      if (node[name].path ||
          !(node[name].literal == undefined || node[name].literal == 'boolean' || node[name].literal == 'string')) {
        signal(warning`Annotation "${name}" must have a string or boolean value`, node[name].location);
      }
    }
  }

  // Generate all that is required in ODATA for draft enablement of 'artifact' into the artifact
  // and into the model
  function generateDraftForOdata(artifact) {
    // Sanity check
    if (!artifact._service) {
      throw new Error('Expecting artifact to be part of a service: ' + JSON.stringify(artifact));
    }

    // FIXME: Current restriction: Must only have exactly one key, which is of type UUID
    let keyNames = Object.keys(artifact.elements).filter(elemName => {
      return artifact.elements[elemName].key && artifact.elements[elemName].key.val;
    });
    if (keyNames.length != 1) {
      signal(warning`"${artifact.name.absolute}": Ignoring annotation "@odata.draft.enabled" - currently only supported for artifacts with exactly one key of type "UUID"`, artifact.location);
      return;
    }
    let keyElem = artifact.elements[keyNames[0]];
    // Sanity check
    if (!keyElem._finalType) {
      throw new Error('Expecting artifact to have final type: ' + JSON.stringify(keyElem));
    }
    if (keyElem._finalType.name.absolute != 'cds.UUID') {
      signal(warning`"${artifact.name.absolute}": Ignoring annotation "@odata.draft.enabled" - currently only supported for key of type "UUID"`, keyElem.location);
      return;
    }

    // Generate the DraftAdministrativeData projection into the service, unless there is already one
    let draftAdminDataProjectionName = artifact._service.name.absolute + '.' + 'DraftAdministrativeData';
    let draftAdminDataProjection = model.definitions[draftAdminDataProjectionName];
    if (!draftAdminDataProjection) {
      draftAdminDataProjection = createAndAddDraftAdminDataProjection(artifact._service);
      addBoolAnnotationTo('@cds.odata.NoEntitySet', true, draftAdminDataProjection);
    }
    // Barf if it is not an entity or not what we expect
    if (draftAdminDataProjection.kind != 'entity' || !draftAdminDataProjection.elements['DraftUUID']) {
      signal(error`Generated entity "${draftAdminDataProjectionName}" conflicts with existing artifact`, draftAdminDataProjection.location);
    }

    // Generate the annotations describing the draft actions
    addStringAnnotationTo('@Common.DraftRoot.PreparationAction', 'draftPrepare', artifact);
    addStringAnnotationTo('@Common.DraftRoot.ActivationAction', 'draftActivate', artifact);
    addStringAnnotationTo('@Common.DraftRoot.EditAction', 'draftEdit', artifact);

    // Generate the additional elements into the draft-enabled artifact

    // key IsActiveEntity : Boolean default true
    let isActiveEntity = createScalarElement('IsActiveEntity', 'cds.Boolean', true, true);
    addElement(isActiveEntity, artifact);

    // HasActiveEntity : Boolean default false
    let hasActiveEntity = createScalarElement('HasActiveEntity', 'cds.Boolean', false, false);
    addElement(hasActiveEntity, artifact);

    // HasDraftEntity : Boolean default false;
    let hasDraftEntity = createScalarElement('HasDraftEntity', 'cds.Boolean', false, false);
    addElement(hasDraftEntity, artifact);

    // DraftAdministrativeData : Association to one DraftAdministrativeData;
    let draftAdministrativeData = createAssociationElement('DraftAdministrativeData', draftAdminDataProjection, true);
    draftAdministrativeData.cardinality = {
      targetMax: {
        literal: 'number',
        val: 1,
      },
    };
    addElement(draftAdministrativeData, artifact);

    // SiblingEntity : Association to one Books on (... IsActiveEntity unequal, all other key fields equal ...)
    let siblingEntity = createAssociationElement('SiblingEntity', artifact, false);
    siblingEntity.cardinality = {
      targetMax: {
        literal: 'number',
        val: 1,
      },
    };
    addElement(siblingEntity, artifact);
    // ... on SiblingEntity.IsActiveEntity != IsActiveEntity ...
    siblingEntity.onCond = createAssociationPathComparison(siblingEntity, isActiveEntity, '!=', isActiveEntity);
    for (let elemName in artifact.elements) {
      let elem = artifact.elements[elemName];
      if (elemName != 'IsActiveEntity' && elem.key) {
        // ... and SiblingEntity.<keyfield> = <keyfield> ... (for all key fields except 'IsActiveEntity')
        siblingEntity.onCond = {
          op: {
            val: 'and',
          },
          args: [
            createAssociationPathComparison(siblingEntity, elem, '=', elem),
            siblingEntity.onCond,
          ]
        }
      }

      // Make all non-key fields nullable
      if (elem.notNull && !elem.key) {
        elem.notNull.val = false;
      }
    }

    // Generate the actions into the draft-enabled artifact

    // action draftPrepare (SideEffectsQualifier: String) return <artifact>;
    let draftPrepare = createAction('draftPrepare', artifact, 'SideEffectsQualifier', 'cds.String');
    addAction(draftPrepare, artifact);

    // action draftActivate() return <artifact>;
    let draftActivate = createAction('draftActivate', artifact);
    addAction(draftActivate, artifact);

    // action draftEdit (PreserveChanges: Boolean) return <artifact>;
    let draftEdit = createAction('draftEdit', artifact, 'PreserveChanges', 'cds.Boolean');
    addAction(draftEdit, artifact);
  }

}

// Rename shorthand annotations within artifact or element 'node' according to a builtin
// list.
function renameShorthandAnnotations(node) {
  // FIXME: Verify this list - are they all still required? Do we need any more?
  const mappings = {
    '@label': '@Common.Label',
    '@title': '@Common.Label',
    '@ValueList.entity': '@Common.ValueList.entity',
    '@ValueList.type': '@Common.ValueList.type',
    '@Capabilities.Deletable': '@Capabilities.DeleteRestrictions.Deletable',
    '@Capabilities.Insertable': '@Capabilities.InsertRestrictions.Insertable',
    '@Capabilities.Updatable': '@Capabilities.UpdateRestrictions.Updatable',
  }

  for (let name in node) {
    // Rename according to map above
    if (mappings[name] != undefined) {
      renameAnnotation(node, name, mappings[name]);
    }

    // Special case: '@important: [true|false]' becomes '@UI.Importance: [#High|#Low]'
    if (name == '@important') {
      renameAnnotation(node, name, '@UI.Importance');
      let annotation = node['@UI.Importance'];
      annotation.literal = 'enum';
      annotation.symbol = {
        // Note that an original '@important' without ': true' shows up as undefined value here!!
        id: (annotation.val == undefined || annotation.val == true) ? 'High' : 'Low',
      };
      // FIXME: Strangely, enum-valued annotations have no value
      delete annotation.val;
    }

    // Special case: '@readonly' becomes a triplet of capability restrictions for entities,
    // but '@Core.Immutable' for everything else.
    if (name == '@readonly') {
      if (node.kind == 'entity' || node.kind == 'view') {
        addBoolAnnotationTo('@Capabilities.DeleteRestrictions.Deletable', false, node);
        addBoolAnnotationTo('@Capabilities.InsertRestrictions.Insertable', false, node);
        addBoolAnnotationTo('@Capabilities.UpdateRestrictions.Updatable', false, node);
      }
      else {
        renameAnnotation(node, name, '@Core.Immutable');
      }
    }
  }
}

// Return an array of non-abstract service names contained in (augmented or compacted) 'model''
function getServiceNames(model) {
  let resultDict = Object.create(null);
  forEachDefinition(model, (artifact, artifactName) => {
    if (artifact.kind == 'service' && !artifact.abstract) {
      resultDict[artifactName] = artifact;
    }
  });
  return Object.keys(resultDict);
}

// Post-process an augmented CSN model 'model' that has been produced by 'transform4odata' so that it
// looks like the original (compacted) output of the '4odata' transformation'.
// If 'serviceName' is provided, only artifacts from this service are considered for the output.
// Most of this should not be necessary once we adapt the EDMX generation to use augmented CSN.
// Currently this involves the following steps:
// - Convert to compact CSN
//   => EDMX processors should actually use augmented CSN
// - Keep only exposed artifacts
//   => EDMX processors should instead look only at those artifacts in augmented CSN that have '_service'
// - Filter out everything but the one service selected
//   => EDMX processors should handle this based on '_service', too
// Return a (compacted) copy of 'model' with the transformation applied. Do not change the original model.
function postProcessForBackwardCompatibility(model, serviceName=undefined) {
  // Compact the model
  let compactedModel = (model.options.testMode) ? compactSorted(model) : compact(model);
  setProp(compactedModel, 'messages', model.messages);

  // Iterate artifact definitions on the augmented model, but modify the compacted one in parallel
  forEachDefinition(model, (artifact, artifactName) => {
    // Remove artifacts that are not exposed
    if (!artifact._service) {
      delete compactedModel.definitions[artifactName];
      return;
    }
    // Ignore if not part of specified service (if any)
    if (serviceName != undefined && serviceName != artifact._service.name.absolute) {
      delete compactedModel.definitions[artifactName];
      return;
    }
  });
  return compactedModel;
}

module.exports = {
  transform4odata,
  getServiceNames,
  postProcessForBackwardCompatibility,
}
