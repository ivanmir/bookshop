"use strict";
var { CompilationError, hasErrors, sortMessages } = require('../base/messages');
const { forEachDefinition, forEachMemberRecursively, setProp,
        cloneWithTransformations }  = require('../base/model');
const deepCopy = require('../base/deepCopy');
const { isAssociation, isStructuredElement, isManagedAssociationElement, isProjection, isView,
        foreachPath, printableName, mergeOptions, hasBoolAnnotation, getTopLevelArtifactNameOf,
        isElementWithType, addStringAnnotationTo, getArtifactDatabaseNameOf,
        getElementDatabaseNameOf } = require('../model/modelUtils');
const transformUtils = require('./transformUtils');
const { checkTypeParameters } = require('../checks/checkElements');
const alerts = require('../base/alerts');
const { translateAssocsToJoins } = require('./translateAssocsToJoins');

// Return a copy of augmented CSN 'model' with a number of transformations made for rendering
// in HANA CDS style, used by 'toHana', toSql' and 'toRename'.
// The behavior is controlled by the following options:
// options = {
//    forHana.names                               // See the behavior of 'names' in toHana, toSql and toRename
//    forHana.associations                        // See the behavior of 'associations' in toHana and toSql
//    forHana.keepNamespaces                      // Do not transform namespaces to contexts (to be used for
//                                                // producing HANA-CDS compatible names with 'toHana', 'toSql' ...)
//    forHana.keepStructsAssocs                   // Do not flatten structs, do not convert managed assocs to
//                                                // unmanaged ones, do not convert assocs to joins (to be used
//                                                // for rendering strictly HANA-CDS compatible CDS source with
//                                                // 'toHana')
// }
// The result model will always have 'options.forHana' set, to indivate that these transformations have happened.
// The following transformations are made:
// - (010) (not for 'keepStructsAssocs'): Transform associations to joins if requested by option
//         'forHana.associations'
// - (020) Check: in "flat" mode, quoted ids are not allowed.
//         (a) check in namespace declarations
//         (b) check in artifact/element definitions.
// - (030) ("flat" only) For all elements, derived types are replaced by their final base type.
// - (040) Abstract entities and entities 'implemented in' something are ignored, as well
//         as entities annotated with '@cds.persistence.skip' or '@cds.persistence.exists'.
// - (045) The query is stripped from entities that are annotated with '@cds.persistence.table',
//         essentially converting views to entities.
// - (050) Some primitive type names are mapped to HANA type names (e.g. DateTime => UTCDateTime,
//         Date => LocalDate, ...).
// - (060) The primitive type 'UUID' is replaced by 'String(36)'.
// - (070) Default length 5000 is supplied for strings if not specified.
// - (080) Annotation definitions (a) and annotation assignments (b) are ignored.
// - (090) Compositions become associations.
// - (100) 'virtual' elements are ignored (a), 'masked' is ignored (b), and attribute 'localized' is removed (c)
// - (110) Actions and functions (bound or unbound) are ignored.
// - (120) (a) Services become contexts.
//         (b) (not for 'keepNamespaces'): Namespaces become contexts.
// - (130) (not for 'keepStructsAssocs'): Elements having structured types are flattened into
//         multiple elements (using '_' or '.' as name separator, depending on 'forHana.names').
// - (140) (not for 'keepStructsAssocs'): Managed associations get explicit ON-conditions, with
//         generated foreign key elements (also using '_' or '.' as name separator, depending on 'forHana.names').
// - (150) (a) Elements from inherited (included) entities are copied into the receiving entity
//         (b) The 'include' property is removed from entities.
// - (160) Projections become views, with MIXINs for association elements (adding $projection where
//         appropriate for ON-conditions).
// - (170) ON-conditions referring to '$self' are transformed to compare explicit keys instead.
// - (180) In projections and views, ...
//         (a) association elements that are mixins must not be explicitly redirected
//         (b) MIXINs are created for association elements in the select list that are not mixins by themselves.
// - (190) For all enum types, ...
//         (a) enum constants in defaults are replaced by their values (assuming a matching enum as element type)
//         (b) the enum-ness is stripped off (i.e. the enum type is replaced by its final base type).
// - (200) The 'key' property is removed from all elements of types.
// - (210) (not for 'keepStructsAssocs'): Managed associations in GROUP BY and ORDER BY are
//         replaced by by their foreign key fields.
// - (220) Contexts that contain no artifacts or only ignored artifacts are ignored.
// - (230) (only for 'keepStructsAssocs'): The following are rejected in views
//         (a) Structured elements
//         (b) Managed association elements
//         (c) Managed association entries in GROUP BY
//         (d) Managed association entries in ORDER BY
// - (240) All artifacts (a), elements, foreign keys, parameters (b) that have a DB representation are annotated
//         with their database name (as '@cds.persistence.name') according to the naming convention chosen
//         in 'options.forHana.names'.
function transformForHana(inputModel, options) {
  // Work on a copy of the input model
  const { error, warning, signal } = alerts(inputModel);
  let model = deepCopy(inputModel);
  model.messages = inputModel.messages;

  // Tell consumers that this model has undergone the transformations for HANA, and merge options into model
  model.options = mergeOptions({ forHana: true }, inputModel.options, options);
  options = model.options;

  const pathDelimiter = (options.forHana.names == 'hdbcds') ? '.' : '_';

  const { flattenStructuredElement, flattenForeignKeys, checkForeignKeys,
    flattenStructStepsInPath, createForeignKeyElement, toFinalBaseType,
    setServiceProperty, addImplicitRedirections, isBacklinkAssociation,
    isBacklinkComparison, collectAllSimpleExpressions,
    createAndAddDraftAdminDataProjection, createScalarElement, createAssociationElement,
    addElement,copyAndAddElement } = transformUtils.getTransformers(model, pathDelimiter);


  // (010) If requested, translate associations to joins
  if (!options.forHana.keepStructsAssocs && options.forHana.associations == 'joins') {
    model = translateAssocsToJoins(model);
  }

  // Set '_service' property for all artifacts and sub-artifacts, for each service in the model
  setServiceProperty(model);

  // Generate artificial draft shadow entities if requested
  forEachDefinition(model, artifact => {
    if ((artifact.kind == 'entity' || artifact.kind == 'view') && hasBoolAnnotation(artifact, '@odata.draft.enabled')) {
      generateDraftForHana(artifact);
    }
  });

  // (020 a) In "flat" mode, quoted ids are not allowed.
  // Here, check namespace declarations (only stored in model.sources).
  if (options.forHana.names == 'flat' && model.sources) {
    for (let s in model.sources) {
      if (model.sources[s].namespace && model.sources[s].namespace.path) {
        model.sources[s].namespace.path.filter(x => x.quoted).forEach(errorQuotedIdentifier);
      }
    }
  }

  // (030) - only for 'flat' names
  // For all elements, replace derived types by final base type
  // Needs to happen before renamePrimitiveTypes() or replaceUuidByString()
  if (options.forHana.names == 'flat') {
    forEachDefinition(model, artifact => {
      forEachMemberRecursively(artifact, member => {
        toFinalBaseType(member);
      });
    });
  }

  // Perform implicit redirection of non-exposed association targets
  // Don't do it when producing SQL for sqlite, as there are no assocs to redirect any more
  // (FIXME : ... and implicit redirection fails when translation assoc-to-join has already run)
  if (!(options.toSql && options.toSql.dialect === 'sqlite')) {
    addImplicitRedirections(model);
  }

  // Process all artifacts (pass 1)
  forEachDefinition(model, artifact => {
    // (040) Ignore entities and views that are abstract or implemented
    // or carry the annotation cds.persistence.skip/exists
    // These entities are not removed from the model, but flagged as "to be ignored"
    if (artifact.kind == 'entity' || artifact.kind == 'view') {
      if (artifact.abstract ||
          artifact.impl ||
          hasBoolAnnotation(artifact, '@cds.persistence.skip')) {
        artifact._ignore = true;
      }
      else if (hasBoolAnnotation(artifact, '@cds.persistence.exists')) {
        artifact._ignore = true;
        artifact.impl = 'existsOnDB'; // used in toCdl to generate correct "using"
      }
    }
    // (045) Strip all query-ish properties from views and projections annotated with '@cds.persistence.table',
    // and make them entities
    if ((isProjection(artifact) || isView(artifact)) && hasBoolAnnotation(artifact, '@cds.persistence.table')) {
      artifact.kind = 'entity';
      delete artifact.query;
      delete artifact.queries;
      delete artifact.source;
      // All elements must have a type for this to work
      forEachMemberRecursively(artifact, member => {
        if (member.kind == 'element' && !isElementWithType(member)) {
          signal(error`"${artifact.name.absolute}.${member.name.element}": All elements must have a type when entity is annotated with "@cds.persistence.table"`, member.location);
        }
      });
    }

    // Some transformation for all kinds of artifacts
    transformCommon(artifact);
    // (120 a) Services become contexts
    if (artifact.kind == 'service') {
      artifact.kind = 'context';
    }
    // (120 b) Namespaces become contexts (unless explicitly asked to keep them)
    if (!options.forHana.keepNamespaces && artifact.kind == 'namespace') {
      artifact.kind = 'context';
    }

    // Do things specific for entities and views (pass 1)
    if (artifact.kind == 'entity' || artifact.kind == 'view') {
      transformEntityOrViewPass1(artifact);
    }
    // (150 b) Strip inheritance
    delete artifact.includes;
    // (080) Ignore annotation declarations
    if (artifact.kind == 'annotation') {
      artifact._ignore = true;
    }
    // Process the artifact's  members
    forEachMemberRecursively(artifact, member => {
      transformCommon(member);
      // (100 a) Ignore virtual elements
      if (member.virtual) {
        member._ignore = true;
      }
      // (100 b) Ignore the property 'masked' itself (but not its effect on projections)
      if (member.masked) {
        member._ignoreMasked = true;
      }
      // Treat inherited (not projected!) members as if they originated here
      if (member.origin && !artifact.query && member.kind !== 'key') {
        delete member.origin;
      }
      // Barf if a key is explicitly (!) nullable
      if (member.key && member.key.val && member.notNull && !member.notNull.val) {
        signal(error`"${artifact.name.absolute}.${member.name.element}": Key elements cannot be nullable in HANA CDS`, member.notNull.location);
      }
    });
  });

  // Process all artifacts (pass 2)
  // Perform HANA-specific checks that require the whole model to be processed
  // FIXME: Ideally, we could do this on-the-fly while processing artifacts, but because we do struct
  // flattening etc non-recursively, we need to wait till all artifacts are processed
  forEachDefinition(model, artifact => {
    if (!artifact._ignore) {
      // (240 a) Annotate artifacts with their DB names
      // Skip artifacts that have no DB equivalent anyway
      if (!['service', 'context', 'namespace', 'annotation', 'action', 'function'].includes(artifact.kind)) {
        addStringAnnotationTo('@cds.persistence.name', getArtifactDatabaseNameOf(artifact.name.absolute, options.forHana.names, model), artifact);
      }
      // Do things specific for entities and views (pass 2)
      if (artifact.kind == 'entity' || artifact.kind == 'view') {
        transformEntityOrViewPass2(artifact);
      }
      forEachMemberRecursively(artifact, (member, memberName) => {
        // (240 b) Annotate elements, foreign keys, parameters etc with their DB names
        if (['element', 'key', 'param'].includes(member.kind)) {
          addStringAnnotationTo('@cds.persistence.name', getElementDatabaseNameOf(memberName, options.forHana.names), member);
        }
        // (20 a) If we keep associations as they are (hdbcds naming convention), we cannot have structured
        // view elements (we could enumerate the elements but we can't give them the names one would expect)
        if (options.forHana.keepStructsAssocs
            && (isProjection(artifact) || isView(artifact))
            && isStructuredElement(member)) {
          signal(error`With "hdbcds" naming, structured elements cannot be used in a view`, member.location);
          return;
        }
        // Check foreign keys of redirected associations
        if (!member._ignore && isAssociation(member.type)) {
          checkForeignKeys(member);
        }
        // (200) Strip 'key' property from type elements
        if (artifact.kind == 'type' && member.key) {
          delete member.key;
        }
      });

      // (210) Fix GROUP BY, ORDER BY in views
      if (isView(artifact)) {
        replaceAssociationsInGroupByOrderBy(artifact)
      }

      // (220) Weed out empty top-level contexts recursively (i.e. those that only have ignored content)
      if (artifact.kind == 'context' && getTopLevelArtifactNameOf(artifact.name.absolute, model) == artifact.name.absolute) {
        ignoreContextsWithIgnoredContent(artifact);
      }
    }
  });

  // Throw up if we have errors
  if (hasErrors(model.messages)) {
    throw new CompilationError( sortMessages(model.messages), model)
  }

  return model;

  // Traverse artifact 'art', set '_ignore' for all contexts that only contain ignored artifacts
  function ignoreContextsWithIgnoredContent(art) {
    // We only care for non-ignored contexts
    if (art._ignore || art.kind != 'context') {
      return;
    }
    // Descend into children, note if any is non-ignored
    let hasNonIgnoredChildren = false;
    for (let childName in art.artifacts || {}) {
      let child = art.artifacts[childName];
      ignoreContextsWithIgnoredContent(child);
      if (!child._ignore) {
        hasNonIgnoredChildren = true;
      }
    }
    if (!hasNonIgnoredChildren) {
      // If we get here, the context was either empty or everything in it was ignored.
      // We currently preserve empty contexts - might also ignore them if we later decide so
      if (art.artifacts && Object.keys(art.artifacts).length > 0) {
        art._ignore = true;
      }
    }
  }

  // Perform transformations common to artifacts and members (in place)
  function transformCommon(obj) {
    // (020 b) In "flat" mode, quoted ids are not allowed. Here, check for artifact and
    // element definitions (ignore elements that have been added by postprocessing steps.)
    if (options.forHana.names == 'flat' && !obj.viaTransform) {
      if (obj.name.path) {
        obj.name.path.filter(x => x.quoted).forEach(errorQuotedIdentifier);
      }
      else if (obj.name.quoted) {
        errorQuotedIdentifier(obj.name);
      }
    }
    // (050) Rename HANA-specific types
    renamePrimitiveTypes(obj);
    renamePrimitiveTypes(obj.items);
    // (060) Replace type UUID by String(36)
    replaceUuidByString(obj);
    replaceUuidByString(obj.items);
    // (070) Supply default length 5000 for strings if not specified
    // FIXME: Do we really want this?
    addDefaultStringLength(obj);
    addDefaultStringLength(obj.items);
    // (080 b) Strip annotation assignments
    for (let name in obj) {
      if (name.startsWith('@')) {
        delete obj[name];
      }
    }
    // (090) Compositions become associations
    if (obj.type && obj.type.absolute && obj.type.absolute == 'cds.Composition') {
      obj.type.absolute = 'cds.Association';
      obj.type.path = [{id: obj.type.absolute}];
      setProp(obj.type, '_artifact', model.definitions['cds.Association']);
      setProp(obj.type.path[0], '_artifact', model.definitions['cds.Association']);
    }
    // (100 c) Remove attribute 'localized'
    delete obj.localized;
    // (080 a) and (110) Ignore annotation declarations, actions and functions
    if (obj.kind == 'annotation' || obj.kind == 'action' || obj.kind == 'function') {
      obj._ignore = true;
    }
    // Check type parameters (length, precision, scale ...)
    if (!obj._ignore && obj.type) {
      checkTypeParameters(obj, model);
    }
    if (!obj._ignore && obj.items && obj.items.type) {
      checkTypeParameters(obj.items, model);
    }
  }

  // Issue an error for a quoted identifier in toHana, flat mode
  function errorQuotedIdentifier(obj) {
    signal(error`Quoted identifiers are not allowed in flat mode of toHana: "${obj.id}"`, obj.location);
  }

  // If 'obj' has one of the primitive types that have a different name in HANA,
  // rename the type accordingly
  function renamePrimitiveTypes(obj) {
    const hanaNames = {
      'cds.DateTime' : 'UTCDateTime',
      'cds.Timestamp' : 'UTCTimestamp',
      'cds.Date' : 'LocalDate',
      'cds.Time' : 'LocalTime'
    }
    if (obj && obj.type && obj.type.absolute in hanaNames) {
      obj.type.absolute = hanaNames[obj.type.absolute];
      obj.type.path = [{id : obj.type.absolute}];
    }
  }

  // If 'obj' has primitive type 'cds.UUID', make it a cds.String(36)
  function replaceUuidByString(obj) {
    if (obj && obj.type && obj.type._artifact == model.definitions['cds.UUID']) {
      obj.type = {
        absolute: 'cds.String',
        path: [{id: 'cds.String'}]
      };
      setProp(obj.type, '_artifact', model.definitions['cds.String']);
      setProp(obj.type.path[0], '_artifact', model.definitions['cds.String']);
      setProp(obj, '_finalType', obj);
      obj.length = { literal: 'number', val: 36 };
    }
  }

  // If 'obj' has primitive type 'cds.String' and no length, add default length 5000
  function addDefaultStringLength(obj) {
    if (obj && obj.type && obj.type.absolute && obj.type.absolute == 'cds.String' && !obj.length) {
      obj.length = { literal: 'number', val: 5000 }
    }
  }

  // Perform first pass of all transformations required for an entity or a projection entity or a view (in place)
  function transformEntityOrViewPass1(art) {
    // (130) First walk through the entity elements: Flatten structs (might result in new elements)
    // (unless explicitly asked to keep structs)
    if (!options.forHana.keepStructsAssocs) {
      for (let elemName in art.elements) {
        let elem = art.elements[elemName];
        if (isStructuredElement(elem)) {
          // Ignore the structured element, replace it by its flattened form
          elem._ignore = true;
          let flatElems = flattenStructuredElement(elem);
          for (let flatElemName in flatElems) {
            if (art.elements[flatElemName]) {
              signal(error`"${art.name.absolute}.${elemName}": Flattened struct element name conflicts with existing element: "${flatElemName}"`, elem.location);
            }
            art.elements[flatElemName] = flatElems[flatElemName];
            // FIXME: Should also adapt indexNo of the newly added elements and all subsequent ones
          }
        }
      }
    }

    // Flatten structs in indexes and partitions (unless explicitly asked to keep structs)
    let tc = art.technicalConfig;
    if (!options.forHana.keepStructsAssocs) {
      if (tc) {
        // Secondary and fulltext indexes
        for (let name in tc.indexes) {
          let index = tc.indexes[name];
          // Array of indexes is an error: multiple index definitions with same name.
          // However, if it has survived until here, behave correctly
          if (Array.isArray(index)) {
            index.forEach(idx => {
              checkFTIColumns(idx);
              flattenStructuredColumnPaths(idx.columns);
            });
          }
          else {
            checkFTIColumns(index);
            flattenStructuredColumnPaths(index.columns);
          }
        }
        if (tc.fzindexes) {
          tc.fzindexes.forEach(idx =>  {
            flattenStructuredColumnPaths(idx.columns);
          });
        }
        // Partition columns
        if (tc.partition) {
          tc.partition.specs.forEach(spec => flattenStructuredColumnPaths(spec.columns));
        }
      }
    }

    function checkFTIColumns(index) {
      if(index.kind === 'fulltextindex') {
        index.columns.filter(col => isStructuredElement(col._artifact)).forEach(col => {
          signal(error`"${art.name.absolute}": A fulltext index cannot be defined on a structured element "${col._artifact.name.absolute}`,
          col.location);
        });
      }
    }

    // Flatten structs used in paths (unless explicitly asked to keep structs)
    if (!options.forHana.keepStructsAssocs) {
      foreachPath(art, (path, pathOwner) => {
        pathOwner.path = flattenStructStepsInPath(path);
      });
    }

    // after all paths have been flattened "a_b_c", assign fuzzy index definitions
    // to the flattened element
    if (tc && tc.fzindexes) {
      tc.fzindexes.forEach(idx =>  {
        idx.columns.forEach(col => {
          if(!col._ignore) {
            art.elements[col.path[0].id]._fzindex = idx; // last one wins on multiple occurences
          }
        });
      });
    }

    // Second walk through the entity elements: Deal with associations (might also result in new elements)
    for (let elemName in art.elements) {
      let elem = art.elements[elemName];
      // Magic special case: If a fully fledged element was extended into a projection
      // (recognizable by not having a value), it must be an unmanaged association (because only
      // those can be "added" into the MIXIN of the resulting view
      if (isProjection(art) && !elem.value) {
        if (!isAssociation(elem.type) || isManagedAssociationElement(elem)) {
          // Not an unmanaged association
          signal(error`"${art.name.absolute}.${elem.name.element}": Only unmanaged associations can be extended into projections with --to-hana`,
          elem.location);
        } else {
          // Unmanaged association: OK, construct an artificial value (otherwise toCdl would omit this element
          // from the projection list)
          elem.value = {
            path: [{ id: elemName }],
            absolute: elem.absolute,
            element: elemName,
          };
          elem.name.calculated = true;
          // FIXME: Cannot construct a proper _artifact here
        }
      }

      // (140) Generate foreign key elements and ON-condition for managed associations
      // (unless explicitly asked to keep asocs unchanged)
      if (!options.forHana.keepStructsAssocs) {
        if (isManagedAssociationElement(elem)) {
          // Aliased foreign keys in managed associations not yet allowed (only check for non-projections, to avoid duplicate errors)
          if (!elem._main.source) {
            for (let name in elem.foreignKeys) {
              let foreignKey = elem.foreignKeys[name]
              if (!foreignKey.calculated && !foreignKey.name.$inferred && !foreignKey.name.calculated) {
                signal(error`"${elem.name.absolute}.${elem.name.element}": Aliases for foreign keys are not supported yet with --to-hana`,
                       elem.foreignKeys[name].location);
              }
            }
          }
          // Flatten foreign keys (replacing foreign keys that are managed associations by their respective foreign keys)
          elem.foreignKeys = flattenForeignKeys(elem.foreignKeys);
          // Generate foreign key elements for managed associations, and assemble an ON-condition with them
          let onCondParts = [];
          for (let name in elem.foreignKeys) {
            let foreignKey = elem.foreignKeys[name]
            // Sanity check
            if (!foreignKey.targetElement.path) {
              throw Error('Expecting foreign key ' + printableName(foreignKey) + ' to have a path');
            }
            // Assemble left hand side of 'assoc.key = fkey'
            let assocKeyArg = {
              path: [ { id: elem.name.id } ].concat(foreignKey.targetElement.path),
              absolute: foreignKey.name.absolute,
              element: foreignKey.name.id,
            }
            setProp(assocKeyArg, '_artifact', foreignKey._artifact);
            // Assemble right hand side of 'assoc.key = fkey'
            let foreignKeyElement = createForeignKeyElement(elem, foreignKey);
            let fKeyArg = {
              path: [ { id: foreignKeyElement.name.id } ],
              absolute: foreignKeyElement.name.absolute,
              element: foreignKeyElement.name.id
            }
            setProp(fKeyArg, '_artifact', foreignKey._artifact);
            onCondParts.push({ op: {val:'=', location: elem.location}, args : [ assocKeyArg, fKeyArg ]});
          }
          if (onCondParts.length == 1) {
            // Only one key-fkey comparison
            elem.onCond = onCondParts[0];
          } else {
            // Multiple key-fkey comparisons - join with 'and'
            elem.onCond = { op: {val:'and', location: elem.location}, args: onCondParts };
          }

          // If the managed association has a 'key' property => remove it as unmanaged assocs cannot be keys
          // TODO: Are there other modifiers (like 'key') that are valid for managed, but not valid for unmanaged assocs?
          if (elem.key && elem.key.val) {
            delete elem.key;
          }

          // If the managed association has a 'not null' property => remove it
          if (elem.notNull && elem.notNull.val) {
            delete elem.notNull;
          }

          // The association is now unmanaged, i.e. actually it should no longer have foreign keys
          // at all. But the processing of backlink associations below expects to have them, so
          // we don't delete them (but mark them as implicit so that toCdl does not render them)
          elem.implicitForeignKeys = true;
        }
      }

      // Workaround for bugzilla 176495
      // If a select item of a cdx view contains an expression, the result type cannot be computed
      // but must be explicitly specified. This is important for the OData channel, which doesn't
      // work if the type is missing (for HANA channel an explicit type is not required, as HANA CDS
      // can compute the result type).
      // Due to bug in HANA CDS, providing explicit type 'LargeString' or 'LargeBinary' causes a
      // diserver crash. Until a fix in HANA CDS is available, we allow to suppress the explicit
      // type in the HANA channel via an annotation.
      if ((isProjection(art) || isView(art)) && elem["@cds.workaround.noExplicitTypeForHANA"]) {
        delete elem._typeIsExplicit;
      }
    }

    /*
      For each path node of the columns array do:
        1) Store current path node in newColumns
        2) If the column path terminates in a structured type:
           (but not a managed association, this requires much more effort!)
          2a) Generate all leaf paths originating from this structured type.
              Every path step of the new leaf paths has an _artifact reference to
              it's corresponding definition element.
              Prepend the column path as prefix to all leaf paths and create a new path object
              with attributes { path, absolute, element, _artifact, calculated: true }
          2b) Propagate all properties from original path node to the resulting flattened path
              node, except for [ path, absolute, element, location, calculated ].
          2c) Set leaf _artifact as _artifact to flattened path node.
          2d) Add the new path node to newColumns.
          2e) Mark the original path node with _ignore=true.
        3) Replace the content of original columns with the content of newColumns if required
    */
    function flattenStructuredColumnPaths(columns) {
      if (columns === undefined) {
        return;
      }
      let newColumns = [];
      columns.forEach(col => {
        newColumns.push(col);
        if (col._artifact.elements) {
          let flattenedPaths = getLeafPathsForStructuredElement(col._artifact, col.path);
          flattenedPaths.forEach(fp => {
            let flatCol = { path: fp, absolute: col.absolute, 
              element: fp.map(f=>f.id).join('.'), calculated: true };
            Object.keys(col).forEach(k => {
              if (!['path', 'absolute', 'element', 'location', 'calculated'].includes(k))
                flatCol[k] = col[k];
            });
            setProp(flatCol, '_artifact', fp[fp.length-1]._artifact);
            newColumns.push(flatCol);
          });
          col._ignore = true;
        }
      });
      if (columns.length < newColumns.length) {
        columns.splice(0, columns.length, ...newColumns);
      }

      function getLeafPathsForStructuredElement(elt, prefixPath=[]) {
        let paths = [];
        if (elt.elements) {
          for (let name in elt.elements) {
            let sub = elt.elements[name];
            paths = paths.concat(getLeafPathsForStructuredElement(sub, [ newPathStep(sub) ]) );
          }
          return paths.map(p => prefixPath.concat(p));
        }
        else {
          return prefixPath;
        }

        function newPathStep(elt) {
          let node = { id: elt.name.id };
          setProp(node, '_artifact', elt);
          return node;
        }
      }
    }
  }

  // Perform all transformations required for an entity or a projection entity or a view (in place)
  function transformEntityOrViewPass2(art) {
    // Second walk through the entity elements: Deal with associations (might also result in new elements)
    for (let elemName in art.elements) {
      let elem = art.elements[elemName];

      // (230 b) If we keep associations as they are (hdbcds naming convention), we cannot have managed associations
      // as view elements (their foreign keys cannot be addressed in the view)
      if (options.forHana.keepStructsAssocs
          && (isProjection(art) || isView(art))
          && isAssociation(elem.type)
          && !elem.onCond) {
        signal(error`With "hdbcds" naming, managed association elements cannot be used in a view`, elem.location);
        continue;
      }

      // (170) Transform '$self' in backlink associations to appropriate key comparisons
      if (isAssociation(elem.type)) {
        processBacklinkAssoc(elem);
      }

      // (180 a) An association element in a projection or a view that is defined in a mixin must not
      // be explicitly redirected
      // TODO: consider moving this check to the compiler or a general check phase
      if ((isProjection(art) || isView(art))
          && isAssociation(elem.type)
          && (elem.value && elem.value.path && elem.value.path.length == 1 && art.query && art.query.mixin && art.query.mixin[elem.value.path[0].id])
          && elem.redirected) {
        signal(error`Association elements defined in a mixin must not be redirected: "${elem.value.path[0].id}"`, elem.location);
      }

      // (180 b) Create MIXINs for association elements in projections or views (those that are not mixins by themselves)
      if ((isProjection(art) || isView(art)) && isAssociation(elem.type)
          && !(elem.value && elem.value.path && elem.value.path.length == 1 && art.query && art.query.mixin && art.query.mixin[elem.value.path[0].id])) {
        // Suppress redirections (and the '_typeIsExplicit' that seems to come with it)
        delete elem.redirected;
        delete elem._typeIsExplicit;
        // Create an unused alias name for the MIXIN
        let mixinElemName = '__' + elemName;
        while (art.elements[mixinElemName]) {
          mixinElemName = '_' + mixinElemName;
        }
        // Copy the association element to the MIXIN clause under its alias name
        // (shallow copy is sufficient, just fix name and value)
        let mixinElem = Object.assign({}, elem);
        mixinElem.name = Object.assign({}, elem.name, { id: mixinElemName, element: mixinElemName });
        setProp(mixinElem, '_finalType', elem._finalType);
        setProp(mixinElem, '_main', elem._main);
        setProp(mixinElem, '_parent', elem._parent);
        mixinElem.value = Object.assign({}, elem.value);
        // FIXME: Remove once the compactor no longer renders 'origin'
        mixinElem.origin = mixinElem.value;
        // Perform common transformations on the newly generated MIXIN element (won't be reached otherwise)
        transformCommon(mixinElem);
        if (!art.query.mixin) {
          art.query.mixin = Object.create(null);
        }
        art.query.mixin[mixinElemName] = mixinElem;
        // Let the original association element use the newly generated MIXIN name as value and alias
        delete elem.viaAll;
        delete elem.name.calculated;
        delete elem.name.$inferred;
        if (!elem.value) {
          elem.value = {
            absolute : art.name.absolute
          };
        }
        elem.value.path = [{ id : mixinElemName }];
        elem.value.element = mixinElemName;
        // FIXME: Remove once the compactor no longer renders 'origin'
        elem.origin = elem.value;
        // Clone 'onCond', prepending '$projection' to paths where appropriate,
        // and fixing the association alias just created
        if (mixinElem.onCond) {
          mixinElem.onCond = cloneWithTransformations(mixinElem.onCond, {
            path: (path, pathOwner, clonedPathOwner) => {
              // Clone the path, without any transformations (unfortunately stripping off '_artifact')
              let clonedPath = cloneWithTransformations(path, {});
              // Restore '_artifact' for the path steps
              for (let i = 0; i < path.length; i++) {
                setProp(clonedPath[i], '_artifact', path[i]._artifact);
              }
              // Restore '_artifact' for the object within which 'path' was found
              if (pathOwner._artifact) {
                setProp(clonedPathOwner, '_artifact', pathOwner._artifact);
              }
              // Prepend '$projection' to the path, unless the first path step is the (mixin) element itself or '$projection')
              if (clonedPath[0].id == elemName) {
                clonedPath[0].id = mixinElemName;
              } else if (clonedPath[0].id != '$projection') {
                let projectionId = { id: '$projection' };
                setProp(projectionId, '_artifact', art);
                clonedPath.unshift(projectionId);
              }
              return clonedPath;
            },
            func: (func) => {
              // Unfortunately, function names are disguised as paths, so we would prepend a '$projection'
              // above (no way to distinguish that in the callback for 'path' above). We can only pluck it
              // off again here ... sigh
              if (func.path && func.path[0] && func.path[0].id == '$projection') {
                func.path = func.path.slice(1);
              }
              return func;
            }
          });
        }
      }
    }

    // Third walk through the entity/view elements: All artificial elements in place, do whatever processing is needed on them
    for (let elemName in art.elements) {
      let elem = art.elements[elemName];
      // (190 a) Replace enum symbols by their value (if found)
      if (elem.default && elem.default.literal == 'enum') {
        if (!elem._finalType.enum) {
          // Not an enum at all
          signal(error`Enum literal "#${elem.default.symbol.id}" can only be used with an enum type in HANA CDS`, elem.default.location);
        }
        else {
          // Try to get the corresponding enum symbol from the element's type
          let enumSymbol = elem._finalType.enum[elem.default.symbol.id];
          if (!enumSymbol) {
            signal(error`Enum literal "#${elem.default.symbol.id}" not found in "${elem._finalType.name.absolute}" for HANA CDS`, elem.default.location);
          }
          else if (enumSymbol.value) {
            // Replace default with enum value
            elem.default = {
              literal: enumSymbol.value.literal,
              val: enumSymbol.value.val,
            };
          }
          else {
            // Enum symbol without explicit value - replace default by the symbol in string form
            elem.default = {
              literal: 'string',
              val: enumSymbol.name.id,
            };
          }
        }
      }
      // (190 b) Replace enum types by their final base type
      if (elem._finalType && elem._finalType.enum) {
        elem.type = elem._finalType.type;
        if (elem._finalType.length) {
          elem.length = elem._finalType.length;
        }
        delete elem.enum;
      }
    }

    // (160) Projections now finally become views
    if (isProjection(art)) {
      art.kind = 'view';
    }

    // FIXME: Move this somewhere more appropriate
    if (art.queries) {
      for (let query of art.queries) {
        // There is no '*' in HANA CDS
        delete query.all;
        for (let elemName in query.elements) {
          delete query.elements[elemName].viaAll;
        }
        // There is no 'excluding' in HANA CDS
        delete query.exclude;
      }
    }

    // If the association 'assoc' is a backlink association, massage its ON-condition (in place) so that
    // it compares the appropriate keys with their corresponding foreign key fields. Otherwise, do nothing.
    function processBacklinkAssoc(assoc) {
      let currentArt = assoc._main; // current entity to which will compare for a backlink assoc
      if (isBacklinkAssociation(assoc, currentArt)) {
        let expressions = collectAllSimpleExpressions(assoc.onCond);
        expressions.forEach(expr => {
          if (isBacklinkComparison(expr, currentArt, assoc)) { // should be only one in an array of expressions
            let assocSide = expr.args.find(e => {
              return e._artifact !== currentArt;
            });
            if (assocSide._artifact.foreignKeys) // the case when the not '$self'-containing association is managed one
              transformAugmOnCondForManagedAssoc(expr, assocSide, assoc.name.element);
            else if (assocSide._artifact.onCond) // when the not '$self'-containing association is unmanaged one
              transformAugmOnCondForUnmanagedAssoc(expr, assocSide, assoc.name.element);
          }
        })
      }

      // Takes the simple condition which contains the $self part and transforms it into the desired form with the replaced $self identifier
      // e.g. a: association to B on a.<assoc_in_B> = $self; becomes a : association to B on a.<assoc_in_B>_<key_name1> = <key_name1> and a.<assoc_in_B>_<key_name2> = <key_name2> ...;
      function transformAugmOnCondForManagedAssoc(cond, assoc, selfAssocName) {
        let loc = cond.location;
        let keys = Object.keys(assoc._artifact.foreignKeys);
        // if the element was structured then it was flattened => change of the delimiter from '.' to '_'
        // this is done in the flattening, but as we do not alter the onCond itself there should be done here as well
        let nonSelfAssocName = assoc.element.replace(/\./g, pathDelimiter);
        selfAssocName = selfAssocName.replace(/\./g, pathDelimiter);
        if (keys.length > 1) {
          cond.op = {val:'and',location:loc};
          cond.args = [];
        } else
          cond.op = {val:'=',location:loc};
        keys.forEach(k => {
          // Depending on naming conventions, the foreign key may two path steps (hdbcds) or be a single path step with a flattened name (flat, deep)
          let fKeyPath = options.forHana.keepStructsAssocs ? [{ id: nonSelfAssocName, location: loc },
                                                              { id: k, location: loc} ]
                                                           : [{ id: `${nonSelfAssocName}${pathDelimiter}${k}`, location: loc }]
          // FIXME: _artifact to the args ???
          let a = [
            {
              path: [{ id: selfAssocName, location: loc }, ...fKeyPath], location: loc
            },
            {
              path: [{ id: k, location: loc }], location: loc
            }
          ];
          if (keys.length > 1)
            cond.args.push({
              op: {val:'=',location:loc},
              args: a,
              location: loc
            });
          else
            cond.args = a;
        });
      }

      // Takes the simple condition which contains the $self identifier =>
      // => replace it with the reversed onCond from the non $self-containing association as correctly seen from the $self-containing association
      // e.g. entity A {
      // 	a : Integer;
      // 	c : Integer;
      // 	// originally => toB : association to B on toB.toA = $self and 1 = 1;
      // 	toB : association to B on a = toB.b and c = toB.d and 1 = 1;
      // };
      // entity B {
      // 	b : Integer;
      // 	d : Integer;
      // 	toA : association to A on toA.a = b and toA.c = d;
      // };
      function transformAugmOnCondForUnmanagedAssoc(cond, assoc, selfAssocName) {
        let loc = cond.location;
        // if the element was structured then it may have been flattened => change of the delimiter from '.' to '_'
        // this is done in the flattening, but as we do not alter the onCond itself there should be done here as well
        selfAssocName = selfAssocName.replace(/\./g, pathDelimiter);
        let forwardAssocName = assoc._artifact.name.element.replace(/\./g, pathDelimiter);
        // clone the onCond for later use in the path transformation,
        // also assign the _artifact elements of the path elements to the copy
        let newOnCond = cloneWithTransformations(assoc._artifact.onCond, {
          path: (value, node, resultNode) => {
            resultNode = cloneWithTransformations(value, {});
            resultNode.forEach((element, index) => {
              setProp(element, '_artifact', value[index]._artifact);
            });
            return resultNode;
          }
        });
        // goes through the the newOnCond and transform all the 'path' elements
        foreachPath(newOnCond, (path) => {
          if (path[0].id === forwardAssocName) // we are in the "path" from the forwarding assoc => need to remove the first part of the path
            path.shift();
          else { // we are in the backlink assoc "path" => need to push at the beginning the association's id
            path.unshift({ id: selfAssocName, location: loc });
            // if there was a $self identifier in the forwarding association onCond
            // we do not need it any more, as we prepended in the previous step the back association's id
            if (path[1].id === '$self')
              path.splice(1, 1);
          }
        });
        Object.assign(cond, newOnCond);
      }
    }
  }

  // Replace (formerly) managed associations in GROUP BY and ORDER BY of 'view' by their foreign key fields.
  // FIXME: We should also complain about unmanaged assocs?
  // FIXME: We should also check for structured entries for 'keepStructsAssocs' 
  function replaceAssociationsInGroupByOrderBy(view) {
    for (let query of view.queries) {
      if (query.groupBy) {
        let result = [];
        // Walk the GROUP BY entries, replace assocs by their foreign keys
        for (let groupByEntry of query.groupBy) {
          if (groupByEntry._artifact && groupByEntry._artifact.foreignKeys) {
            // This is (or used to be before transformation) a managed assoc
            // (230 c) If we keep associations as they are (hdbcds naming convention), we can't have associations in GROUP BY
            if (options.forHana.keepStructsAssocs) {
              signal(error`With "hdbcds" naming, managed association elements cannot be used in the GROUP BY clause of a view`, groupByEntry.location);
              continue;
            }

            // Walk the managed assoc's (original) fkeys (apparently, the _artifact of
            // the GROUP-BY entry points to something in the view which does have all properties of the original
            // fkeys, so we need to dig up '_finalType' ...)
            // Sanity check
            if (!groupByEntry._artifact._finalType || !groupByEntry._artifact._finalType.foreignKeys) {
              throw new Error("Expecting GROUP BY entry's artifact's _finalType to have foreign keys");
            }
            let foreignKeys = groupByEntry._artifact._finalType.foreignKeys;
            for (let foreignKeyName in foreignKeys) {
              let foreignKey = foreignKeys[foreignKeyName];
              // Sanity check
              if (!foreignKey.generatedFieldName) {
                throw new Error('Expecting generated field name for foreign key: ' + JSON.stringify(foreignKey));
              }
              // For each fkey, assemble a new GROUP BY entry that looks like one with the assoc, replacing the last path step
              let newPath = groupByEntry.path.slice(0, -1);
              newPath.push({
                id : foreignKey.generatedFieldName,
              });
              result.push(Object.assign({}, groupByEntry, { path : newPath, element : foreignKey.generatedFieldName }));
              // FIXME: We don't bother to reconstruct _artifact links here (hopefully they won't be needed)
            }
          } else {
            // Not a formerly managed association - take as it is
            result.push(groupByEntry);
          }
        }
        query.groupBy = result;
      }
      // Unfortunately, ORDER BY entries look slightly different, so we can't easily reuse what we have above
      // FIXME: Maybe simplify this one day ... ugly!
      if (query.orderBy) {
        let result = [];
        // Walk the ORDER BY entries, replace assocs by their foreign keys
        for (let orderByEntry of query.orderBy) {
          if (orderByEntry.value && orderByEntry.value._artifact && orderByEntry.value._artifact.foreignKeys) {
            // This is (or used to be before transformation) a managed assoc
            // (230 d) If we keep associations as they are (hdbcds naming convention), we can't have associations in ORDER BY
            if (options.forHana.keepStructsAssocs) {
              signal(error`With "hdbcds" naming, managed association elements cannot be used in the ORDER BY clause of a view`, orderByEntry.value.location);
              continue;
            }
            // Walk the assoc's  (original) fkeys (apparently, the _artifact of
            // the ORDER-BY entry points to something in the view which does have all properties of the original
            // fkeys, so we need to dig up 'origin' ...)
            // Sanity check
            if (!orderByEntry.value._artifact._finalType || !orderByEntry.value._artifact._finalType.foreignKeys) {
              throw new Error("Expecting ORDER BY entry's artifact's _finalType to have foreign keys");
            }
            let foreignKeys = orderByEntry.value._artifact._finalType.foreignKeys;
            for (let foreignKeyName in foreignKeys) {
              let foreignKey = foreignKeys[foreignKeyName];
              // Sanity check
              if (!foreignKey.generatedFieldName) {
                throw new Error('Expecting generated field name for foreign key: ' + JSON.stringify(foreignKey));
              }
              // For each fkey, assemble a new ORDER BY entry that looks like one with the assoc, replacing the last path step
              let newPath = orderByEntry.value.path.slice(0, -1);
              newPath.push({
                id : foreignKey.generatedFieldName,
              });
              let newValue = Object.assign({}, orderByEntry.value, { path : newPath, element : foreignKey.generatedFieldName });
              result.push(Object.assign({}, orderByEntry, { value: newValue }));
              // FIXME: We don't bother to reconstruct _artifact links here (hopefully they won't be needed)
            }
          } else {
            // Not a formerly managed association - take as it is
            result.push(orderByEntry);
          }
        }
        query.orderBy = result;
      }
    }
  }

  // Generate all that is required in HANA CDS for draft enablement of 'artifact' into the model
  // (the artifact itself is not modified)
  function generateDraftForHana(artifact) {
    // Sanity check
    if (!artifact._service) {
      throw new Error('Expecting artifact to be part of a service: ' + JSON.stringify(artifact));
    }

    // FIXME: Current restriction: Must only have exactly one key, which is of type UUID
    let keyNames = Object.keys(artifact.elements).filter(elemName => {
      return artifact.elements[elemName].key && artifact.elements[elemName].key.val;
    });
    if (keyNames.length != 1) {
      signal(warning`"${artifact.name.absolute}": Ignoring annotation "@odata.draft.enabled" - currently only supported for artifacts with exactly one key of type "UUID"`, artifact.location);
      return;
    }
    let keyElem = artifact.elements[keyNames[0]];
    // Sanity check
    if (!keyElem._finalType) {
      throw new Error('Expecting artifact to have final type: ' + JSON.stringify(keyElem));
    }
    if (keyElem._finalType.name.absolute != 'cds.UUID') {
      signal(warning`"${artifact.name.absolute}": Ignoring annotation "@odata.draft.enabled" - currently only supported for key of type "UUID"`, keyElem.location);
      return;
    }

    // Generate the DraftAdministrativeData projection into the service, unless there is already one
    let draftAdminDataProjectionName = artifact._service.name.absolute + '.' + 'DraftAdministrativeData';
    let draftAdminDataProjection = model.definitions[draftAdminDataProjectionName];
    if (!draftAdminDataProjection) {
      draftAdminDataProjection = createAndAddDraftAdminDataProjection(artifact._service);
    }
    // Barf if it is not an entity or not what we expect
    if (draftAdminDataProjection.kind != 'entity' || !draftAdminDataProjection.elements['DraftUUID']) {
      signal(error`Generated entity "${draftAdminDataProjectionName}" conflicts with existing artifact`, draftAdminDataProjection.location);
    }

    // Duplicate the artifact as a draft shadow entity
    let draftsArtifactName = artifact.name.absolute + '_drafts';
    if (model.definitions[draftsArtifactName]) {
      signal(error`"${draftsArtifactName}": Generated entity name conflicts with existing entity`, model.definitions[draftsArtifactName].location);
      return;
    }
    let draftsArtifact = {
      name: {
        path: [
          { id: draftsArtifactName },
        ],
        id : artifact.name.id + '_drafts',
        absolute: draftsArtifactName,
      },
      kind: 'entity',
      elements: Object.create(null),
    };
    setProp(draftsArtifact, '_service', artifact._service);
    setProp(draftsArtifact, '_finalType', draftsArtifact);
    // Copy all elements
    for (let elemName in artifact.elements) {
      let elem = copyAndAddElement(artifact.elements[elemName], draftsArtifact, elemName);
      // explicitly set nullable if not key and not unmanaged association
      if ((!elem.key || !elem.key.val) && !elem.onCond) {
        elem.notNull = {
          val: false,
        }
      }
    }

    // Generate the additional elements into the draft-enabled artifact

    // key IsActiveEntity : Boolean default true
    let isActiveEntity = createScalarElement('IsActiveEntity', 'cds.Boolean', false);
    addElement(isActiveEntity, draftsArtifact);

    // HasActiveEntity : Boolean default false
    let hasActiveEntity = createScalarElement('HasActiveEntity', 'cds.Boolean', false);
    addElement(hasActiveEntity, draftsArtifact);

    // HasDraftEntity : Boolean default false;
    let hasDraftEntity = createScalarElement('HasDraftEntity', 'cds.Boolean', false);
    addElement(hasDraftEntity, draftsArtifact);

    // DraftAdministrativeData : Association to one DraftAdministrativeData not null;
    let draftAdministrativeData = createAssociationElement('DraftAdministrativeData', draftAdminDataProjection, true);
    draftAdministrativeData.cardinality = {
      targetMax: {
        literal: 'number',
        val: 1,
      },
    };
    draftAdministrativeData.notNull = {
      val: true,
    }
    addElement(draftAdministrativeData, draftsArtifact);

    // Add to model
    model.definitions[draftsArtifactName] = draftsArtifact;
  }
}

module.exports = {
  transformForHana
};
