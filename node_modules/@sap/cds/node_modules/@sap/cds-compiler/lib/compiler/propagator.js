//

'use strict';

const { forEachDefinition, forEachMember, setProp }
      = require( '../base/model');
var { linkToOrigin, withAssociation } = require('./shared');
// const { refString } = require( '../base/messages')

function propagate( model ) {
  const props = {
    '@com.sap.gtt.core.CoreModel.Indexable': never,
    '@cds.persistence.exists': never,
    '@cds.persistence.table': never,
    '@': annotation,            // always except in 'returns' and 'items'
    default: always,
    virtual: notViaType,
    notNull,                    // a variant of notViaType()
    targetElement: onlyViaParent,
    value: onlyViaParent,      // enum symbol value
    // masked: special = done in definer
    // key: special = done in resolver
    // actions: struct includes & primary source - TODO: do in definer/resolver
    // params/returns
    type: always,
    length: always,
    precision: always,
    scale: always,
    localized: always,
    target: always,
    cardinality: always,
    onCond: always,             // is expensive, but often rewritten - TODO: on
    on: ( prop, target, source ) => { target[prop] = source[prop]; }, // TODO: get rid of this soon!
    foreignKeys: expensive,
    items,
    elements: expensive,
    enum: expensive,
    params: expensive,
    returns,
  };

  forEachDefinition( model, run );
  return model;

  function run( art ) {
    if (!art)
      return;
    if (!checkAndSetStatus( art )) {
      if ( art.status !== 'propagated')
        runMembers( art );
      return;
    }
    // console.log('RUN:',refString(art), art.elements ? Object.keys(art.elements) : 0)
    let chain = [];
    let target = art;
    let source = getOrigin( target );
    while (source && checkAndSetStatus( source )) {
      chain.push({ target, source });
      target = source;
      source = getOrigin( target );
    }
    if (source) {               // the source has fully propagated properties
      step({ target, source });
    }
    else if (target._main) {    // source is element, which has not inherited props yet
      run( target._main )       // run on main artifact first
    }
    else if (target.includes) {
      let targets = [ target ];
      while (targets.length) {
        let news = [];
        for (let t of targets) {
          for (let ref of t.includes || []) {
            let s = ref._artifact;
            if (!s)          // ref error
              continue;
            chain.push( { target: t, source: s } );
            if (checkAndSetStatus( s ))
              news.push( s );
          }
        }
        targets = news;
      }
    }
    chain.reverse().forEach( step );
    runMembers( art );
    // console.log('DONE:',refString(art), art.elements ? Object.keys(art.elements) : 0)
  }

  function runMembers( art ) {
    // console.log('MEMBERS:',refString(art), art.elements ? Object.keys(art.elements) : 0)
    forEachMember( art, run ); // after propagation in parent!
    let obj = art;
    if (art.returns) {
      obj = art.returns;
      run( obj );
    }
    if (obj.items)
      run( obj.items );
    setProp( art, '_status', 'propagated' );
  }

  function step({ target, source }) {
    // console.log('PROPS:',source&&refString(source),'->',refString(target))
    let viaType = target.type && !target.type.$inferred;
    let keys = Object.keys( source );
    for (let prop of keys) {
      if (prop in target)       // TODO: warning with competing props from multi-includes
        continue;
      let transformer = props[prop] || props[prop.charAt(0)];
      if (transformer)
        transformer( prop, target, source, viaType );
    }
    // propagate NOT NULL and VIRTUAL from sub elements:
    if (target.$inferred !== 'proxy' &&
        target.kind === 'element' && source.kind === 'element') {
      let elem = source;        // the outer element
      while (elem._parent.kind === 'element')
        elem = elem._parent;
      if (elem !== source) {
        if (!('notNull' in target) && ('notNull' in elem))
          props.notNull( 'notNull', target, elem );
        if (!('virtual' in target) && ('virtual' in elem))
          props.virtual( 'virtual', target, elem );
      }
    }
    //setProp( target, '_status', 'shallow-propagated' );
  }

  function never () {}

  function always( prop, target, source ) {
    target[prop] = Object.assign( { $inferred: 'prop' }, source[prop] );
    if ('_artifact' in source[prop])
      setProp( target[prop], '_artifact', source[prop]._artifact );
  }

  // Expensive properties are not really propagated if they can be directly
  // accessed at their _finalType being a main artifact
  // (TODO: improve for type T: OtherStruct.elem; )
  // This should be adapted if elements of referred types can be annotated
  // (i.e. check whether there are annotations on it)
  function expensive( prop, target, source ) {
    if (target._finalType && !target._finalType._main)
      return;
    let location = target.type && !target.type.$inferred && target.type.location
                || target.location;
    let dict = source[prop];
    for (let name in dict) {
      let member = linkToOrigin( dict[name], name, target, prop, location );
      member.$inferred = 'proxy';
      if ('_finalType' in dict[name])
        setProp( member, '_finalType', dict[name]._finalType);
    }
  }

  function notViaType( prop, target, source, viaType ) {
    if (!viaType)
      always( prop, target, source );
  }

  function onlyViaParent( prop, target, source ) {
    if (target.$inferred === 'proxy')
      always( prop, target, source );
  }

  function annotation( prop, target, source ) {
    if (!target._outer)         // not in 'returns' and 'items'
      always( prop, target, source );
  }

  function notNull( prop, target, source, viaType ) {
    // TODO: also if we access sub element - set in definer/resolver
    if (!(viaType || target.value && withAssociation( target.value, targetMinZero )))
      always( prop, target, source );
  }

  function returns( prop, target, source, ok ) {
    // TODO: remove returns in XSN
    if (ok || target.$inferred === 'proxy' || target.$inferred === 'include' ) {
      let origin = {};
      target[prop] = { $inferred: 'proxy', origin };
      setProp( origin, '_artifact', source[prop] );
      setProp( target[prop], '_outer', target._outer || target ); // for setMemberParent
    }
  }

  function items( prop, target, source ) {
    if (!target._finalType || target._finalType._main)
      returns( prop, target, source, true );
  }
}

function targetMinZero( art ) {
  // Semantics of associations without provided cardinality: [*,0..1]
  return !(art.cardinality && art.cardinality.targetMin && art.cardinality.targetMin.val);
}

function getOrigin( art ) {
  if (art.$from && art.$from.length) { // query
    let tabref = art.$from[0]._artifact;
    return (tabref && tabref.kind === 'element')
      ? tabref._finalType && tabref._finalType.target
      : tabref;
  }
  else {
    return (art.type && !art.type.$inferred)
      ? art.type._artifact
      : art.origin && art.origin._artifact;
  }
}

function checkAndSetStatus( art ) {
  if (art._status === 'propagated' || art._status === 'propagating')
    return false;
  setProp( art, '_status', 'propagating' );
  return true;
}

module.exports = {
  propagate,
};
