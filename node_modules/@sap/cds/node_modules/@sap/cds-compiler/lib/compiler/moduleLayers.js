// Module handling, layers and packages

'use strict';

const detectCycles = require('./cycle-detector');

function setLayers( sources, filenames ) {
  let fname = filenames.find( name => !name.endsWith( '.properties' ) );
  let representative = fname && sources[fname];
  // set dependencies
  let srcs = Object.create(null);
  let annofiles = [];
  for (let name in sources) {
    let ast = sources[name];
    ast.realname = name;
    if (representative && name.endsWith( '.properties' )) {
      annofiles.push( ast );
      continue;
    }
    srcs[name] = ast;
    setProp( ast, '_deps', [] );
    for (let d of ast.dependencies || []) {
      let art = sources[ d.realname ];
      if (art)
        ast._deps.push( { art } );
    }
  }
  detectCycles( srcs, null, setExtends );
  for (let ast of annofiles)
    setProp( ast, '_layerRepresentative', representative._layerRepresentative );
}

// it is ensured that the representative is called last in SCC and that
// dependent SCCs are called first
function setExtends( node, representative, sccDeps = Object.create(null) ) {
  setProp( node, '_layerRepresentative', representative );
  for (let dep of node._deps) {
    if (dep.art._scc.lowlink !== node._scc.lowlink) { // not in same SCC
      let depRepr = dep.art._layerRepresentative;
      sccDeps[ depRepr.realname ] = depRepr;
    }
  }
  if (node === representative) {
    let exts = Object.keys( sccDeps ).map( name => sccDeps[name]._layerExtends );
    Object.assign( sccDeps, ...exts );
    setProp( representative, '_layerExtends', sccDeps );
    // console.log ('SCC:', node.realname)
  }
  return sccDeps;
}

function layer( art ) {
  while (art && art.kind !== 'source')
    art = art._block;
  return art && art._layerRepresentative;
}

// Like `obj.prop = value`, but not contained in JSON / CSN
function setProp ( obj, prop, value ) {
  Object.defineProperty( obj, prop, { value, configurable: true, writable: true } );
  return value;
}

module.exports = {
  setLayers,
  layer,
}
