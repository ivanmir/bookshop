// Compiler phase "resolve": resolve all references

// The resolve phase tries to find the artifacs (and elements) for all
// references in the augmented CSN.  If there are unresolved references, this
// compiler phase fails with an error containing a vector of corresponding
// messages (alternatively, we could just store this vector in the CSN).

// References are resolved according to the scoping rules of CDS specification.
// That means, the first name of a reference path is not only searched in the
// current environments, but also in the parent environments, with the source
// as second-last, and the environment for builtins as the last search
// environment.

// For all type references, we set the properties `type.absolute` and
// `type._artifact`, the latter is the actual type definition.

// If the referred type definition has a `parameters` property, we use it to
// transform the `typeArguments` property (sibling to the `type` property`) to
// named properties.  See function `resolveTypeWithArguments` below for details.

// Example 'file.cds' (see './definer.js' for the CSN before "resolve"):
//   type C { elem: String(4); }
//
// The corresponding definition of element "elem" looks as follows:
//   {
//     kind: 'element',
//     name: { id: 'elem', component: 'elem', location: ... }
//     type: { absolute: 'cds.String', _artifact: {...}, path: ...},
//     length: { val: 4, location: <of the number literal> },
//     location: ..., _parent: ...
//   }

// Future sequence (currently, 1 and 3 are mixed):
//  1. Resolve "element building" constructs: calculate main query elements
//  2. Add implicit foreign keys
//  3. Resolve the rest: ON, WHERE, ..., resolve non-FROM subqueries, rewrite
//     associations, ...

'use strict';

const { kindProperties, queryOps, setProp, forEachDefinition, forEachMember, forEachGeneric, forEachInOrder }
      = require('../base/model');
var { addToDict, addToDictWithIndexNo, clearDict, dictLocation }
    = require('../base/dictionaries');
const { msgName, getMessageFunction } = require('../base/messages');

var detectCycles = require('./cycle-detector');
const layers = require('./moduleLayers');

var { fns, linkToOrigin, setMemberParent, withAssociation, storeExtension }
    = require('./shared');

const undefinedArtifact = { kind: 'undefined', name: { absolute: ".<unknown>." } };

const annotationPriorities = { define: 1, extend: 2, annotate: 2, edmx: 3, i18n: 4 };


// Export function of this file.  Resolve type references in augmented CSN
// `model`.  If the model has a property argument `messages`, do not throw
// exception in case of an error, but push the corresponding error object to
// that property (should be a vector).
function resolve( model, options = model.options || {} ) {
  // Get shared "resolve" functionality and the message function:
  const { resolvePath, defineAnnotations }
        = fns( model, environment );
  const message = getMessageFunction( model );
  var implicitForeignKeys = [];
  return main();

  function main() {
    // --- sub phase 1: check paths in usings ---
    for (let name in model.sources) {
      let source = model.sources[name];
      resolveUsings( source.usings );
    }
    // --- sub phase 2: calculate/init view elements ---
    forEachDefinition( model, resolveView );
    // resolve all artifacts:
    forEachDefinition( model, resolveRefs );
    // adding implicit keys must be delayed due to projections (elements are calculated later)
    implicitForeignKeys.forEach( addImplicitForeignKeys );

    detectCycles( model.definitions, function( art, location ) {
      if (location) {
        message( 'ref-cyclic', location, { art }, 'Error', {
          std:  'Illegal circular reference to $(ART)',
          elem: 'Illegal circular reference to element $(ELEM) of $(ART)'
        });
      }
    });

    if (model.extensions)
      model.extensions.map( annotateUnknown );
    return model;
  }
  // TODO: have $applied/$extension/$status on extension with the following values
  //  - 'unknown': artifact to extend/annotate is not defined or contains unknown member
  //  - 'referred': contains annotation for element of referred type (not yet supported)
  //  - 'inferred': only contains extension for known member, but some inferred ones
  //    (inferred = elements from structure includes, query elements)
  //  - 'original': only contains extensions on non-inferred members

  // Resolve all references in artifact or element `art`.  Do so recursively in
  // all sub elements.
  function resolveRefs( art ) {
    // console.log( 'RESOLVE:', art.kind, refString(art.name) );
    if (!art._deps)
      setProp( art, '_deps', [] );
    if (art.$tableAliases && !art._$next) // TODO: in definer - yes, with param support
      setProp( art, '_$next', model.$magicVariables );
    if (art.key && !art.key.$inferred && art._parent &&
        !['entity', 'view', 'query'].includes( art._parent.kind ))
      message( 'unexpected-key', art.key.location, {},
               'Warning', 'KEY is only supported for elements in an entity or view' );

    let thing = art.returns || art;
    let obj = thing.items || thing; // the object which has type properties
    //console.log(art.name, art._block, obj)
    if (obj.type)
      resolveTypeWithArguments( obj, art, art._block );
    if (obj.target) {
      resolvePath( obj.target, 'target', art, art._block );
      if (obj.onCond) {
        if (!art._parent || !art._parent.elements) {
          message( 'assoc-as-type', obj.onCond.location, {},
                   ['Error'], 'An unmanaged association cannot be defined as type' );
          // TODO: also warning if inside structure
        }
        else if (!obj.onCond.$inferred) {
          // TODO: when used for mixin def: use query.$combined (currently extra)
          // TODO: provide "expected" special for on condition of association
          resolveExpr( obj.onCond, 'expr', art, art._main, environment( art._parent ), art._block );
        }
      }
      else if (!obj.foreignKeys && !obj.redirected && obj.target._artifact)
        implicitForeignKeys.push( art );
    }
    if (art.targetElement) {    // in foreign keys
      let target = art._parent && art._parent.target;
      if (target && target._artifact) {
        // we just look in target for the path
        // TODO: also check that we do not follow associations?
        resolvePath( art.targetElement, 'element', art,
                     { $msg: target._artifact }, environment( target._artifact ) );
      }
    }
    // Resolve projections/views
    if (art.$from)
      resolveView( art );
    if (obj.type || obj.origin || obj.value && obj.value.path || obj.elements) // typed artifacts
      finalType(obj);  // set _finalType if appropriate, (future?): copy elems if extended
    if (thing.items)
      setProp( thing, '_finalType', thing );

    if (obj.elements)           // silent dependencies
      forEachGeneric( obj, 'elements', elem => { art._deps.push( { art: elem } ) } );
    if (obj.foreignKeys)        // silent dependencies
      forEachGeneric( obj, 'foreignKeys', elem => { art._deps.push( { art: elem } ) } );

    if (art.default)
      resolveExpr( art.default, 'const', art, art._main, environment( art._parent ), art._block )

    annotateMembers( art );
    for (let prop in art) {
      if (prop.charAt(0) === '@')
        chooseAssignment( prop, art );
    }

    resolveTechnicalConfig( art );

    forEachMember( art, resolveRefs );
  }

  function annotateUnknown ( ext ) {
    if (ext.$extension)         // extension for known artifact -> already applied
      return;
    annotateMembers( ext );
    for (let prop in ext) {
      if (prop.charAt(0) === '@')
        chooseAssignment( prop, ext );
    }
  }

  // resolve all paths inside a technical configuration
  function resolveTechnicalConfig( art ) {
    // user required? works only with extDict = art.elements is that so?
    let tc = art.technicalConfig;
    if (!tc)
      return;
    if (!options.hanaFlavor && !options.betaMode && tc.location) {
      message( null, tc.location, {}, 'Error',
               'TECHNICAL CONFIGURATION is not supported yet' );
    }

    // secondary and fulltext indexes
    forEachGeneric( tc, 'indexes', (index) => {
      index.columns.forEach( col => {
        resolvePath( col, 'element', undefined, {}, art.elements );
      });
      if (index.language)
        resolvePath( index.language.column, 'element', undefined, {}, art.elements );
      resolvePath( index.mimeTypeColumn, 'element', undefined, {}, art.elements );
    });
    // fuzzy indexes
    if (tc.fzindexes)
      tc.fzindexes.forEach( i => {
        i.columns.forEach(c => {
          resolvePath( c, 'element', undefined, {}, art.elements )
        });
      });
    // partition expressions
    if (tc.partition) {
      tc.partition.specs.forEach( s => {
        s.columns && s.columns.forEach( p => {
          resolvePath( p, 'element', undefined, {}, art.elements)
        })
      })
    }
  }

  // Return effective search environment provided by artifact `art`, i.e. the
  // `artifacts` or `elements` dictionary.  For the latter, follow the `type`
  // chain and resolve the association `target`.
  function environment( art ) {
    if (!art)
      return Object.create(null);
    if (art.artifacts)
      return art.artifacts;
    let type = finalType(art);
    if (type.target)
      type = resolvePath( type.target, 'target', type, type._block ) || {};
    if (type.$from)
      resolveView( type, true );
    return type.elements || Object.create(null);
  }

  function directType( art ) {
    // only used with !art.target && !art.enum ! (and !art.elements)
    if (art.origin)
      return art.origin._artifact;
    if (art.type)
      return resolveType( art.type, art, art._block );
    // console.log( 'EXPR-IN', art.kind, refString(art.name) )
    let query = art._parent && art._parent._leadingQuery || art._parent;
    // console.log( 'EXPR-QUERY', query.kind, refString(query.name) )
    if (query && query.kind === 'query') {
      resolveExpr( art.value, 'expr', art, query, query.$combined, art._block );
      // console.log( 'EXPR-OUT', art.value._artifact.kind, refString(art.value._artifact.name) );
      return art.value._artifact;
    }
    // TODO: calculated fields in general, inline select item def (expand)
    return undefined;
  }

  // Follow the `type` chain, i.e. derived types and TYPE OF, stop just before
  // built-in types (otherwise, we would loose type parameters).  Return that
  // type and set it as property `_finalType` on all artifacts on the chain.
  function finalType( art ) {
    // TODO: resolvePath( origin ) should be part of this
    if (art._finalType)
      return art._finalType;

    var chain = [];
    while (art && !art._finalType && (art.type || art.origin || art.value && art.value.path) && !art.target && !art.enum) {
      chain.push( art );
      setProp( art, '_finalType', undefinedArtifact ); // initial setting in case of cycles
      art = directType( art );
    }
    if (!art || art._finalType === undefinedArtifact)
      return undefinedArtifact; // undefined or in cycle

    if (art.builtin && chain.length) {
      let builtin = art;
      art = chain.pop();
      if (art.length || art.precision || art.scale || art.typeArguments) // TODO: move to above like art.target
        setProp( art, '_finalType', art );
      else {
        setProp( art, '_finalType', builtin );
        art = builtin;
      }
    }
    else if (art._finalType) {
      art = art._finalType;
    }
    else {
      setProp( art, '_finalType', art );
    }
    for (let a of chain) {
      // TODO: we had (git tag 'nr-hana') an auto expansion of referred
      // structure types if there existed an annotation assignment for elements
      // of that referred type.  This is not such a good idea since later
      // annotation would not have this effect.  It is better to provide an
      // compiler option --expand-structures which would always expand referred
      // structure types.
      setProp( a, '_finalType', art );
    }
    return art;
  }

  function extensionFor( art ) {
    if (art.kind === 'annotate')
      return art;
    if (art._extension)
      return art._extension;

    // $extension means: already applied
    let ext = {
      kind: art.kind,           // set kind for setMemberParent()
      $extension: 'exists',
      location: art.location    // location( extension to existing art ) = location(art)
    };
    let location = art.name.location;
    if (!art._main) {
      ext.name = {
        path: [ { id: art.name.absolute, location } ],
        location,
        absolute: art.name.absolute
      }
      model.extensions ? model.extensions.push(ext) : model.extensions = [ext];
    }
    else {
      ext.name = { id: art.name.id, location };
      let parent = extensionFor( art._parent );
      let kind = kindProperties[ art.kind ].normalized || art.kind;
      if ( parent[ kindProperties[ kind ].dict ] &&
           parent[ kindProperties[ kind ].dict ][art.name.id] )
        throw new Error(art.name.id);
      setMemberParent( ext, art.name.id, parent, kindProperties[ kind ].dict );
    }
    ext.kind = 'annotate';    // after setMemberParent()!
    setProp( art, '_extension', ext );
    setProp( ext.name, '_artifact', art );
    return ext;
  }

  function annotateMembers( art, extensions = [], prop, name, parent, kind ) {
    let severity = !art && parent && parent.kind !== 'annotate' &&
        (art === null ? 'Error' : 'Info');
    if (!art && extensions.length && severity !== 'Error') {
      let parentExt = extensionFor(parent);
      art = parentExt[prop] && parentExt[prop][name];
      if (!art) {
        art = {
          kind,                 // for setMemberParent()
          name: { id: name, location: extensions[0].name.location },
          location: extensions[0].location
        };
        setMemberParent( art, name, extensionFor(parent), prop );
        art.kind = 'annotate';  // after setMemberParent()!
      }
    }

    for (let ext of extensions) {
      if ('_artifact' in ext.name) // already applied
        continue;
      setProp( ext.name, '_artifact', art );

      if (art) {
        defineAnnotations( ext, art, ext._block, ext.kind );
        forEachMember( ext, function init( elem, name, prop ) {
          storeExtension ( elem, name, prop, art, ext._block );
        });
      }
      if (severity) {
        // TODO: use some more generic resolveMember() function - in shared.js,
        // TODO: proper use of message()
        // TODO: message more like `"${parent.name.absolute}" cannot have elements`
        if (prop === 'elements' || prop === 'enum')
          message( null, ext.name.location,
                   art === null
                   ? `No elements or enums have been found in "${parent.name.absolute}"`
                   : (parent.elements)
                   ? `Element "${name}" has not been found in "${parent.name.absolute}"`
                   : `Enum symbol "${name}" has not been found in "${parent.name.absolute}"`,
                   severity )
        else if (prop === 'actions')
          message( null, ext.name.location,
                   art === null
                   ? `No action has been found in "${parent.name.absolute}"`
                   : `Action "${name}" has not been found in "${parent.name.absolute}"`,
                   severity );
        else
          message( null, ext.name.location,
                   art === null
                   ? `No parameter has been found in "${parent.name.absolute}"`
                   : `Parameter "${name}" has not been found in "${parent.name.absolute}"`,
                   severity );
      }
    }
    if (art) {
      let obj = art.returns || art; // why the extra `returns` for actions?
      obj = obj.items || obj;
      annotate( obj, 'element', 'elements', 'enum', art );
      annotate( art, 'action', 'actions' );
      annotate( art, 'param', 'params' );
    }
    return;

    function annotate( obj, kind, prop, altProp, parent = obj ) {
      let dict = art._annotate && art._annotate[prop];
      let env = obj[prop] || altProp && obj[altProp] || null;
      for (let name in dict) {
        annotateMembers( env && env[name], dict[name], prop, name, parent, kind );
      }
    }
  }

  function chooseAssignment( annoName, art ) {
    // TODO: getPath an all names
    let anno = art[annoName];
    if (!(anno instanceof Array)) // just one assignment -> use it
      return;
    // sort assignment according to layer
    let layerAnnos = Object.create(null);
    for (let a of anno) {
      let layer = layers.layer( a._block );
      let name = (layer) ? layer.realname : '';
      let done = layerAnnos[name];
      if (done)
        done.annos.push( a );
      else
        layerAnnos[name] = { layer, annos: [a] };
    }
    // collect assignments of upper layers (are in no _layerExtends)
    let exts = Object.keys( layerAnnos ).map( layerExtends );
    let allExtends = Object.assign( Object.create(null), ...exts );
    let collected = [];
    for (let name in layerAnnos) {
      if (!(name in allExtends))
        collected.push( prioritizedAnnos( layerAnnos[name].annos ) );
    }
    // inspect collected assignments - choose the one or signal error
    let justOnePerLayer = collected.every( annos => annos.length === 1);
    if (!justOnePerLayer || collected.length > 1) {
      for (let annos of collected) {
        for (let a of annos ) {
          message( 'anno-duplicate', a.name.location,
                   { anno: annoName, '#': justOnePerLayer && 'unrelated' },
                   ['Error'], {
                     std:       'Duplicate assignment with $(ANNO)',
                     // we could add USING...FROM between the unrelated layers:
                     unrelated: 'Duplicate assignment with $(ANNO) in unrelated layers'
                   });
        }
      }}
    art[annoName] = collected[0][0]; // just choose any one with error
    return;

    function layerExtends( name ) {
      let layer = layerAnnos[name].layer;
      return layer && layer._layerExtends;
    }
  }

  function prioritizedAnnos( annos ) {
    let prio = 0;
    let r = [];
    for (let a of annos) {
      let p = annotationPriorities[ a.priority ] || annotationPriorities[ 'define' ] ;
      if (p === prio)
        r.push(a);
      else if (p > prio)
        r = [a], prio = p;
    }
    return r;
  }


  function resolveType( ref, user, block ) {
    if (!ref.resolveSemantics)
      return resolvePath( ref, 'type', user, block );
    // currently just `typeOf`
    if (options.hanaFlavor && ref.path.length > 1)
      return resolvePath( ref, 'type', user, block );
    else if (user._parent && user._parent.elements)
      return resolvePath( ref, 'typeOf', user, user._main, user._parent.elements );
    message( 'ref-no-elements', ref.location, { art: user._parent || user },
             'Error', 'Artifact $(ART) has no elements' );
    return undefined;
  }

  // Resolve the type arguments provided with a type referenced for artifact or
  // element `art`.  This function does nothing if the referred type `typeArt`
  // does not have a `parameters` property (currently, only builtin-types have
  // it, see ./builtins.js).
  //
  // For each property name `<prop>` in `typeArt.parameters`, we move a number
  // in art.typeArguments (a vector of numbers with locations) to `art.<prop>`.
  // TODO: error if no parameters applicable
  function resolveTypeWithArguments( art, user, block ) {
    let typeArt = resolveType( art.type, user, block );
    if (!typeArt)
      return;
    var args = art.typeArguments || [];
    let parameters = typeArt.parameters || [];
    var parLength = parameters.length;

    for (let i = 0; i < parLength; ++i) {
      let par = parameters[i];
      if (!(par instanceof Object))
        par = { name: par };
      if (!art[ par.name ] && (i < args.length || par.literal))
        art[ par.name ] = args[i] || { literal: par.literal, val: par.val };
    }
    if (args.length > parLength) {
      art.typeArguments = art.typeArguments.slice(parLength);
      message( 'unexpected-type-arg', art.typeArguments[0].location, { art: typeArt },
               'Warning', 'Too many arguments for type $(ART)' );
    }
    else if (art.typeArguments)
      delete art.typeArguments;
  }

  function addImplicitForeignKeys( art ) {
    let obj = art;
    // TODO: currently assumes obj === art (array of association to ... does not exist)
    let target = obj.target._artifact;
    if (!target)                // no valid target
      return;
    forEachInOrder( target, 'elements', function( elem, name ) {
      if (elem.key && elem.key.val) {
        let location = obj.target.location;
        let key = {
          name: { location, id: elem.name.id, $inferred: 'keys' }, // more by setMemberParent()
          kind: 'key',
          targetElement: { path: [{ id: elem.name.id, location }], location },
          location,
          calculated: true,
          $inferred: 'keys'
        };
        setMemberParent( key, name, art, 'foreignKeys' );
        setProp( key.targetElement, '_artifact', elem );
        setProp( key.targetElement.path[0], '_artifact', elem );
        setProp( key, '_finalType', finalType(elem) );
        setProp( key, '_deps', [{ art: elem, location }] );
        art._deps.push( { art: key } );
      }
    });
    art.implicitForeignKeys = true;
  }

  function resolveView( art, onlyInit ) {
    if (!art.$from)
      return;
    var resolveChain = [];
    var fromChain = [art];
    while (fromChain.length) {
      let view = fromChain.pop();
      if (view._status === '_query') // already fully resolved (status at def)
        continue;
      resolveChain.push( view );
      for (let from of view.$from) {
        if (from._status)       // status at the ref -> illegal recursion -> stop
          continue;
        setProp( from, '_status', '_query' );
        let source = resolvePath( from, 'from', view, view._block );
        if (source && source.$from && source._status !== '_query')
          fromChain.push( source );
      }
    }
    for (let view of resolveChain.reverse()) {
      if (view._status === '_query' ) // already resolved
        continue;
      setProp( view, '_status', '_query' );
      // TODO $parameters: params (before $magicVariables)
      resolveQueryExpr( view.query, onlyInit || view !== art );
      inheritActions( view );
    }
    if (!resolveChain.length && !onlyInit)
      resolveQueryExpr( art.query );
  }

  function inheritActions( view ) {
    let primary = view.$from[0] && view.$from[0]._artifact;
    if (!primary || !primary.actions)
      return;
    let location = view.$from[0].location;
    let actions = view.actions || Object.create(null);
    clearDict( view, 'actions' );
    forEachGeneric( primary, 'actions', function( origin, id ) {
      let own = actions[id];
      if (!own) {
        let action = linkToOrigin( origin, id, view, 'actions', location );
        action.$inferred = 'proxy';
      }
      else if (!own.$inferred) {
        // TODO: or in-place if shadowed?  But the order is unimportant anyway...
        message( 'shadowed-action', own.name.location, { id, art: primary },
                 'Info', 'This definition shadows action $(ID) of $(ART)' );
      }
    });
    forEachGeneric( {actions}, 'actions', function( action, name ) {
      addToDictWithIndexNo( view, 'actions', name, action );
    });
  }

  function resolveQueryExpr( query, onlyInit ) {
    while (query instanceof Array) // query in parentheses
      query = query[0];
    if (!query)
      return;
    if (query.join) {
      for (let tab of query.args)
        resolveQueryExpr( tab, onlyInit );
      if (!onlyInit && query.on)
        resolveQuery( query, onlyInit );
    }
    else if (query.op && query.op.val === 'query') { // select
      for (let tab of query.from)
        resolveQueryExpr( tab, onlyInit );
      resolveQuery( query, onlyInit );
    }
    else if (query.args) {      // UNION, INTERSECT, ..., sub query
      for (let tab of query.args)
        resolveQueryExpr( tab, onlyInit );
    }
    // else: with parse error (`select from <EOF>`)
  }

  function resolveQuery( query, onlyInit ) {
    if (!query._$next)
      setProp( query, '_$next', model.$magicVariables );
    if (!query.$combined) {     // not already called with onlyInit
      query.$combined = Object.create(null);
      forEachGeneric( query, '$tableAliases', resolveTabRef);
      if (query.all)
        expandWildcard();
      forEachGeneric( { elements: query.elements }, 'elements', initElem );
    }
    if (!withKeyPropagation())
      forEachGeneric( { elements: query.elements }, 'elements', resetKey );
    if (onlyInit)
      return;

    forEachGeneric( query, '$tableAliases', resolveMixin);
    // A special order-by dictionary is only necessary if SELECT … ORDER BY, not … UNION … ORDER BY
    var dictOB = query.orderBy && Object.create(null);
    // TODO: name resolution for types etc in MIXIN definitions of subqueries?
    forEachGeneric( { elements: query.elements }, 'elements', resolveRedirected );
    forEachGeneric( { elements: query.elements }, 'elements', resolveElem );
    if (dictOB)
      query.$dictOrderBy = Object.assign( Object.create(null), query.$combined, dictOB );
    if (query.on)
      resolveExpr( query.on, 'expr', null, query, query.$combined, query._block );
    if (query.where)
      resolveExpr( query.where, 'expr', null, query, query.$combined, query._block );
    if (query.groupBy) {
      for (let gb of query.groupBy)
        resolveExpr( gb, 'expr', null, query, query.$combined, query._block );
    }
    resolveExpr( query.having, 'expr', null, query, query.$combined, query._block );
    resolveOrderBy();
    return;

    function withKeyPropagation() {
      let leading = query._leadingQuery || query;
      // Check that only one source, not navigating along to-many association:
      if (!leading.from || leading.from.length !== 1)
        return false;
      let from = leading.from[0]; // TODO: what about `union` - allow currently
      if (!from)                  // parse error SELECT FROM <EOF>
        return false;
      if (from.join)
        return false;
      if (from && from.path &&  // TODO: re-check sub query in FROM
          withAssociation( from, targetMaxNotOne, true ))
        return false;
      // Check that all keys from the source are projected:
      let navElems = leading._firstAliasInFrom && leading._firstAliasInFrom.$navigation;
      for (let name in navElems) {
        let nav = navElems[name];
        if (nav.key && nav.key.val && !(nav._projections && nav._projections.length))
          return false;
      }
      // Check that there is no to-many assoc used in select item:
      for (let name in leading.elements) {
        let elem = leading.elements[name];
        if (!elem.$inferred && elem.value &&
            testExpr( elem.value, r => withAssociation( r, targetMaxNotOne ), ()=>false ))
          return false;
      }
      return true;
    }

    function resetKey( elem ) {
      if (elem.key && elem.key.$inferred)
        elem.key.val = undefined; // not put into CSN (but keep it in XSN)
    }

    function initElem( elem ) {
      //if (elem.type) console.log(msgName(elem),elem)
      // TODO: make sure that EXTEND ENTITY cannot be used on view (only ad-hoc mixin)
      if (elem.type && !elem.type.$inferred && !elem.viaAll) {
        resolveTypeWithArguments( elem, elem, elem._block );
        return;
      }
      if (elem.viaAll || !elem.value || !elem.value.path)
        return;
      let origin = resolvePath( elem.value, 'expr', undefined,
                                query, query.$combined, elem._block );
      if (!origin)
        return;
      elem.origin = elem.value; // TODO: remove origin, make it a _origin = origin._artifact
      // now set things which are necessary for later sub phases:
      let navElem = pathNavigation( elem.value );
      let pathnav = navElem.element; // undefined for CURRENT_DATE
      if (!elem.key && pathnav && pathnav.key && !withAssociation( elem.value ))
        elem.key = Object.assign( { $inferred: 'query' }, pathnav.key );
      if (pathnav && navElem.item === elem.value.path[ elem.value.path.length-1 ])
        // we address the complete source element
        addProjection( elem, pathnav );
      //else if (pathnav) console.log('PATH:', elem.value.path, navElem.item)
    }

    function resolveRedirected( elem ) {
      if (!elem.target || elem.target.$inferred) // no REDIRECTED TO
        return;
      // console.log('REDIRECTED:',elem.target)
      let target = resolvePath( elem.target, 'target', elem, elem._block );
      setProp( elem, '_origTarget', undefined ); // null = do not touch path steps after assoc
      let assoc = elem.origin && elem.origin._artifact;
      if (!assoc) {
        if (!elem.value.path)
          message( 'redirected-no-assoc', elem.target.location, {},
                   'Error', 'Only associations can be redirected' );
        return;
      }
      let origType = finalType( assoc );
      if (!origType || !origType.target) {
        message( 'redirected-no-assoc', elem.target.location, {},
                 'Error', 'Only associations can be redirected' );
        return;
      }
      let origTarget = origType.target._artifact;
      if (!origTarget || !target)
        return;
      if (target === origTarget) {
        message( 'redirected-to-same', elem.target.location, { art: target },
                 'Info', 'The redirected target is the original $(ART)' );
        // TODO: set _origTarget or not?
        return;
      }
      // now check whether target and origTarget are "related"
      while (target.query) {
        let from = (target.query.args) ? [1,2] : target.query.from;
        if (!from || !from.length) // parse error
          return;
        if (from.length > 1 || !from[0].path) {
          message( 'redirected-to-complex', elem.target.location,
                   { art: target, '#': target === elem.target._artifact ? 'target' : 'std' },
                   'Warning', {
                     std: 'Redirection involves the complex view $(ART)',
                     target: 'The redirected target $(ART) is a complex view'
                   });
          break;
        }
        target = from[0]._artifact;
        if (!target)
          return;
        if (target === origTarget) {
          setProp( elem, '_origTarget', origTarget );
          return;
        }
      }
      let news = [[target]];
      let dict = Object.create(null);
      while (news.length) {
        let olds = [].concat( ...news );
        news = [];
        if (olds.some( findOrig ))
          return;
      }
      message( 'redirected-to-unrelated', elem.target.location, { art: origTarget },
               'Warning', 'The redirected target does not originate from $(ART)' );
      return;

      function findOrig( art ) {
        if (!art)             // some include ref or query source cannot be found
          return true;        // -> no further message
        if (art === origTarget) {
          setProp( elem, '_origTarget', origTarget );
          return true;
        }
        if (dict[art.name.absolute]) // already processed
          return false;
        dict[art.name.absolute] = true;

        if (art.includes)
          news.push( art.includes.map( r => r._artifact ) );

        let query = art._leadingQuery;
        if (!query)
          return false;
        else if (!query.$tableAliases) // something wrong with query
          return true;                 // -> no message about redirected target
        // With Node 7, we could do: Object.values(…).filter(…).map(…)
        let sources = [];
        for (let n in query.$tableAliases) {
          let a = query.$tableAliases[n];
          if (a.type && !a.self && !a.name.$mixin)
            sources.push( a.type._artifact );
        }
        news.push( sources );
        return false;
      }
    }

    function resolveElem( elem, name ) {
      rewriteAssociation( elem );
      if (elem.viaAll)
        return;
      if (dictOB)               // TODO: do NOT use "competing" aliases from extension (or complain about them)
        addToDict( dictOB, name, elem );
      elem.$inferred = 'query';
      // ony direct paths have been resolved so far (w/o explicit type), no expression:
      resolveExpr( elem.value, 'expr', elem, query, query.$combined, elem._block );
      finalType( elem );
    }

    function rewriteAssociation( elem ) {
      if (!options.betaMode && !options.newCsn)
        return;
      let assoc = elem.origin && elem.origin._artifact;
      if (!assoc || !finalType(assoc))
        return;                 // no direct path
      if (!assoc._finalType.target || !assoc._finalType.onCond)
        // no unmanaged association (later we need to check wheter it is a
        // struct containing an assoc = reject those, and also check managed
        // associations with redirected target)
        return;
      let pathnav = pathNavigation( elem.value );
      // console.log( 'ASSOC:', elem.value, pathnav )
      let nav = pathnav.element;
      if (!nav)                 // $projection, $magic, or future ref to const
        return;
      // Currently, having an unmanaged association inside a struct is not
      // supported by this function:
      if (nav !== assoc && nav.origin._artifact !== assoc) {
        // Currently no warning, as this is also true for "assoc1.assoc2",
        // warning only for "otherelem1.assoc2"
        // message( warning`Rewriting associations in a structure is not supported`, elem.value.location );
        return;
      }
      let target = elem.target && !elem.target.$inferred &&
          resolvePath( elem.target, 'target', elem, elem._block );
      if (target) {
        let from = target.query && target.query.from; // query entity (no assoc)
        // simple (no UNION), no JOINs, no subquery in FROM:
        target = from && from.length === 1 && from[0].path && from[0]._tableAlias;
        if (!target) {
          message( null, elem.target.location,
                   `Redirected target is no simple projection`,
                   'Error' );   // rewrite this function anyway
          return;
        }
        else if (assoc._finalType.target._artifact !== from[0]._artifact) {
          message( null, elem.target.location,
                   `The source of the redirected target is not the original target`,
                   'Warning' ); // rewrite this function anyway
          return;
        }
        // TODO: we might allow the following in the future
        //  - original target is just the indirect source of the new target
        //  
      }
      let cond = copyExpr( assoc._finalType.onCond );
      if (!pathnav.tableAlias)  // mixin
        resolveExpr( cond, rewriteExpr );
      else if (pathnav.tableAlias.type)
        resolveExpr( cond, rewriteExpr, elem, pathnav.tableAlias );
      else {
        // If we want to support that: make sure that ON condition of sub query
        // already had been rewritten
        message( null, elem.value.location,
                 `Selecting unmanaged associations from a sub query is not supported` );
      }
      cond.$inferred = 'rewrite';
      elem.onCond = cond;
      if (!elem.target) {
        environment( assoc ); // make sure that assoc._finalType.target._artifact exists
        elem.target = Object.assign( { $inferred: 'rewrite' }, assoc._finalType.target );
        // console.log('AFT:',assoc._finalType && assoc._finalType.name,assoc._finalType.target,assoc._finalType.target._artifact)
        setProp( elem.target, '_artifact', assoc._finalType.target._artifact );
      }
      setProp( elem, '_finalType', elem );
      // TODO: info message with more than one possibility
    }

    function addProjection( proj, nav ) {
      if (nav) {
        if (nav._projections)
          nav._projections.push( proj )
        else
          setProp( nav, '_projections', [proj] );
      }
    }

    function expandWildcard() {
      let elements = Object.assign( Object.create(null), query.elements );
      clearDict( query, 'elements', true );
      let exclude = query.exclude || Object.create(null);
      // TODO: paths in exclude? - Did I mention it? EXCLUDING is ill-defined...
      let location = query.all.location;
      for (let name in query.$combined) {
        let navElem = query.$combined[name];
        if (exclude[name] || navElem.masked && navElem.masked.val)
          continue;
        let selElem = elements[name];
        if (selElem && selElem.name) { // no name with parse error or repeated def
          let path = selElem.value && selElem.value.path;
          // TODO: to bring a message for ParentElem.Assoc, we should move this
          // check to resolveElem for elems with $replacement, by comparing the
          // name with the name.element of the _origin.
          // We cannot check path.length === 1, as we want to allow Alias.Elem.
          if (!selElem.redirected || path && path[ path.length-1 ].id !== selElem.name.id) {
            if (navElem instanceof Array)
              message( 'wildcard-excluding-many', selElem.name.location, { id: name },
                       'Info', 'This select item replaces $(ID) from two or more sources' );
            else
              message( 'wildcard-excluding-one', selElem.name.location,
                       { id: name, alias: navElem._parent.name.id },
                       'Info', 'This select item replaces $(ID) from table alias $(ALIAS)' );
          }
          selElem.$replacement = true;
          addToDictWithIndexNo( query, 'elements', name, selElem );
        }
        else if (navElem instanceof Array) {
          message( 'wildcard-ambiguous', location, { id: name },
                   'Error', 'Ambiguous, select $(ID) explicitly with table alias' );
        }
        else {
          let origin = navElem.origin._artifact;
          let elem = linkToOrigin( origin, name, query, 'elements', location );
          elem.$inferred = '*';
          elem.name.$inferred = '*';
          elem.name.calculated = true;
          let aliasObj = navElem._parent;
          let aliasStep = { id: aliasObj.name.id, location };
          let step = { id: name, location };
          elem.value = elem.origin;
          // always expand * to path with table alias (reason: columns current_date etc)
          elem.value.path = [ aliasStep, step ];
          let real = aliasObj.origin || aliasObj.type; // is undefined for sub query
          setProp( aliasStep, '_artifact', real && real._artifact || aliasObj );
          setProp( aliasStep, '_navigation', aliasObj );
          setProp( step, '_artifact', origin );
          setProp( step, '_navigation', navElem ); // TODO: really set this?
          addProjection( elem, navElem );
          elem.viaAll = true;
          if (origin.key && aliasObj === aliasObj._parent._firstAliasInFrom)
            elem.key = Object.assign( { $inferred: '*' }, origin.key );
          // TODO: _finalType?
        }
      }
      forEachInOrder( { elements }, 'elements', function (elem, name) {
        if (!elem.$replacement)
          addToDictWithIndexNo( query, 'elements', name, elem );
      });
    }

    // Note the strange name resolution (dynamic part) for ORDER BY: the same
    // as for select items if it is an expression, but first look at select
    // item alias (i.e. like `$projection.NAME` if it is a path.  If it is an
    // ORDER BY of an UNION, do not allow any dynamic path in an expression,
    // and only allow the eements of the leading query if it is a path.
    //
    // This seem to be similar, but different in SQLite 3.22.0: ORDER BY seems
    // to bind stronger than UNION (see <SQLite>/src/parse.y), and the name
    // resolution seems to use select item aliases from all SELECTs of the
    // UNION (see <SQLite>/test/tkt2822.test).
    function resolveOrderBy() {
      if (query.$orderBy || query.orderBy) {
        let leading = query._leadingQuery || query; // TODO: query is always the leading here
        let emptyDict = Object.create(null);
        // TOOD: handle query.orderBy and query.$orderBy extra - then we have no need for _$queryNode
        for (let ob of [...query.$orderBy||[], ...query.orderBy||[] ]) {
          resolveExpr( ob.value, 'expr', null, leading,
                       (ob.value && ob.value.path)
                       ? (ob._$queryNode ? leading.elements : leading.$dictOrderBy)
                       : (ob._$queryNode ? emptyDict : leading.$combined ),
                       leading._block );
        }
      }
    }

    function resolveMixin( alias ) {
      if (alias.kind === 'element') { // TODO: use resolveRefs( alias ), but beware $self
        let main = query._main;
        if (alias.type)
          resolveTypeWithArguments( alias, main, main._block );
        if (alias.target) {
          resolvePath( alias.target, 'target', main, main._block );
          // TODO: disallow foreign keys, resolve ON, but but beware $self
          if (alias.onCond)
            resolveExpr( alias.onCond, 'expr', alias, query, query.$combined, main._block );
          else
            message( 'assoc-in-mixin', alias.target.location, {},
                     'Error', 'Managed associations are not allowed for MIXIN elements' );
        }
      }
      // TODO: handle MIXIN defs which look like name = value
    }

    function resolveTabRef( alias ) {
      if (alias.kind === 'element' || alias.self) // mixin element or $projection
        return;
      if (!alias.$navigation) {
        let main = query._main;
        // if (main._block.$frontend!=='json') console.log('TABREF:',alias.name,main,main._block)
        let tab = resolvePath( alias.type, 'from', main, main._block );
        for (let step of tab && alias.type.path || []) {
          if (!step._artifact)
            break;
          if (step.namedArgs) {
            if (!options.betaMode && !options.hanaFlavor)
              message( null, dictLocation( step.namedArgs ), {},
                       'Error', 'View arguments are not supported yet' );
            resolveParams( step.namedArgs, step._artifact, main._block ); // block for future :const
          }
          if (step.where)    // TODO: support for $projection, $parameters, ...?
            resolveExpr( step.where, 'element', null, {},
                         environment( step._artifact ), main._block );
        }
        let isPrimaryAlias = alias === alias._parent._firstAliasInFrom;
        let elements = alias.elements || environment(tab); // sub query or table ref
        forEachGeneric( { elements }, 'elements', function( origin, name ) {
          let elem = linkToOrigin( origin, name, alias, '$navigation',
                                   (tab||origin).name.location );
          elem.kind = '$navElement';
          // setProp( elem, '_fromAlias', alias );  same as _parent
          setProp( elem, '_finalType', finalType(origin) );
          // elem.name.query = query.name.query; 
          if (origin.key && isPrimaryAlias)
            elem.key = Object.assign( { $inferred: 'nav' }, origin.key );
          if (origin.masked)
            elem.masked = Object.assign( { $inferred: 'nav' }, origin.masked );
        });
      }
      forEachGeneric( { elements: alias.$navigation }, 'elements', function( elem, name ) {
        addToDict( query.$combined, name, elem );
      });
    }
  }

  // Resolve the using declarations in `using`.  If not compiled with lint-mode
  // or if it is a reference for a builtin (path starts with `cds`), issue
  // error message if the referenced artifact does not exist.
  function resolveUsings( usings ) {
    if (!usings)
      return;
    for (let def of usings) {
      if (def.usings)           // using {...}
        resolveUsings( def.usings );
      if (!def.name)            // using {...} or parse error
        continue;
      let art = model.definitions[ def.name.absolute ];
      if (art instanceof Array)
        continue;
      let location = def.extern.location;
      // TODO: try to find better position - and set valid names
      setProp( def, '_deps', (art) ? [{ art, location }] : [] );
      if (!art &&
          (!model.options || !model.options.lintMode ||
           def.extern.path && def.extern.path[0] && def.extern.path[0].id == 'cds')) {
          // even with lint-mode, we complain about undefined "cds.*"
        message( 'ref-undefined-art', location, { art: def.name },
                 'Error', 'Artifact $(ART) has not been found' );
      }
    }
  }

  function rewriteExpr( expr, user, tableAlias ) {
    let pathnav = (tableAlias)
                ? sourceNavigation( expr, tableAlias ) // in ON of query source element
                : pathNavigation( expr );              // in ON of mixin element
    let nav = pathnav.element;
    if (!nav) {
      if (!pathnav.item)        // not $projection (only from mixin)
        return;
      if (expr.path.length > 1 && expr.path[1].id.charAt(0) !== '$') {
        // some backends have problems with $self -> delete it if unnecessary
        expr.path.shift();
      }
      else {
        // console.log('SELF:',pathnav,tableAlias)
        pathnav.item.id = '$self';
        delete pathnav.item._navigation;
        if (tableAlias) {       // comparison with $self -> semantics to define
          message( null, user && user.value && user.value.location || pathnav.item.location,
                   `Association ${msgName( user.name.element )} has inferred ON condition with unclear $self comparison`,
                   'Info' );
        }
      }
      return;
    }
    // console.log( 'REWRITE: ', expr.path )
    if (!nav._projections) {
      message( null, user && user.value && user.value.location || pathnav.item.location,
               `Projected association uses non-projected element "${nav.name.id}"` );
      return;
    }
    let elem = nav._projections[0]; // TODO: info with more than one
    let step = pathnav.item;
    step.id = elem.name.id;
    setProp( step, '_artifact', elem );
    let root = expr.path[0];
    if (root !== step) {        // we have used tabAlias.elem, $self/$projection.elem
      if (step.id.charAt(0) !== '$') {
        // some backends have problems with $self -> delete it if unnecessary
        expr.path.shift();
      }
      else {
        root.id = '$self';
        setProp( root, '_artifact', pathnav.tableAlias._parent ); // set to query
        delete pathnav.item._navigation;
      }
    }
  }

  function pathNavigation( ref ) {
     // currently, indirectly projectable elements are not included - we might
    // keep it this way!  If we want them to be included - be aware: cycles
    let item = ref.path && ref.path[0];
    let root = item && item._navigation;
    if (!root)
      return {};
    if (root.kind === '$navElement')
      return { element: root, item, tableAlias: root._parent };
    if (root.name.$mixin)
      return { element: root, item };
    if (root.self)
      return { item };
    if (root.kind !== '$tableAlias' || ref.path.length < 2)
      return {};
    item = ref.path[1];
    return { element: root.$navigation[ item.id ], item, tableAlias: root };
  }

  function sourceNavigation( ref, tableAlias ) {
    // For paths in the ON condition coming from source elements.
    // We cannot use _navigation here, as it is not set.
    let item = ref.path && ref.path[0];
    let root = item && item._artifact;
    if (!root)
      return {};
    let source = tableAlias.type && tableAlias.type._artifact;
    if (root._main === source) // element of query - root._parent might link to leading query!
      return { element: tableAlias.$navigation[ item.id ], item, tableAlias };
    if (root !== source || ref.path.length === 1) // $projection, $self
      return { item };
    item = ref.path[1];
    return { element: tableAlias.$navigation[ item.id ], item, tableAlias };
  }

  function resolveExpr( expr, expected, user, env, extDict, block ) {
    if (!expr || typeof expr === 'string') // parse error or keywords in {xpr:...}
      return;
    if (expr instanceof Array)
      expr.forEach( e => resolveExpr( e, expected, user, env, extDict, block ) );
    else if (expr.path) {
      if (expected instanceof Function) {
        expected( expr, user, env, extDict, block );
        return;
      }
      // TODO: user!!!, TODO: block for constant and parameter access!
      resolvePath( expr, expected, undefined, env, extDict ); // TODO: user!!!
      // TODO: put the following in resolvePath (extra arg if allowed)?
      for (let step of expr.path) {
        if (!step._artifact)
          break;
        if (step.namedArgs)
          // TODO: also check for just assoc
          resolveParams( step.namedArgs, step._artifact, block ); // block for future :const
        if (step.where) {   // TODO: support for $projection, $parameters, ...?
          let assoc = finalType( step._artifact );
          if (!assoc.target)
            message( 'expr-no-filter', step.where.location, {},
                     ['Error'],
                     'A filter can only be provided when navigating along associations' );
          else
            resolveExpr( step.where, 'element', null, { $msg: assoc.target },
                         environment( step._artifact ), block );
        }
      }
    }
    else if (expr.op && queryOps[ expr.op.val ]) {
      // TODO: is that enough or should we make sure to resolve them in reverse order?
      if (expr.kind || expr._leadingQuery) // UNION has _leadingQuery
        resolveQueryExpr( expr );
      else
        message( 'expr-no-subquery', expr.location, {},
                 'Error', 'Subqueries are not supported here' );
    }
    else if (expr.op && expr.args) {
      let func = expr.func && expr.func.path && expr.func.path[0].id;
      if (func && func.toUpperCase() === 'ROUND') // TODO: temp?
        resolveExpr( expr.args[0], expected, user, env, extDict, block )
      else
        expr.args.forEach( e => resolveExpr( e, expected, user, env, extDict, block ) );
    }
  }

  // eslint-disable-next-line no-unused-vars
  function resolveParams( dict, art, block ) { // TODO: block for :param or :const
    let type = finalType( art );
    if (type.target) {
      art = type.target._artifact;
      if (!art)                 // association with undefined target
        return;
    }
    if (!art.params) {
      let first = dict[ Object.keys(dict)[0] ];
      if (first instanceof Array)
        first = first[0];
      message( 'ref-no-params',
               dictLocation( dict, first && first.name && first.name.location ), { art },
               ['Error'], 'Entity $(ART) has no parameters' );
      return;
    }
    for (let name in dict) {
      let param = art.params[name];
      let arg = dict[name];
      for (let a of (arg instanceof Array) ? arg : [arg]) {
        setProp( a.name, '_artifact', param );
        if (!param)
          message( 'ref-undefined-param', a.name.location, { art, id: name },
                   ['Error'], 'Entity $(ART) has no parameter $(ID)' );
        resolveExpr( a, 'expr', null, {} ); // only param and const, TODO: block
      }
    }
  }
}

function copyExpr( expr ) {
  if (!expr || typeof expr !== 'object')
    return expr;
  else if (expr instanceof Array)
    return expr.map( copyExpr );

  let proto = Object.getPrototypeOf( expr );
  if (proto && proto !== Object.prototype) // do not copy object from special classes
    return expr;
  let r = Object.create( proto );
  if (proto && expr.op && queryOps[ expr.op.val ])
    return [];                  // copy/rewrite with sub query is not supported

  for (let prop of Object.getOwnPropertyNames( expr )) {
    let pd = Object.getOwnPropertyDescriptor( expr, prop );
    if (!pd.enumerable || !pd.value) // should include all properties starting with _
      Object.defineProperty( r, prop, pd );
    else if (!proto || prop.charAt() !== '$' && prop !== 'location')
      r[prop] = copyExpr( pd.value );
    else
      Object.defineProperty( r, prop, pd );
  }
  return r;
}


function testExpr( expr, pathTest, queryTest ) {
  // potential future params for "what to do with sub queries?
  if (!expr || typeof expr === 'string') // parse error or keywords in {xpr:...}
    return false;
  else if (expr instanceof Array)
    return expr.some( e => testExpr( e, pathTest, queryTest ) );
  else if (expr.path)
    return pathTest( expr );
  else if (expr.op && queryOps[ expr.op.val ])
    return queryTest( expr );
  else if (expr.op && expr.args)
    return expr.args.some( e => testExpr( e, pathTest, queryTest ) );
  else
    return false;
}

function targetMaxNotOne( assoc, item ) {
  // Semantics of associations without provided cardinality: [*,0..1]
  let cardinality = item.cardinality || assoc.cardinality;
  return cardinality && cardinality.targetMax && cardinality.targetMax.val !== 1;
}

module.exports = resolve;
