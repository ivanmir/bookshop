const Base = require('./Base')

/**
 * Class representation of after middleware.
 * @augments Base
 * @alias module:hooks.After
 */
class After extends Base {
  /**
   * Add a handler for a specific event type and entity. N handlers per type and entity can be registered.
   * @param {string} event - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|Object} [entity] - Name of the entity or CSN entity
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   */
  use (event, entity, handler) {
    const normalized = this._getParameterFromArgs(event, entity, handler)
    this._addHandler(normalized.event, normalized.entity, this._addConvenienceWrapper(normalized.handler))
  }

  /**
   * In case the app developer uses the single arguments row or each for his handler, he wants convenience.
   * This means, the framework has to wrap his function in an iterator in case the result is an array.
   * @param {function} handler
   * @return {function}
   * @private
   */
  _addConvenienceWrapper (handler) {
    if ((/^\s*(?:\(\s*)?(?:row|each)\s*\)?\s*=>/).test(handler.toString())) {
      return (result) => {
        if (Array.isArray(result)) {
          for (const row of result) {
            handler(row)
          }

          return
        }

        handler(result)
      }
    }

    return handler
  }

  /**
   * Check if handlers are registered for event and entity. Execute all handlers that are registered,
   * with result being passed in as input parameter to the handler.
   * @param {string} event - name of the event like READ, UPDATE, ...
   * @param {Object} context - Contains request information and utility events like .reply(), .error(), ...
   * @param {Object} context.target - the unreflected entity.
   * @param {Object|Array} result - the result being received from the OnHandler. In case of a COMMIT or ROLLBACK event
   *                                this could also be the error that indicates that the transaction operation failed.
   */
  executeHandlerIfListed (event, context, result) {
    let promiseChain = Promise.resolve()

    for (const entry of this._handlers) {
      if (this._match(event, context, entry)) {
        promiseChain = this._extendPromiseChainWithHandler(promiseChain, entry.handler, context, result)
      }
    }

    if (this._isTransactionEvent(event)) {
      return promiseChain
    }

    return promiseChain
      .then(() => {
        return this._handleErrors(context)
      })
  }

  _extendPromiseChainWithHandler (promiseChain, handler, context, result) {
    return promiseChain.then(() => {
      const promise = handler(result, context)

      return (promise && promise.then) ? promise : Promise.resolve()
    })
  }
}

module.exports = After
