const {EventHandlerNotDefined, NotInModel} = require('../../errors')
const DEFAULT_EVENTS = ['CREATE', 'CREATE_DRAFT', 'DELETE', 'READ', 'UPDATE', 'UPDATE_DRAFT', 'COMMIT', 'ROLLBACK']
const TRANSACTION_EVENTS = ['COMMIT', 'ROLLBACK']

/**
 * Base class for hooks middleware.
 */
class Base {
  /**
   * Constructs a middleware handler.
   * @param {object} reflected - the reflected CSN model.
   * @param {string} service - Service name as specified in CSN.
   */
  constructor (reflected, service) {
    this._handlers = []
    this._model = reflected
    this._service = service
  }

  /**
   * Add a handler for a specific event type and entity. N handlers per type and entity can be registered.
   * @param {string} [event] - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|Object} [entity] - Name of the entity or CSN entity
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   */
  use (event, entity, handler) {
    const normalized = this._getParameterFromArgs(event, entity, handler)
    this._addHandler(normalized.event, normalized.entity, normalized.handler)
  }

  /**
   * An entity can be omitted in case of unbound actions and functions.
   * Normalize the arguments into an object.
   * @param {string} [event] - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|Object} [entity] - Name of the entity or CSN entity
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   * @returns {Object}
   * @private
   */
  _getParameterFromArgs (event, entity, handler) {
    // Any (but COMMIT or ROLLBACK) handler
    if (event === '*') {
      return this._getParameterFromArgs(entity, handler)
    }
    if (event && !entity && !handler) {
      return this._anyHandler(this._generateHandlerIfCQN(event))
    }

    // Unbound handler or any event handler
    if (!entity || !handler) {
      return this._noEntity(event, this._generateHandlerIfCQN(handler || entity))
    }

    return this._specificHandler(event, this._objectEntityToString(entity), this._generateHandlerIfCQN(handler))
  }

  _generateHandlerIfCQN (handler) {
    if (this._isCQN(handler)) {
      return (context) => {
        return context.run(handler)
      }
    }

    return handler
  }

  _anyHandler (handler) {
    this._handlerParamValid(handler)

    return {handler}
  }

  _noEntity (event, handler) {
    if (!this._isDefaultEvent(event) && typeof event === 'string') {
      event = event.startsWith(this._service) ? event : `${this._service}.${event}`
    }

    this._eventParamValid(event)
    this._handlerParamValid(handler)

    return {event, handler}
  }

  _specificHandler (event, entity, handler) {
    this._entityParamValid(entity)
    this._eventParamValid(event, entity)
    this._handlerParamValid(handler)

    return {event, handler, entity}
  }

  _objectEntityToString (entity) {
    if (typeof entity === 'object') {
      return (entity.kind === 'entity' && entity.name) ? entity.name : false
    }

    if (typeof entity === 'string' && !entity.startsWith(this._service)) {
      return `${this._service}.${entity}`
    }

    return entity
  }

  _isCQN (object) {
    if (!object || typeof object !== 'object') {
      return false
    }

    if (object.SELECT) {
      return true
    }
    if (object.INSERT) {
      return true
    }
    if (object.UPDATE) {
      return true
    }

    return Boolean(object.DELETE)
  }

  /**
   * Basic check if the specified entity is a valid parameter for the event handler.
   * @param {string} entity - Entity parameter
   * @private
   */
  _entityParamValid (entity) {
    // Check if provided entity is defined in the reflection model
    if (entity !== undefined && !this._isModeledEntity(entity)) {
      throw new NotInModel(entity === false ? undefined : entity)
    }
  }

  _isDefaultEvent (event) {
    return DEFAULT_EVENTS.includes(event)
  }

  _isTransactionEvent (event) {
    return TRANSACTION_EVENTS.includes(event)
  }

  /**
   * Basic check if the specified event is a valid parameter for the event handler.
   * @param {string} event - Event parameter
   * @param {string} [entity] - Entity parameter
   * @private
   */
  _eventParamValid (event, entity) {
    // Check validity of custom operations
    if (event && !this._isDefaultEvent(event)) {
      // Check if provided unbound custom operation is contained in the reflection model
      if (entity === undefined && !this._isUnboundCustomOperation(event)) {
        throw new NotInModel(event)
      }

      // Check if provided bound custom operation is defined within the provided entity in the reflection model
      if (entity !== undefined && !this._isBoundCustomOperation(entity, event)) {
        throw new NotInModel(event)
      }
    }
  }

  /**
   * Basic check if the specified handler is a valid parameter for the event handler.
   * @param {function} handler - Handler parameter
   * @private
   */
  _handlerParamValid (handler) {
    // Check if provided handler param has wrong type
    if (typeof handler !== 'function') {
      throw new EventHandlerNotDefined()
    }
  }

  /**
   * Checks whether or not an entity exists in the reflection model.
   * @param entity
   * @returns {boolean}
   * @private
   */
  _isModeledEntity (entity) {
    return this._model.find(d => d.kind === 'entity' && d.name === entity) !== undefined
  }

  /**
   * Checks whether or not a provided event exists as unbound custom operation in the reflection model.
   * @param {string} event
   * @returns {boolean}
   * @private
   */
  _isUnboundCustomOperation (event) {
    return this._model.find(d => ['action', 'function'].includes(d.kind) && d.name === event) !== undefined
  }

  /**
   * Checks whether or not a provided event exists as bound custom operation in the reflection model.
   * @param {string} entity
   * @param {string} event
   * @returns {boolean}
   * @private
   */
  _isBoundCustomOperation (entity, event) {
    return this._model.find(d => d.kind === 'entity' && d.name === entity &&
      ((d.actions && d.actions[event]) || this._isDraftAction(d, event))) !== undefined
  }

  // TODO remove if draftPrepare, draftEdit and draftActivate actions are part of the new CSN
  _isDraftAction (definition, event) {
    return definition['@odata.draft.enabled'] && (event === 'draftPrepare' || event === 'draftEdit' || event === 'draftActivate')
  }

  /**
   * Adds a middleware handler to the set.
   * @param event
   * @param entity
   * @param handler
   * @private
   */
  _addHandler (event, entity, handler) {
    this._handlers.push({
      event,
      entity,
      handler
    })
  }

  /**
   * Check if the handler should handle this event.
   * @return {boolean}
   * @private
   */
  _match (event, context, entry) {
    // Registered to all events
    if (!this._isTransactionEvent(event) && !entry.event && !entry.entity) {
      return true
    }

    if (entry.event !== event) {
      return false
    }

    if (entry.entity === undefined) {
      return true
    }

    return (context.target && entry.entity === context.target.name)
  }

  _handleErrors (context) {
    if (!context._.errors || context._.errors.length === 0) {
      return Promise.resolve()
    }

    return Promise.reject(context._.errors.reduce(this._reduceErrors))
  }

  _reduceErrors (finalError, currentError) {
    if (!finalError) {
      return currentError
    }

    finalError.message += `, ${currentError.message}`

    return finalError
  }
}

module.exports = Base
