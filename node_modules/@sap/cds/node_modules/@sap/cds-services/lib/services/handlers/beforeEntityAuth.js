const getClientIpFromRequest = require('../utils/clientIpFromRequest')

const _evaluate = (match, context) => {
  let value = context
  const parts = match.substring(1).split('.')

  for (const part of parts) {
    value = value[part]
  }

  return value
}

/**
 * Replace $user with context.user.id
 * and $user.bla.bla with context.user.bla.bla.
 * Afterwards split to parts by space.
 *
 * @param where
 * @param context
 *
 * @private
 */
const _parseWhere = (where, context) => {
  const matches = where.match(/\$(user(?:\.[^\s=]+))/g) || []

  for (const match of matches) {
    where = where.replace(match, _evaluate(match, context))
  }

  return where.replace('$user', context.user.id)
    .split(' ')
    .filter((s) => {
      return s.length !== 0
    })
}

/**
 * This is a temporary solution for handling where conditions for data provided in insert or update.
 * Only the conditions in form column = value are considered.
 * In the entries to be inserted/updated the column will be set to the value.
 * Also only one where condition is currently supported.
 *
 */
const _parseWhereData = (where, context) => {
  if (where.length === 0) {
    return {}
  }
  const parsed = _parseWhere(where[0], context) // limitation: only one where condition

  if (parsed.length !== 3 || parsed[1] !== '=') {
    return {}
  }

  return {
    col: parsed[0],
    val: parsed[2]
  }
}

const _changeInsertEntries = (insert, col, val) => {
  if (!insert.entries || insert.entries.length === 0 || !insert.entries[0].hasOwnProperty(col)) {
    return
  }

  for (const entry of insert.entries) {
    entry[col] = val
  }
}

const _changeInsert = (annotations, context) => {
  const parsed = _parseWhereData(annotations.where, context)
  if (Object.keys(parsed).length !== 0) {
    _changeInsertEntries(context.query.INSERT, parsed.col, parsed.val)
  }
}

const _changeUpdateData = (context, col, val) => {
  if (!context.query.UPDATE.data.hasOwnProperty(col)) {
    return
  }

  context.query.UPDATE.data[col] = val

  // returned data object
  if (context.data && context.data.hasOwnProperty(col)) {
    context.data[col] = val
  }
}

const _changeUpdate = (annotations, context) => {
  const parsed = _parseWhereData(annotations.where, context)
  if (Object.keys(parsed).length !== 0) {
    _changeUpdateData(context, parsed.col, parsed.val)
  }
}

/**
 * Get generic authorization handler for CRUD requests on entity level.
 * The handler to be registered as a before handler.
 *
 * @param annotations - prepared authorization (restrict or requires) annotations
 * @param auditLogger - the audit logger object
 */
const getAuthEntityHandler = (annotations, auditLogger) => {
  /**
   * @param context - operation object, that provides error, continuation and other functions as well as information
   * regarding the current operation.
   */
  return (context) => {
    if (annotations.to) {
      if (!context.user.has(annotations.to)) {
        const ip = getClientIpFromRequest(context._.req)
        const tenant = context.attr.identityZone
        auditLogger.logMissingPermissions({user: context.user.id, ip, tenant})
        return context.reject(403)
      }
    }

    if (!annotations.where) {
      return
    }
    if (context.query.INSERT) {
      _changeInsert(annotations, context)
      return
    }
    if (context.query.UPDATE) {
      _changeUpdate(annotations, context)
    }
    for (const where of annotations.where) {
      context.query.where(..._parseWhere(where, context))
    }
  }
}

module.exports = getAuthEntityHandler
