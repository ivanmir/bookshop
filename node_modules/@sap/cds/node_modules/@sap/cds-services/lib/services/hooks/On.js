const {FeatureNotSupported} = require('../../errors/index')
const Base = require('./Base')
const CALLED = Symbol.for('continuationCalled')

/**
 * Class representation of on middleware.
 * @augments Base
 * @alias module:hooks.On
 */
class On extends Base {
  _calculateDefaultHandlerCount (definition) {
    if (definition['@readonly']) {
      return 1
    }

    if (definition['@insertonly']) {
      if (definition['@odata.draft.enabled']) {
        return 5
      }

      return 1
    } else {
      if (definition['@odata.draft.enabled']) {
        return 9
      }

      return 4
    }
  }

  /**
   * Constructs the on middleware handler.
   * @param {object} reflected - the reflected CSN model.
   * @param {string} service - Service name as specified in CSN.
   */
  constructor (reflected, service) {
    super(reflected, service)

    // fail handler
    this._defaultHandlerCount = 1

    // Sum up the to be registered generic handlers.
    reflected.find((definition) => {
      if (definition.kind === 'entity' && definition.name.startsWith(service)) {
        this._defaultHandlerCount += this._calculateDefaultHandlerCount(definition)
      }
    })
  }

  /**
   * Replace a handler for a specific event type and entity.
   * @param {string} event - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|Object} [entity] - Name of the entity or CSN entity
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   */
  use (event, entity, handler) {
    if (this._isTransactionEvent(event)) {
      throw new FeatureNotSupported()
    }

    const length = this._handlers.length

    if (length < this._defaultHandlerCount) {
      this._handlers.push(this._getParameterFromArgs(event, entity, handler))

      return
    }

    this._handlers.splice((length - this._defaultHandlerCount), 0, this._getParameterFromArgs(event, entity, handler))
  }

  /**
   * Check if a handler is registered for event and entity. Execute the handler that is registered,
   * with request and response as input parameter to the handler.
   * @param {string} event - name of the event like READ, UPDATE, ...
   * @param {Object} context - Contains request information and utility events like .send(), .error(), ...
   * @param {string} context.target - the unreflected entity
   * @param {function} reject - If dbc is present, rollback + release; else only end the chain.
   * @returns {Promise}
   */
  executeHandlerIfListed (event, context, reject) {
    const calledFrom = {}
    const length = this._handlers.length
    let i = 0

    // Recursive function, which will work with closures i and length
    const next = (err, calledFromHandler) => {
      // Prevent that error happen in case next is called twice within the same handler
      if (calledFrom[calledFromHandler]) {
        return
      }

      calledFrom[calledFromHandler] = true

      // Explicit end of chain by handler
      if (err) {
        reject(err)
        return
      }

      // Stop the chain, as reply has been called before
      if (context[CALLED]) {
        return
      }

      let handler

      // Check all registered handlers if registered for this event.
      while (i < length) {
        // Copy count and use to identify
        const count = i
        const nextOnce = (err) => {
          return next(err, count)
        }

        handler = this._handlers[i]
        i++

        // We have to catch in order to be able to release the DB client.
        if (this._match(event, context, handler)) {
          try {
            this._handleLayerReturn(context, nextOnce, handler.handler(context, nextOnce), reject)
            return
          } catch (err) {
            reject(err)
            return
          }
        }
      }
    }

    next(null, -1)
  }

  /**
   * (a)sync code might be in place which can be expressed in various forms.
   * If a return is given, provide convenience.
   * @private
   */
  _handleLayerReturn (context, next, layerReturn, reject) {
    // Promise or equaly behaving thenables.
    if (layerReturn && layerReturn.then) {
      this._handleThanables(context, next, layerReturn, reject)
      return
    }

    // CQN means, we should run it
    if (this._isCQN(layerReturn)) {
      this._handleThanables(context, next, context.run(layerReturn), reject)
      return
    }

    // A result is returned, that marks the end of the chain
    if (layerReturn !== undefined && typeof layerReturn !== 'function') {
      this._handleErrors(context)
        .then(() => {
          context.reply(layerReturn)
        })
        .catch(reject)
    }
  }

  /**
   * The app dev decided to handle async processes on its own.
   * The result should be the end of the chain.
   * @private
   */
  _handleThanables (context, next, promise, reject) {
    return promise
      .then((result) => {
        // app developer called .reply in the meantime. This check prevents double execution
        if (context[CALLED]) {
          return
        }

        return this._handleErrors(context)
          .then(() => {
            context.reply(result)
          })
      })
      .catch(reject)
  }
}

module.exports = On
