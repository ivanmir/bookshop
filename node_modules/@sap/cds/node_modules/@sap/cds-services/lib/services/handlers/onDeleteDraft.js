const notFound = require('./notFound')
const {getError} = require('../../errors/index')
const {getPathEntities, getCompositionTree} = require('../utils/compositionTree')
const {getServiceNamespace, getEntityName, getDraftName, getSubCQNs, getUpdateDraftAdminCQN} = require('../utils/draftUtils')
const {DB_CONNECTION_MISSING} = require('../utils/constants')

// whereCondition = [{ref: ['id']}, '=', {val: '123'},
//                    ----multiple-----
//                   , 'and', {ref: ['IsActiveEntity']}, '=', {val: 'true'}]
const _extractKeysFromWhere = whereCondition => {
  const result = {
    keyList: [],
    IsActiveEntity: false
  }

  const length = whereCondition.length
  let index = 0
  while (index < length) {
    if (whereCondition[index].ref && whereCondition[index].ref[0] === 'IsActiveEntity') {
      result.IsActiveEntity = whereCondition[index + 2].val === 'true'
    } else {
      result.keyList.push(whereCondition[index],
        whereCondition[index + 1],
        whereCondition[index + 2])
    }
    index += 4
  }
  return result
}

const _getSelectCQN = (context, keys) => {
  const select = context.statements.SELECT.from(context.target)
  select.where(...keys.keyList)

  return select
}

const _getDraftEntityName = ({target: {name}}) => `${name}_drafts`

const _getDraftSelectCQN = (context, keys) => {
  const draftEntityName = _getDraftEntityName(context)

  return context.statements.SELECT.from(`${draftEntityName}`, ['DraftUUID', 'InProcessByUser'])
    .join('DRAFT.DraftAdministrativeData').on({ref: ['DraftAdministrativeData_DraftUUID']}, `=`, `"DRAFT.DraftAdministrativeData"."DraftUUID"`)
    .where(...keys.keyList)
}

const _validate = (activeResult, draftResult, context, IsActiveEntity) => {
  if ((IsActiveEntity === true && activeResult.length === 0) ||
    (IsActiveEntity === false && draftResult.length === 0)) throw notFound(context)

  if (draftResult.length !== 0 && draftResult[0].InProcessByUser !== context.user.id) {
    throw getError(403, 'Locked by another user')
  }
}

const _getActiveDeleteCQN = ({statements: {DELETE}}, entityName, keys) => DELETE
  .from(entityName)
  .where(...keys)

const _getDraftAdminDeleteCQN = ({statements: {DELETE}}, draftUUID) => DELETE
  .from('DRAFT.DraftAdministrativeData')
  .where({draftUUID})

const _getDeleteTreeCQNs = (compositionTree, definitions, context, keys) => {
  const result = []
  const serviceNamespace = getServiceNamespace(context.target.name)
  const rootCQN = context.statements.SELECT
    .from(getDraftName(serviceNamespace,
      getEntityName(context.target.name)
    ))
    .where(...keys)

  const subSelectCQNs = getSubCQNs({definitions, context, rootCQN, compositionTree, selectFromDraft: true})

  let currentLevel = Math.max(...subSelectCQNs.map(obj => obj.level))
  while (currentLevel > 0) {
    result.push([...subSelectCQNs.filter(obj => obj.level === currentLevel).map(selectCQN => {
      return context.statements.DELETE
        .from(selectCQN.cqn.SELECT.from.ref[0])
        .where(selectCQN.cqn.SELECT.where)
    })])

    currentLevel--
  }

  result.push([context.statements.DELETE
    .from(rootCQN.SELECT.from.ref[0])
    .where(rootCQN.SELECT.where)])

  return result
}

/**
 * Generic Handler for DELETE requests.
 * In case of success it returns an empty object.
 * If the entry to be deleted does not exist, it rejects with error to return a 404.
 *
 * @param context - operation object, that provides error, continuation and other functions as well as information
 * regarding the current operation.
 * @alias module:handlers.onDelete
 */
const getOnDeleteDraft = (definitions) => context => {
  if (!context.run) {
    context.log.warn(DB_CONNECTION_MISSING)
    return Promise.resolve()
  }

  const keys = _extractKeysFromWhere(context.query.DELETE.where)
  return Promise.all([context.run(_getSelectCQN(context, keys)), context.run(_getDraftSelectCQN(context, keys))])
    .then(([activeResult, draftResult]) => {
      _validate(activeResult, draftResult, context, keys.IsActiveEntity)

      const source = definitions[context.target.name].source
      const compositionTree = getCompositionTree(definitions, source, false)
      const delTreeCQNs = _getDeleteTreeCQNs(compositionTree, definitions, context, keys.keyList)

      const delCQNs = []

      if (keys.IsActiveEntity) {
        delCQNs.push(_getActiveDeleteCQN(context, source, keys.keyList))
      }

      if (draftResult.length !== 0) {
        const pathEntities = getPathEntities(definitions, context)
        const draftUUID = draftResult[0].DraftUUID
        if (pathEntities.size === 0) {
          delCQNs.push(_getDraftAdminDeleteCQN(context, draftUUID))
        } else {
          delCQNs.push(getUpdateDraftAdminCQN(context, draftUUID))
        }
      }

      let promise = Promise.resolve()
      for (const levelCQN of delTreeCQNs) {
        promise = promise.then(() => {
          return Promise.all(levelCQN.map(cqn => context.run(cqn)))
        })
      }

      context._oldData = keys.IsActiveEntity ? activeResult[0] : draftResult[0]
      return promise
        .then(() => {
          return Promise.all(delCQNs.map(cqn => context.run(cqn)))
        })
        .then(() => {
        })
    })
}

module.exports = getOnDeleteDraft
