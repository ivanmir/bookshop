const cds = require('../cds')
const getDiff = require('./utils/diff')
const {getError} = require('../errors')
const CALLED = Symbol.for('continuationCalled')

/**
 * Generic Service Event Handler.
 */
class Service {
  /**
   * Constructs an OData service for the given CDS model.
   * @param {Object} csn - the reflected CSN.
   * @param {Object} options - configuration options
   * @param {function} [impl] - init function to register custom handlers.
   * @throws {ModelNotDefined}
   */
  constructor (csn, options, impl) {
    const {After, Before, On, Reject} = require('./hooks')

    cds.service.providers.push(this)

    this._options = options
    this.service = options.service
    this.definition = csn
    this.reflected = cds.reflect(csn)
    this.entities = this.reflected.childrenOf(this.reflected.definitions[options.service])

    this._handlers = {
      before: new Before(this.reflected, this.service),
      on: new On(this.reflected, this.service),
      after: new After(this.reflected, this.service),
      reject: new Reject(this.reflected, this.service)
    }

    this._addDefaultOnHandler()
    this._addDefaultBeforeAuthHandler()
    this._addDefaultPersonalDataHandler()
    this._addDefaultMiddleware()
    this._executeImpl(impl)
  }

  /**
   * Require @sap/cds-ql on first usage.
   * @returns {Object}
   * @private
   */
  get _ql () {
    const ql = require('@sap/cds-ql')
    Object.defineProperty(this, '_ql', {value: ql})
    return ql
  }

  /**
   * Require logger on first usage.
   * Could be provided via options.
   *
   * @returns {Object}
   */
  get logger () {
    const logger = require('./utils/logger')(this._options)
    Object.defineProperty(this, 'logger', {value: logger})
    return logger
  }

  /**
   * Require @sap/audit-logging on first usage.
   * @returns {Object}
   * @private
   */
  get _auditLogger () {
    const auditLogger = require('./utils/auditlog')(this._options.auditlog, this.logger)
    Object.defineProperty(this, '_auditLogger', {value: auditLogger})
    return auditLogger
  }

  _addDefaultMiddleware () {
    this._registerPassportMiddleware()
  }

  _registerPassportMiddleware () {
    const passport = require('../adapter/utils/passport')(this._options, this.definition.definitions)

    if (passport) {
      this.use(passport.initialize())
      this.use(require('../adapter/utils/passportAuthenticateCallback')(passport, (this._options.passport) ? this._options.passport.strategy : {}, this._auditLogger))
      this.use(require('../adapter/utils/serviceAuth')(this.reflected.definitions[this.service], this._auditLogger))
      // Security annotations, but no passport
    } else if (passport === false) {
      this.use(require('../adapter/utils/serviceAuth')(this.reflected.definitions[this.service], this._auditLogger))
    }
  }

  /**
   * Registers custom handlers.
   * @param {function} impl - init function to register custom handlers.
   */
  _executeImpl (impl) {
    if (typeof impl === 'function') {
      impl.apply(this, [this.entities])
    }
  }

  _getReadHandler (isDraftEnabled) {
    return isDraftEnabled ? require('./handlers/onReadDraft')(this)
      : require('./handlers/onRead')
  }

  _getCreateHandler () {
    return require('./handlers/onCreate')
  }

  _getCreateDraftHandler (isDraftEnabled) {
    return isDraftEnabled ? require('./handlers/onCreateDraft')(this) : undefined
  }

  _getDraftPrepareHandler (isDraftEnabled) {
    return isDraftEnabled ? require('./handlers/onDraftPrepare') : undefined
  }

  _getDraftEditHandler (isDraftEnabled) {
    return isDraftEnabled ? require('./handlers/onDraftEdit')(this.reflected.definitions) : undefined
  }

  _getDraftActivateHandler (isDraftEnabled, localClient) {
    return isDraftEnabled ? require('./handlers/onDraftActivate')({
      localClient,
      definitions: this.reflected.definitions
    }) : undefined
  }

  _getUpdateHandler () {
    return require('./handlers/onUpdate')
  }

  _getDeleteHandler (isDraftEnabled) {
    return isDraftEnabled ? require('./handlers/onDeleteDraft')(this.reflected.definitions)
      : require('./handlers/onDelete')
  }

  _getUpdateDraftHandler (isDraftEnabled) {
    return isDraftEnabled ? require('./handlers/onUpdateDraft') : undefined
  }

  _getScenario (entity) {
    if (entity['@readonly']) {
      return '@readonly'
    }
    if (entity['@insertonly']) {
      return '@insertonly'
    }
    return 'default'
  }

  _getHandlersOfScenario () {
    return new Map([
      ['@readonly', {
        on: new Map([['READ', this._getReadHandler]]),
        reject: ['CREATE', 'CREATE_DRAFT', 'UPDATE', 'UPDATE_DRAFT', 'DELETE']
      }],
      ['@insertonly', {
        on: new Map([
          ['CREATE', this._getCreateHandler],
          ['CREATE_DRAFT', this._getCreateDraftHandler],
          ['UPDATE_DRAFT', this._getUpdateDraftHandler],
          ['draftPrepare', this._getDraftPrepareHandler],
          ['draftActivate', this._getDraftActivateHandler]
        ]),
        reject: ['READ', 'DELETE', 'UPDATE']
      }],
      ['default', {
        on: new Map([
          ['READ', this._getReadHandler],
          ['CREATE', this._getCreateHandler],
          ['CREATE_DRAFT', this._getCreateDraftHandler],
          ['draftPrepare', this._getDraftPrepareHandler],
          ['draftEdit', this._getDraftEditHandler],
          ['draftActivate', this._getDraftActivateHandler],
          ['UPDATE', this._getUpdateHandler],
          ['UPDATE_DRAFT', this._getUpdateDraftHandler],
          ['DELETE', this._getDeleteHandler]
        ]),
        reject: []
      }]]
    )
  }

  // Workaround: Add navigations to DraftAdminData to CSN
  // Otherwise CQN cannot be built
  // TODO: Remove workaround, once provided by CSN
  _addDraftAdminNavigations (entity) {
    const draftAdminAssociation = {
      foreignKeys: {
        DraftUUID: {
          path: 'DraftUUID'
        }
      },
      name: 'DraftAdministrativeData',
      type: 'cds.Association',
      target: 'DRAFT.DraftAdministrativeData',
      kind: 'element'
    }

    this.reflected.definitions[entity.name].elements['DraftAdministrativeData'] = draftAdminAssociation
    this.reflected.definitions[entity.source].elements['DraftAdministrativeData'] = draftAdminAssociation
  }

  // Workaround: Add DraftAdminData to CSN and register READ handler
  // TODO: Remove workaround, once provided by CSN
  _addDraftAdmin () {
    const draftAdminEntity = require('./utils/administrativeData')
    this.reflected.definitions['DRAFT.DraftAdministrativeData'] = draftAdminEntity

    const handler = this._getReadHandler(true)
    this.on('READ', draftAdminEntity, handler)

    this._handlers.on._defaultHandlerCount += 1
  }

  /**
   * Register default on handlers for all entities of the service.
   * If the entity is marked with @readonly annotation only default handler for read is registered, others are rejected.
   * If the entity is marked with @insertonly annotation only default handler for insert is registered, others are rejected.
   * @private
   */
  _addDefaultOnHandler () {
    const handlersOfScenario = this._getHandlersOfScenario()
    let service = this

    const localClient = require('../adapter/client/for')(this.service)

    for (const entity of this._getServiceEntities()) {
      const isDraftEnabled = entity['@odata.draft.enabled']
      const {on, reject} = handlersOfScenario.get(this._getScenario(entity))

      for (const [method, getHandlers] of on) {
        const handler = getHandlers.apply(this, [isDraftEnabled, localClient])
        if (handler) {
          service = service.on(method, entity, handler)
        }
      }
      if (reject.length) {
        service = service.reject(reject, entity.name)
      }

      // Workaround
      if (isDraftEnabled) {
        if (!this._draftEntities) {
          this._draftEntities = []
        }
        this._draftEntities.push(entity)
      }
    }

    // Workaround
    if (this._draftEntities) {
      this._addDraftAdmin()
    }

    // Final handler, that will throw an error
    this.on(require('./handlers/finalOn'))
  }

  /**
   * Checks if entity has annotation '@PersonalData.EntitySemantics' and value is either 'DataSubject' or
   * 'DataSubjectDetails'.
   * @param entity
   * @returns {boolean}
   * @private
   */
  _isPersonalDataRelevant (entity) {
    const allowedAnnotations = ['DataSubject', 'DataSubjectDetails']
    return entity['@PersonalData.EntitySemantics'] &&
      allowedAnnotations.includes(entity['@PersonalData.EntitySemantics'])
  }

  /**
   * Register default before commit and after commit/rollback handler for the entity.
   * @param entity
   * @private
   */
  _registerPersonalDataHandler (entity) {
    const {
      personalDataBeforeCommitHandler,
      personalDataAfterCommitHandler,
      personalDataBeforeRollbackHandler,
      personalDataAfterRollbackHandler
    } = require('../adapter/utils/personalDataHandler')(this.reflected, this._auditLogger)

    if (entity['@AuditLog.Operation.Insert'] || entity['@AuditLog.Operation.Update'] || entity['@AuditLog.Operation.Delete']) {
      this.before('COMMIT', entity, personalDataBeforeCommitHandler)
      this.after('COMMIT', entity, personalDataAfterCommitHandler)
      this.before('ROLLBACK', entity, personalDataBeforeRollbackHandler)
      this.after('ROLLBACK', entity, personalDataAfterRollbackHandler)
    } else if (entity['@AuditLog.Operation.Read']) {
      this.before('COMMIT', entity, personalDataBeforeCommitHandler)
    }
  }

  /**
   * Register default before commit and after commit/rollback handler for all personal data annotated entities of the
   * service.
   * @private
   */
  _addDefaultPersonalDataHandler () {
    for (const entity of this._getServiceEntities()) {
      if (this._isPersonalDataRelevant(entity)) {
        this._registerPersonalDataHandler(entity)
      }
    }
  }

  /**
   * Register default before handlers for all authorization annotated entities of the service.
   * @private
   */
  _addDefaultBeforeAuthHandler () {
    const getAnnotations = require('../adapter/utils/getAnnotations')
    const getAuthEntityHandler = require('./handlers/beforeEntityAuth')

    this.before(require('./handlers/beforeAll'))

    for (const entity of this._getServiceEntities()) {
      const annotations = getAnnotations(entity)
      for (const key of Object.keys(annotations)) {
        this.before(key, entity, getAuthEntityHandler(annotations[key], this._auditLogger))
      }
    }
  }

  _getServiceEntities () {
    return [...this.reflected.each((definition) => {
      return definition.kind === 'entity' && definition.name.startsWith(this.service)
    })]
  }

  /**
   * Add a handler for a specific event type and entity. N handlers per type and entity can be registered.
   * @param {string} event - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|Object} [entity] - Name of the entity or CSN entity.
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   * @returns {Service}
   */
  before (event, entity, handler) {
    this._handlers.before.use(event, entity, handler)

    return this
  }

  /**
   * Replace an handler for a specific event type and entity.
   * @param {string} [event] - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|Object} [entity] - Name of the entity or CSN entity.
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   * @returns {Service}
   */
  on (event, entity, handler) {
    this._handlers.on.use(event, entity, handler)

    return this
  }

  /**
   * Add a handler for a specific event type and entity. N handlers per type and entity can be registered.
   * In case an arrow function with '(each) =>' is used for the event handler an iterator for the result set will be added automatically.
   * @param {string} event - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|string|Object} [entity] - Name of the entity or CSN entity.
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   * @returns {Service}
   */
  after (event, entity, handler) {
    this._handlers.after.use(event, entity, handler)

    return this
  }

  /**
   * Reject an event type, list of event types or an event type for a entity.
   * @param {string|Array} event - Specific event type or list of types.
   * @param {string|Object|Array} [entity] - Name of the entity or CSN entity or list of entities the event type should be rejected for.
   * The list can be specified either as Array or as multiple parameters.
   * @returns {Service}
   */
  reject (...args) {
    this._handlers.reject.use(...args)

    return this
  }

  /**
   * Express like middleware registration.
   * @returns {Service}
   */
  use (...args) {
    if (!this._handlers.router) {
      this._handlers.router = require('express').Router()
    }

    this._handlers.router.use(...args)

    return this
  }

  /**
   * Execute all registered middleware.
   * @param {Object} req
   * @param {Object} res
   * @param {Function} next
   * @returns {undefined} if no router is present
   */
  routerHandle (req, res, next) {
    if (!this._handlers.router) {
      next()
      return
    }

    const end = (err) => {
      if (err) {
        // err.status is http error code from passport
        res.status(err.statusCode || err.status || 500)
        res.send({
          error: {
            code: err.code,
            message: err.message
          }
        })

        return
      }

      next()
    }

    this._handlers.router.handle(req, res, end)
  }

  /**
   * Process an event from any adapter/channel.
   * @param {string} event
   * @param {Object} context
   * @returns {Promise<Array>}
   */
  processEvent (event, context) {
    // Workaround
    // TODO: Remove after new csn is available
    if (context.target && context.target.name === 'DRAFT.DraftAdministrativeData') {
      for (const entity of this._draftEntities) {
        this._addDraftAdminNavigations(entity)
      }
    }

    return new Promise((resolve, reject) => {
      if (this._handlers.reject.has(event, context.target)) {
        reject(getError(501))
        return
      }

      this._addError(context)
      this._addReject(context)
      this._addReply(event, context, resolve, reject)
      this._addRunIfPrimarySessionExists(context)
      this._addLogger(context)

      this._runHandlers(event, context, reject)
    })
  }

  _addLogger (context) {
    context.log = this.logger
  }

  /**
   * Check for registered handlers.
   * Execute in sequence before, on, after, beforeCommit, commit, onCommit.
   * @param {string} event
   * @param {Object} context
   * @param {Function} reject
   * @private
   */
  _runHandlers (event, context, reject) {
    this._handlers.before.executeHandlerIfListed(event, context)
      .then(() => {
        this._handlers.on.executeHandlerIfListed(event, context, this._reject(event, context, reject))
      })
      .catch((err) => {
        return this._end(event, context, 'rollback', reject, (err.statusCode) ? err : getError(500, err), reject)
      })
  }

  /**
   * Embed promises reject function in a potential DB client rollback.
   * @param {string} event
   * @param {Object} context
   * @param {Function} reject
   * @returns {Function}
   * @private
   */
  _reject (event, context, reject) {
    return (err) => {
      return this._end(event, context, 'rollback', reject, err, reject)
    }
  }

  /**
   * Success and error handling of commit and rollback.
   * @param {string} event
   * @param {Object} context
   * @param {string} command - commit or rollback
   * @param {Function} end
   * @param {*} value
   * @param {Function} reject
   * @returns {Promise}
   * @private
   */
  _end (event, context, command, end, value, reject) {
    this._storeDataOperations(event, context, value)
    return this._endTransactionIfConnected(context, command)
      .then(() => {
        end(value)
      })
      .catch((err) => {
        reject(value instanceof Error ? value : err)
      })
  }

  /**
   * Add .error function to context object.
   * @param {Object} context
   * @private
   */
  _addError (context) {
    /**
     * Error factory method.
     * Errors are not thrown. Instead they are collected in the array context._.errors.
     * @param {number|Error|string} code - HTTP status code. If unknown to @sap/odata-v4, will be overwritten with 500.
     * @param {Error|string} [err] - Error given by the app developer.
     */
    context.error = (code, err) => {
      if (!context._.errors) {
        context._.errors = []
      }

      const error = getError(code, err)
      context._.errors.push(error)

      return error
    }
  }

  /**
   * Add .reject function to context object.
   * @param {Object} context
   * @private
   */
  _addReject (context) {
    /**
     * Reject factory method
     * In case of reject the error is thrown directly instead of putting it to context._.errors.
     * @param {number|Error|string} code - HTTP status code. If unknown to @sap/odata-v4, will be overwritten with 500.
     * @param {Error|string} [err] - Error given by the app developer.
     */
    context.reject = (code, err) => {
      throw getError(code, err)
    }
  }

  /**
   * Add .reply function to context object.
   * @param {String} event
   * @param {Object} context
   * @param {Function} resolve
   * @param {Function} reject
   * @private
   */
  _addReply (event, context, resolve, reject) {
    context[CALLED] = false

    /**
     * Check if already called.
     * @returns {boolean}
     */
    const replyCalled = () => {
      const lastCalled = context[CALLED]
      context[CALLED] = true

      return lastCalled
    }

    /**
     * Hand over of 'on hook' result to following middleware.
     * @param {Array|Object|string} result - Result as given by persistence at the on handler.
     */
    context.reply = (result) => {
      // Not allowed to be called twice.
      if (replyCalled()) {
        return
      }

      const modifiedResult = this._modifyResult(result)

      // Unexpected errors will be handled in the after handler.
      this._handlers.after.executeHandlerIfListed(event, context, modifiedResult)
        .then(() => {
          return this._end(event, context, 'commit', resolve, modifiedResult, reject)
        })
        .catch((err) => {
          return this._end(event, context, 'rollback', reject, err, reject)
        })
    }
  }

  /**
   * Track the general event as commit event.
   * @param event
   * @param context
   * @param result
   * @private
   */
  _storeDataOperations (event, context, result) {
    let dataOperation = {
      get query () {
        return context.query
      },
      target: context.target,
      data: context.data,
      // Event is not required by handler, but is useful for the app developer
      event: event,
      // Add the underscore, to give an app developer a cross event object
      _: Object.assign({}, context._, {dataOperations: undefined})
    }

    if (!context._.dataOperations) {
      context._.dataOperations = []
    }

    if (event === 'READ') {
      // Lazy constructing of the result
      Object.defineProperty(dataOperation, 'result', {
        configurable: true,
        get: function () {
          Object.defineProperty(dataOperation, 'result', {value: result})

          return result
        }
      })
    } else {
      // Might be undefined; TODO: an API to set it.
      dataOperation.oldData = context._oldData

      // Lazy constructing of the diff
      Object.defineProperty(dataOperation, 'diff', {
        configurable: true,
        get: function () {
          const diff = getDiff(event, this.oldData, this.data)
          Object.defineProperty(dataOperation, 'diff', {value: diff})

          return diff
        }
      })
    }

    context._.dataOperations.push(dataOperation)
  }

  /**
   * Check if result is array and if not return result as single entry in an array.
   * @param result
   * @return {Array}
   * @private
   */
  _modifyResult (result) {
    // Null, 0, false, '', ... should be wrapped
    if (result === undefined) {
      return []
    }

    return Array.isArray(result) ? result : [result]
  }

  /**
   * Execute the end transaction command and trigger after end transaction handlers.
   * In case both the end transaction and a after end transaction handler fails throw end transaction error.
   * @private
   */
  _onAndAfterEndTransaction (context, command) {
    const dataOperations = context._.dataOperations
    delete context._.dataOperations

    return this._commandAndRelease(this._removeNoLongerNeededFromQL(context), command)
      .catch((err) => {
        return this._afterEndTransactionBlock(command, false, dataOperations)
          .catch(() => {
            throw err
          })
          .then(() => {
            throw err
          })
      })
      .then(() => {
        return this._afterEndTransactionBlock(command, true, dataOperations)
      })
  }

  /**
   * Check if a client exists in the event context.
   * If yes and not shared with other events, return client to pool and finish the request.
   * @private
   */
  _endTransactionIfConnected (context, command) {
    // In case there is no dbc, or doNotFinish (might be OData batch), read collection with count, ...
    if (!context._.dbc || context._.doNotFinishTransaction) {
      return Promise.resolve()
    }

    // An error has occurred and there is no client
    if (context._.dbc.stack) {
      return Promise.reject(context._.dbc)
    }

    return this._beforeEndTransactionBlock(command, context._.dataOperations)
      .catch((err) => {
        if (command === 'rollback') {
          // before ROLLBACK error: still execute rollback (and after rollback handlers)
          return this._onAndAfterEndTransaction(context, command)
            .catch(() => {
              throw err
            })
            .then(() => {
              throw err
            })
        } else {
          // before COMMIT error: don't commit, rollback (including before/after rollback handlers)
          return this._endTransactionIfConnected(context, 'rollback')
            .catch(() => {
              throw err
            })
            .then(() => {
              throw err
            })
        }
      })
      .then(() => {
        return this._onAndAfterEndTransaction(context, command)
      })
  }

  /**
   * Execute commit or rollback and release the client to the Pool.
   * @param {Client} dbc
   * @param {string} command
   * @return {Promise}
   * @private
   */
  _commandAndRelease (dbc, command) {
    if (!dbc || typeof dbc[command] !== 'function') {
      return Promise.resolve()
    }

    return dbc[command]()
      .catch((err) => {
        /*
         * If a commit or rollback fails, there is something seriously wrong with the client.
         * Such a client needs to be destroyed rather than reused.
         */
        return this._ql.connect.destroy(dbc)
          .then(() => {
            // Success of destroy must trigger the error handling.
            throw err
          })
      })
      .then(() => {
        return this._ql.connect.release(dbc)
      })
  }

  /**
   * After the commit there shall be no access to .run or the client.
   * Reference might have been copied, but cannot be supported.
   * @param {Object} context
   * @return {Client}
   * @private
   */
  _removeNoLongerNeededFromQL (context) {
    // Copy reference, so context can be wiped of QL related properties
    const dbc = context._.dbc

    delete context.run
    delete context._.dbc

    return dbc
  }

  _beforeEndTransactionBlock (command, dataOperations = []) {
    const handlers = []

    for (const dataOperation of dataOperations) {
      handlers.push(this._handlers.before.executeHandlerIfListed(command.toUpperCase(), dataOperation))
    }

    return Promise.all(handlers)
  }

  _afterEndTransactionBlock (command, success, dataOperations = []) {
    const handlers = []

    for (const dataOperation of dataOperations) {
      dataOperation.success = success

      handlers.push(this._handlers.after.executeHandlerIfListed(command.toUpperCase(), dataOperation))
    }

    return Promise.all(handlers)
  }

  _getAcquireOptions (context) {
    if (context._.req) {
      return {
        JWT: context.attr ? context.attr.token : undefined,
        tenantId: context.attr ? context.attr.identityZone : undefined,
        user: context._.req.user ? context._.req.user.id : undefined,
        locale: context._.req.locale
      }
    }

    return undefined
  }

  _addRunIfPrimarySessionExists (context) {
    // Add the function so that the connection can be released in case of errors in complex scenarios like OData batch
    if (context._.doNotFinishTransaction && !context._.endTransactionIfConnected) {
      // Wrap to easily maintain the scope of this
      context._.endTransactionIfConnected = (...args) => {
        return this._endTransactionIfConnected(...args)
      }
    }

    // cds.connect() has not been used yet
    if (!this._ql.connect.hasSession()) {
      return
    }

    const _run = (...args) => {
      // Run has been used before, but acquire is not done yet
      if (context._.dbc instanceof Promise) {
        return context._.dbc
          .then(() => {
            if (context._.dbc.stack) {
              throw context._.dbc
            }

            return context._.dbc.execute(...args)
          })
      }

      // There has been an error on acquire
      if (context._.dbc && context._.dbc.stack) {
        return Promise.reject(context._.dbc)
      }

      // Run has been used before and acquire is done
      if (context._.dbc) {
        return context._.dbc.execute(...args)
      }

      // Acquire and execute
      context._.dbc = this._ql.connect.acquire(this._getAcquireOptions(context))
        .then((client) => {
          context._.dbc = client
          client.setCSN(this.reflected)

          return client.begin()
        })
        .catch((err) => {
          context._.dbc = err

          throw err
        })
        .then(() => {
          return context._.dbc.execute(...args)
        })

      return context._.dbc
    }

    context.run = (...args) => {
      return this._addThenableToRun(_run(...args), _run)
    }
  }

  _addThenableToRun (promise, run) {
    const then = (fn) => {
      return promise.then(fn)
    }

    then.run = (...args) => {
      return this._addThenableToRun(promise
        .then(() => {
          return run(...args)
        }), run)
    }

    return {
      then: then,
      catch: (fn) => {
        return promise.catch(fn)
      }
    }
  }
}

module.exports = Service
