const {isCustomOperation} = require('../../adapter/odata-v4/utils/request')

// This is a temporary solution until the path control using "select ...where exist" is not implemented
// assumption: entity has one key - to be improved in the follow up implementation
const _getKeyValue = segment => {
  let val, isActive
  for (const keyPredicate of segment.getKeyPredicates()) {
    const keyName = keyPredicate.getEdmRef().getName()
    if (keyName === 'IsActiveEntity') {
      isActive = keyPredicate.getText()
    } else {
      val = keyPredicate.getText()
    }
  }

  return isActive === 'false' ? val : undefined
}

// This is a temporary solution until the path control using "select ...where exist" is not implemented
const getPathEntities = (model, context) => {
  const result = new Map()
  const serviceName = context.target.name.substring(
    0,
    context.target.name.lastIndexOf('.')
  )
  const segments = context._.odataReq.getUriInfo().getPathSegments()

  for (let i = 0, len = segments.length; i < len - 1; i++) {
    // exclude last segment
    let serviceEntityName
    if (segments[i].getKind() === 'NAVIGATION.TO.ONE') {
      serviceEntityName = `${serviceName}.${segments[i]
        .getNavigationProperty()
        .getEntityType()
        .getFullQualifiedName()
        .name}`
    } else {
      serviceEntityName = `${serviceName}.${segments[i]
        .getEntitySet()
        .getName()}`
    }

    if (
      model[serviceEntityName] &&
      model[serviceEntityName]['@odata.draft.enabled']
    ) {
      const draftTableName = `${serviceEntityName}_drafts`
      if (!result.has(draftTableName)) {
        result.set(draftTableName, [])
      }

      const keyValue = _getKeyValue(segments[i])
      if (keyValue) {
        result.get(draftTableName).push(keyValue)
      }
    }
  }

  return result
}
// -----------------------------------------------------------------------------------
// TODO odata-specific helpers for ../handlers/onCreateDraft - to be moved or replaced
// -----------------------------------------------------------------------------------
const isNavigationToMany = context => {
  const segments = context._.odataReq.getUriInfo().getPathSegments()
  return segments[segments.length - 1].getKind() === 'NAVIGATION.TO.MANY'
}

const getPartnerElement = context => {
  const segments = context._.odataReq.getUriInfo().getPathSegments()
  return segments[segments.length - 1]
    .getNavigationProperty()
    .getPartner()
    .getName()
}

// copied from adapter/odata-v4/utils/context-object
const _findSourceEntityNameAtService = (service, name) => {
  const serviceEntity = service.reflected.find(element => {
    return element.source === name
  })

  return serviceEntity ? serviceEntity.name : name
}

// copied from adapter/odata-v4/utils/context-object
const _getTargetEntityName = (service, pathSegments) => {
  if (isCustomOperation(pathSegments, false)) {
    return undefined
  }

  let navSegmentName
  let entityName = `${service.service}.${pathSegments[0]
    .getEntitySet()
    .getName()}`

  for (const navSegment of pathSegments.filter(
    segment => segment.getNavigationProperty() !== null
  )) {
    navSegmentName = navSegment.getNavigationProperty().getName()
    entityName =
      service.reflected.definitions[entityName].elements[navSegmentName].target
  }

  return _findSourceEntityNameAtService(service, entityName)
}

const _isRootEntity = (model, entityName) => {
  const entity = model[entityName]
  if (!entity) return false

  const associationElements = Object.keys(entity.elements)
    .map(key => entity.elements[key])
    .filter(({type}) => type === 'cds.Association')

  for (const {target} of associationElements) {
    const parentEntity = model[target]
    for (const parentElementName of Object.keys(parentEntity.elements)) {
      const parentElement = parentEntity.elements[parentElementName]
      if (
        parentElement.type === 'cds.Composition' &&
        parentElement.target === entityName
      ) {
        return false
      }
    }
  }

  return true
}

/**
 * Provide information about the parent entity, i.e. the entity that has the to-many composition element.
 * Limitation: only works for one key (besides IsActiveEntity)
 * @param service
 * @param context
 * @returns {Object}
 * @private
 */
const getParent = (service, context) => {
  const segments = context._.odataReq.getUriInfo().getPathSegments()

  const parent = {
    entityName: _getTargetEntityName(
      service,
      segments.slice(0, segments.length - 1)
    )
  }

  const parentKeyPredicates = segments[segments.length - 2].getKeyPredicates()
  let keyPredicateName, keyPredicateText
  for (const keyPredicate of parentKeyPredicates) {
    keyPredicateName = keyPredicate.getEdmRef().getName()
    keyPredicateText = keyPredicate.getText()

    if (keyPredicateName === 'IsActiveEntity') {
      parent.IsActiveEntity = keyPredicateText
    } else {
      parent.keyName = keyPredicateName
      parent.keyValue = keyPredicateText
    }
  }

  return parent
}

const _getCompositionTreeInternal = ({rootEntityName, model, compositionSet, compositionTree, parentEntityName}) => {
  compositionSet.add(parentEntityName)
  compositionTree.source = parentEntityName
  compositionTree.compositionElements = []
  compositionTree.backLinks = []

  const parentEntity = model[parentEntityName]
  const elements = Object.keys(parentEntity.elements).map(
    key => parentEntity.elements[key]
  )
  for (const element of elements) {
    if (
      element.type === 'cds.Composition' &&
      rootEntityName !== element.target
    ) {
      const subObject = {name: element.name}
      compositionTree.compositionElements.push(subObject)
      _getCompositionTreeInternal({
        rootEntityName,
        model,
        compositionSet,
        compositionTree: subObject,
        parentEntityName: element.target
      })
    }
    if (
      element.type === 'cds.Association' &&
      compositionSet.has(element.target) &&
      element.foreignKeys
    ) {
      for (const foreignKey of Object.keys(element.foreignKeys)) {
        compositionTree.backLinks.push({
          name: `${element.name}_${foreignKey}`,
          target: element.target
        })
      }
    }
  }
}

const _getCompositionSetInternal = (model, parentEntityName, compositions) => {
  compositions.add(parentEntityName)
  const parentEntity = model[parentEntityName]
  const subCompositions = Object.keys(parentEntity.elements)
    .map(key => parentEntity.elements[key])
    .filter(({type}) => type === 'cds.Composition')
  for (const {target} of subCompositions) {
    if (!compositions.has(target)) {
      _getCompositionSetInternal(model, target, compositions)
    }
  }
}

/**
 * Provides set of all underlying compositions.
 * @param {Object} model Definitions of the reflected model
 * @param {String} EntityName Name of the entity
 */
const getCompositionSet = (model, EntityName) => {
  const compositions = new Set()
  _getCompositionSetInternal(model, EntityName, compositions)

  return compositions
}

/**
 * Provides tree of all compositions.
 * @param {Object} model Definitions of the reflected model
 * @param {String} rootEntityName Name of the root entity
 */
const getCompositionTree = (model, rootEntityName, checkRoot = true) => {
  if (checkRoot && !_isRootEntity(model, rootEntityName)) {
    throw new Error('Entity is not root entity')
  }
  const compositionTree = {}
  const compositionSet = new Set()
  _getCompositionTreeInternal({
    rootEntityName,
    model,
    compositionSet,
    compositionTree,
    parentEntityName: rootEntityName
  })

  return compositionTree
}

module.exports = {
  getPathEntities,
  getCompositionSet,
  getCompositionTree,
  getPartnerElement,
  getParent,
  isNavigationToMany
}
