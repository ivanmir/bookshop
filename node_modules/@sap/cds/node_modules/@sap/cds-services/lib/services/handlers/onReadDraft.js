const {DB_CONNECTION_MISSING} = require('../utils/constants')

const _isTrue = val => val === true || val === 'true'

const _isFalse = val => val === false || val === 'false'

const _calculateSpliceArgs = (index, whereCondition) => {
  const AND_OR = ['and', 'or']
  if (AND_OR.includes(whereCondition[index - 1])) {
    return {index: index - 1, count: 4}
  }
  if (AND_OR.includes(whereCondition[index + 3])) {
    return {index: index, count: 4}
  }
  if (whereCondition[index - 1] === '(' && whereCondition[index + 3] === ')') {
    if (AND_OR.includes(whereCondition[index - 2])) {
      return {index: index - 2, count: 6}
    }
    if (AND_OR.includes(whereCondition[index + 4])) {
      return {index: index - 1, count: 6}
    }

    return {index: index - 1, count: 5}
  }
  return {index: index, count: 3}
}

const _deleteCondition = (index, whereCondition) => {
  const spliceArgs = _calculateSpliceArgs(index, whereCondition)
  whereCondition.splice(spliceArgs.index, spliceArgs.count)
}

const _readAndDeleteKeywords = (keywords, whereCondition) => {
  const index = whereCondition.findIndex(({inline, ref}) => {
    if (!ref) {
      return false
    }

    const refLastIndex = ref.length - 1

    if (keywords.length === 1) {
      return ref[refLastIndex] === keywords[0]
    }

    return inline ? (ref[refLastIndex] === keywords[0]) && (inline[0].ref[0] === keywords[1]) : false
  })

  if (index === -1) {
    return
  }

  const result = {op: whereCondition[index + 1], value: whereCondition[index + 2]}
  _deleteCondition(index, whereCondition)

  return result
}

const _getTableName = ({target: {name}, query: {SELECT: {from}}}, isDraft = false) => {
  const table = isDraft ? `${name}_drafts` : name
  const as = from.args ? from.args[0].as : from.as
  return {
    table: {
      ref: [table],
      as: as
    },
    as: as === undefined ? table : as
  }
}

const _getDraftTableNameFromDataEntity = (name, serviceName) => {
  const entityName = name.substring(name.lastIndexOf('.') + 1)

  return `${serviceName}.${entityName}_drafts`
}

const _getTargetKeys = ({target: {elements}}) => {
  return Object.keys(elements).filter((key) => elements[key].key).map((key) => elements[key].name)
}

const DRAFT_COLUMNS = ['IsActiveEntity', 'HasActiveEntity', 'HasDraftEntity', 'DraftAdministrativeData_DraftUUID']

const DRAFT_COLUMNS_CASTED = [
  {
    ref: ['IsActiveEntity'],
    cast: {type: 'cds.Boolean'}
  }, {
    ref: ['HasActiveEntity'],
    cast: {type: 'cds.Boolean'}
  },
  {
    ref: ['HasDraftEntity'],
    cast: {type: 'cds.Boolean'}
  },
  'DraftAdministrativeData_DraftUUID'
]

const DRAFT_ADMIN_COLUMNS_CASTED = [
  'DraftUUID',
  'CreationDateTime',
  'CreatedByUser',
  {
    ref: ['DraftIsCreatedByMe'],
    cast: {type: 'cds.Boolean'}
  },
  'LastChangeDateTime',
  'LastChangedByUser',
  'InProcessByUser',
  {
    ref: ['DraftIsProcessedByMe'],
    cast: {type: 'cds.Boolean'}
  }
]

// default draft values for active entities
const _getDefaultDraftProperties = hasDraft =>
  [
    {val: 1, as: 'IsActiveEntity', cast: {type: 'cds.Boolean'}},
    {val: 0, as: 'HasActiveEntity', cast: {type: 'cds.Boolean'}},
    {
      val: hasDraft === null ? null : Number(hasDraft),
      as: 'HasDraftEntity',
      cast: hasDraft === null ? null : {type: 'cds.Boolean'}
    },
    {val: null, as: 'DraftAdministrativeData_DraftUUID'}
  ]

// draft values for active entities with calculated hasDraft property
const _getDraftPropertiesDetermineDraft = (context, where) => {
  const {table} = _getTableName(context, true)

  const hasDraftQuery = context.statements.SELECT
    .from(table, [{xpr: [{ref: ['count', {args: '1'}]}, '!=', {val: 0}]}])
    .where(...where)

  hasDraftQuery.as = 'HasDraftEntity'
  hasDraftQuery.cast = {type: 'cds.Boolean'}

  return [
    {val: true, as: 'IsActiveEntity', cast: {type: 'cds.Boolean'}},
    {val: false, as: 'HasActiveEntity', cast: {type: 'cds.Boolean'}},
    hasDraftQuery,
    {val: null, as: 'DraftAdministrativeData_DraftUUID'}]
}

const _getEnrichedCQN = (cqn, select, draftWhere) => {
  if (draftWhere && draftWhere.length !== 0) {
    cqn = cqn.where(...draftWhere)
  }

  if (select.distinct) {
    cqn = cqn.distinct()
  }

  if (select.having) {
    cqn = cqn.having(...select.having)
  }

  // groupBy, orderBy and limit do not support partial CQNs
  if (select.groupBy) {
    cqn.SELECT.groupBy = select.groupBy
  }

  if (select.orderBy) {
    cqn.SELECT.orderBy = select.orderBy
  }

  if (select.limit) {
    cqn.SELECT.limit = select.limit
  }

  return cqn
}

const _whereContainsKeys = (context, whereDraft) => {
  const keys = _getTargetKeys(context)
  if (whereDraft.length < keys.length * 4 - 1) {
    return false
  }

  let i = 0
  let keyCount = 0
  while (i < whereDraft.length) {
    const element = whereDraft[i]
    const op = whereDraft[i + 1]
    if (element.ref && keys.some(x => x === element.ref[element.ref.length - 1]) && op === '=') { // op is EQ by keys
      i = i + 4
      keyCount++
      continue
    }

    i++
  }

  return (keyCount === keys.length)
}

const _isValidActive = (isActiveEntity, context, whereDraft) => {
  return isActiveEntity.op === '=' && _isTrue(isActiveEntity.value.val) &&
    _whereContainsKeys(context, whereDraft)
}

const _isValidDraftOfWhichIAmOwner = (isActiveEntity) => {
  return isActiveEntity.op === '=' && _isFalse(isActiveEntity.value.val)
}

const _isValidActiveWithoutDraft = (isActiveEntity, hasDraftEntity) => {
  return isActiveEntity.op === '=' && _isTrue(isActiveEntity.value.val) &&
    hasDraftEntity.op === '=' && _isFalse(hasDraftEntity.value.val)
}

const _isValidWithDraftLocked = (isActiveEntity, siblingIsActive, draftInProcessByUser) => {
  return isActiveEntity.op === '=' && _isTrue(isActiveEntity.value.val) &&
    siblingIsActive.op === '=' && siblingIsActive.value.val === null &&
    draftInProcessByUser.op === '!=' && draftInProcessByUser.value.val === ''
}

const _isValidWithDraftTimeout = (isActiveEntity, siblingIsActive, draftInProcessByUser) => {
  return isActiveEntity.op === '=' && _isTrue(isActiveEntity.value.val) &&
    siblingIsActive.op === '=' && siblingIsActive.value.val === null &&
    draftInProcessByUser.op === '=' && draftInProcessByUser.value.val === ''
}

const _isValidExcludeActiveDraftExists = (isActiveEntity, siblingIsActive) => {
  return isActiveEntity.op === '=' && _isFalse(isActiveEntity.value.val) &&
    siblingIsActive.op === '=' && siblingIsActive.value.val === null
}

const _draftAdminTable = (context, columns, serviceName) => {
  // Workaround: Add target by DraftAdminData in uri segment
  // TODO: Remove workaround, once new csn provided
  const segments = context._.odataReq.getUriInfo().getPathSegments()
  const lastSegment = segments[segments.length - 1]
  if (!lastSegment._target) {
    lastSegment.targetCount = 0
    lastSegment.getTarget = () => {
      lastSegment.targetCount++
      if (lastSegment.targetCount === 2) {
        return {
          getName: () => ''
        }
      }

      return lastSegment._target
    }
  }

  const {table} = _getTableName(context)

  let cqn = context.statements.SELECT.from(table)
  if (context.query.SELECT.columns) {
    cqn = cqn.columns(...context.query.SELECT.columns)
  }

  return _getEnrichedCQN(cqn, context.query.SELECT, context.query.SELECT.where)
}

const _allActive = (context, columns) => {
  const {table} = _getTableName(context)
  const draftColumns = _getDefaultDraftProperties(null) // TODO: calculate hasDraft for each entry

  const cqn = context.statements.SELECT.from(table)
    .columns(...columns, ...draftColumns)

  return _getEnrichedCQN(cqn, context.query.SELECT, context.query.SELECT.where)
}

const _active = (context, draftWhere, columns) => {
  const {table} = _getTableName(context)
  const draftColumns = _getDraftPropertiesDetermineDraft(context, draftWhere)

  const cqn = context.statements.SELECT.from(table)
    .columns(...columns, ...draftColumns)

  return _getEnrichedCQN(cqn, context.query.SELECT, draftWhere)
}

const _activeWithoutDraft = (context, draftWhere, columns) => {
  const {table} = _getTableName(context, true)
  const draftName = table.ref[0]
  const active = _getTableName(context)
  const keys = _getTargetKeys(context)

  let subSelect = context.statements.SELECT.from(draftName).columns(...keys)
  subSelect = keys.reduce((select, key) => subSelect.where({ref: [active.as, key]}, '=', {ref: [draftName, key]}), subSelect)

  let cqn = context.statements.SELECT.from(active.table).columns(...columns, ..._getDefaultDraftProperties(false))
    .where('not exists', subSelect)

  return _getEnrichedCQN(cqn, context.query.SELECT, draftWhere)
}

const _draftOfWhichIAmOwner = (context, draftWhere, columns) => {
  const {table, as} = _getTableName(context, true)
  const cqn = context.statements.SELECT.from(table)
    .columns(...columns, ...DRAFT_COLUMNS_CASTED)
    .join('DRAFT.DraftAdministrativeData', 'filterAdmin')
    .on({ref: [as, 'DraftAdministrativeData_DraftUUID']}, '=',
      {ref: ['filterAdmin', 'DraftUUID']})
    .where({ref: ['filterAdmin', 'CreatedByUser']}, '=', context.user.id)

  return _getEnrichedCQN(cqn, context.query.SELECT, draftWhere)
}

const _activeWithDraftInProcess = (context, draftWhere, columns, isLocked) => {
  const draft = _getTableName(context, true)
  const draftName = draft.table.ref[0]
  const active = _getTableName(context)
  const keys = _getTargetKeys(context)
  const draftColumns = _getDefaultDraftProperties(true)

  let subSelect = context.statements.SELECT.from(draftName)
    .columns(...keys)
    .join('DRAFT.DraftAdministrativeData')
    .on({ref: [draftName, 'DraftAdministrativeData_DraftUUID']}, '=',
      {ref: ['DRAFT.DraftAdministrativeData', 'DraftUUID']})

  if (isLocked) {
    subSelect = subSelect
      .where('InProcessByUser', '!=', {val: context.user.id}, 'and', 'InProcessByUser', '!=', {val: null})
  } else {
    subSelect = subSelect
      .where('LastChangedByUser', '!=', {val: context.user.id}, 'and', 'InProcessByUser', '=', {val: null})
  }

  subSelect = keys.reduce((select, key) => subSelect.where({ref: [active.as, key]}, '=', {ref: [draftName, key]}), subSelect)

  let cqn = context.statements.SELECT.from(active.table)
    .columns(...columns, ...draftColumns)
    .where('exists', subSelect)

  return _getEnrichedCQN(cqn, context.query.SELECT, draftWhere)
}

const _getCountColumns = (draftWhere) => {
  const columns = []

  for (const entry of draftWhere) {
    if (entry.ref) {
      if (entry.ref[0] === 'contains') {
        columns.push(...entry.ref[1].args[0].list)
      } else {
        columns.push(entry)
      }
    }
  }

  return (columns.length === 0) ? [{val: 1}] : columns
}

const _getUnionCQN = (context, draftName, columns, subSelect, draftWhere) => {
  if (columns.length === 1 && columns[0].as === 'counted') {
    const columnsFromWhere = _getCountColumns(draftWhere)

    return context.statements.SELECT.from({
      SET: {
        op: 'union',
        all: true,
        args: [
          context.statements.SELECT.from(draftName, columnsFromWhere),
          context.statements.SELECT.from(context.target.source, columnsFromWhere).where('not exists', subSelect)
        ]
      }
    }, columns)
  }

  return context.statements.SELECT.from({
    SET: {
      op: 'union',
      all: true,
      args: [
        context.statements.SELECT.from(draftName).columns(...columns, ...DRAFT_COLUMNS_CASTED),
        context.statements.SELECT.from(context.target.source).columns(...columns, ..._getDefaultDraftProperties(false))
          .where('not exists', subSelect)
      ]
    }
  }, [...columns, ...DRAFT_COLUMNS_CASTED])
}

const _excludeActiveDraftExists = (context, draftWhere, columns) => {
  const {table, as} = _getTableName(context, true)
  const draftName = table.ref[0]
  const keys = _getTargetKeys(context)

  let subSelect = context.statements.SELECT.from(draftName)
  subSelect = keys.reduce((select, key) => subSelect.where({ref: [context.target.source, key]}, '=', {ref: [draftName, key]}), subSelect)

  const cqn = _getUnionCQN(context, draftName, columns, subSelect, draftWhere)
  cqn.SELECT.from.as = as

  return _getEnrichedCQN(cqn, context.query.SELECT, draftWhere)
}

const _readDraftParameters = where => ({
  isActiveEntity: _readAndDeleteKeywords(['IsActiveEntity'], where),
  hasDraftEntity: _readAndDeleteKeywords(['HasDraftEntity'], where),
  siblingIsActive: _readAndDeleteKeywords(['SiblingEntity', 'IsActiveEntity'], where),
  draftInProcessByUser: _readAndDeleteKeywords(['DraftAdministrativeData', 'InProcessByUser'], where)
})

const _validatedActiveWithoutDraft = (context, draftWhere, draftParameters, columns) =>
  _isValidActiveWithoutDraft(draftParameters.isActiveEntity, draftParameters.hasDraftEntity)
    ? _activeWithoutDraft(context, draftWhere, columns)
    : undefined

const _validatedActiveWithDraftInProcess = (context, draftWhere, draftParameters, columns) => {
  if (draftParameters.draftInProcessByUser.op === '!=') {
    return _isValidWithDraftLocked(draftParameters.isActiveEntity, draftParameters.siblingIsActive,
      draftParameters.draftInProcessByUser)
      ? _activeWithDraftInProcess(context, draftWhere, columns, context.user.id)
      : undefined
  }

  return _isValidWithDraftTimeout(draftParameters.isActiveEntity, draftParameters.siblingIsActive,
    draftParameters.draftInProcessByUser)
    ? _activeWithDraftInProcess(context, draftWhere, columns, null)
    : undefined
}

const _validatedExcludeActiveDraftExists = (context, draftWhere, draftParameters, columns) =>
  _isValidExcludeActiveDraftExists(draftParameters.isActiveEntity, draftParameters.siblingIsActive)
    ? _excludeActiveDraftExists(context, draftWhere, columns)
    : undefined

const _validatedActive = (context, draftWhere, draftParameters, columns) =>
  _isValidActive(draftParameters.isActiveEntity, context, draftWhere)
    ? _active(context, draftWhere, columns)
    : undefined

const _validatedDraftOfWhichIAmOwner = (context, draftWhere, draftParameters, columns) =>
  _isValidDraftOfWhichIAmOwner(draftParameters.isActiveEntity)
    ? _draftOfWhichIAmOwner(context, draftWhere, columns)
    : undefined

const _generateCQN = (context, columns, serviceName) => {
  if (context.target.name === 'DRAFT.DraftAdministrativeData') {
    return _draftAdminTable(context, DRAFT_ADMIN_COLUMNS_CASTED, serviceName)
  }

  if (!context.query.SELECT.where || context.query.SELECT.where.length === 0) {
    return _allActive(context, columns)
  }

  const draftWhere = [...context.query.SELECT.where] // copy

  const draftParameters = _readDraftParameters(draftWhere)

  if (!draftParameters.isActiveEntity) {
    return _allActive(context, columns)
  }

  if (draftParameters.hasDraftEntity) {
    return _validatedActiveWithoutDraft(context, draftWhere, draftParameters, columns)
  }

  if (draftParameters.siblingIsActive) {
    return draftParameters.draftInProcessByUser
      ? _validatedActiveWithDraftInProcess(context, draftWhere, draftParameters, columns)
      : _validatedExcludeActiveDraftExists(context, draftWhere, draftParameters, columns)
  }

  return _isTrue(draftParameters.isActiveEntity.value.val)
    ? _validatedActive(context, draftWhere, draftParameters, columns)
    : _validatedDraftOfWhichIAmOwner(context, draftWhere, draftParameters, columns)
}

const _getColumns = ({query: {SELECT}}, model) => {
  const getColumns = require('../utils/columns') // _getColumns only called once

  return SELECT.columns
    ? SELECT.columns.filter(col => (col.ref && !DRAFT_COLUMNS.includes(col.ref[col.ref.length - 1])) || (!col.ref && !DRAFT_COLUMNS.includes(col)))
    : getColumns(model, model.definitions[SELECT.from.ref[0]]).map(col => col.name)
}

const _isIsActiveEntity = element => element.ref &&
  ((element.ref[0] === 'IsActiveEntity') ||
    (element.ref.length > 1 && element.ref[1] === 'IsActiveEntity'))

const _adaptSubSelects = ({SELECT: {from, where}}, serviceName) => {
  if (!where) {
    return
  }

  let indexDel = -1
  for (let i = 0, len = where.length; i < len; i++) {
    const element = where[i]
    if (_isIsActiveEntity(element) && len > i + 2) {
      const value = where[i + 2]
      if (_isFalse(value.val)) {
        from.ref[0] = _getDraftTableNameFromDataEntity(from.ref[0], serviceName)
      }
      indexDel = i
    }

    if (element.SELECT) {
      _adaptSubSelects(element, serviceName)
    }
  }

  if (indexDel !== -1) {
    _deleteCondition(indexDel, where)
  }
}

const cleanDraft = (service, context) => {
  // Workaround: Remove DraftAdminData from csn
  // TODO: Remove workaround, once new csn provided
  if (context.target.name === 'DRAFT.DraftAdministrativeData') {
    for (const key in service.reflected.definitions) {
      const entry = service.reflected.definitions[key]
      if (entry.elements && entry.elements['DraftAdministrativeData']) {
        delete entry.elements['DraftAdministrativeData']
      }
    }
  }
}

/**
 * Generic Handler for READ requests in the context of draft.
 *
 * @param context - operation object, that provides error, continuation and other functions as well as information
 * regarding the current operation.
 * @alias module:handlers.onRead
 */
const getOnReadDraft = service => context => {
  if (!context.run) {
    cleanDraft(service, context)
    context.log.warn(DB_CONNECTION_MISSING)
    return Promise.resolve([])
  }

  const cqn = _generateCQN(context, _getColumns(context, service.reflected), service.service)

  cleanDraft(service, context)

  if (!cqn) {
    return context.reject(400)
  }

  _adaptSubSelects(cqn, service.service)

  return context.run(cqn)
}

module.exports = getOnReadDraft
