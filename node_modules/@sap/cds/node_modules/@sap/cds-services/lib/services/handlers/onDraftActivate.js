const notFound = require('./notFound')
const cds = require('../../cds')
const {getError} = require('../../errors')
const {getCompositionSet, getCompositionTree} = require('../utils/compositionTree')
const {draftNamesForCompositionSet} = require('../utils/draftUtils')
const {DB_CONNECTION_MISSING} = require('../utils/constants')

const DRAFT_COLUMNS = [
  {
    ref: ['IsActiveEntity'],
    cast: {type: 'cds.Boolean'}
  }, {
    ref: ['HasActiveEntity'],
    cast: {type: 'cds.Boolean'}
  },
  {
    ref: ['HasDraftEntity'],
    cast: {type: 'cds.Boolean'}
  },
  'DraftAdministrativeData_DraftUUID'
]

const DRAFT_COLUMN_NAMES = ['IsActiveEntity', 'HasActiveEntity', 'HasDraftEntity', 'DraftAdministrativeData_DraftUUID']

const _keysOfEntity = (entity, data) =>
  Object.keys(cds.reflect(entity).keys)
    .reduce((res, key) => {
      res[key] = data[key]
      return res
    }, {})

const _selectCQNForBaseDraft = ({statements: {SELECT}, target: {name}}, keys) =>
  SELECT.from(`${name}_drafts`)
    .columns(['*', ...DRAFT_COLUMNS])
    .where(keys)

const _selectFromDraftAdminTable = ({statements: {SELECT}}, draftUUID) =>
  SELECT.from('DRAFT.DraftAdministrativeData').where({DraftUUID: draftUUID})

const _hasCompositionToTarget = (definition, target) =>
  Object.keys(definition.elements)
    .map(elementName => definition.elements[elementName])
    .some(element => element.type === 'cds.Composition' && element.target === target)

const _hasParentEntity = (definitions, target) =>
  Object.keys(definitions).map(definitionName => definitions[definitionName])
    .filter(definition => definition.kind === 'entity')
    .some(definition => _hasCompositionToTarget(definition, target))

const _selectCQNsForDraft = ({run, statements: {SELECT}}, drafts, draftUUID) =>
  drafts.map(draft => run(SELECT.from(draft).where({DraftAdministrativeData_DraftUUID: draftUUID})))

const _deleteCQNsForDraftAndAdminTable = ({run, statements: {DELETE}}, drafts, draftUUID) => {
  const deletes = drafts.map(draft => run(DELETE.from(draft).where({DraftAdministrativeData_DraftUUID: draftUUID})))
  deletes.push(run(DELETE.from('DRAFT.DraftAdministrativeData').where({DraftUUID: draftUUID})))

  return deletes
}

const _removeDraftColumns = (entry) =>
  Object.keys(entry)
    .reduce((res, key) => {
      if (!DRAFT_COLUMN_NAMES.includes(key)) {
        res[key] = entry[key]
      }
      return res
    }, {})

const _getInsertsAndUpdates = (results) => {
  const inserts = []
  const updates = []

  for (const result of results) {
    result.HasActiveEntity ? updates.push(result) : inserts.push(result)
  }

  return {inserts, updates}
}

const _createUpdateQueries = (localClient, context, entity, results) =>
  results.map(result => {
    const data = _removeDraftColumns(result)
    const keys = _keysOfEntity(entity, data)

    return localClient.update(entity).set(data).where(keys).with(context)
  })

const _insertOrUpdateWithLocalClient = (localClient, context, entities, draftResults) => {
  const queries = []
  for (let i = 0, length = entities.length; i < length; i++) {
    if (draftResults[i].length < 1) {
      continue
    }

    const {inserts, updates} = _getInsertsAndUpdates(draftResults[i])

    if (updates.length > 0) {
      queries.push(..._createUpdateQueries(localClient, context, entities[i], updates))
    }

    if (inserts.length > 0) {
      const entries = inserts.map(draftResult => _removeDraftColumns(draftResult))
      queries.push(localClient.insert(entities[i]).entries(entries).with(context)
        .catch(Promise.reject))
    }
  }

  return queries
}

const _createDeleteStatements = (context, tree, draftUUID, rootKeys, csnEntitiesOfDrafts) => {
  const {SELECT, DELETE} = context.statements

  const deletes = []

  for (const composition of tree.compositionElements) {
    const keyOfParent = Object.keys(cds.reflect(csnEntitiesOfDrafts.find(entity => entity.source === composition.backLinks[0].target)).keys)[0]

    const selectFromParent = SELECT.from(composition.backLinks[0].target, [keyOfParent])
    rootKeys.SELECT ? selectFromParent.where(tree.backLinks[0].name, 'IN', rootKeys) : selectFromParent.where(rootKeys)

    const csnEntityOfComposition = csnEntitiesOfDrafts.find(entity => entity.source === composition.source)
    const keyOfComposition = Object.keys(cds.reflect(csnEntityOfComposition).keys)[0]
    const selectFromDraft = SELECT.from(`${csnEntityOfComposition.name}_drafts`, [keyOfComposition]).where('DraftAdministrativeData_DraftUUID', '=', draftUUID)

    deletes.push(DELETE.from(composition.source)
    // currently only one key is supported
      .where(composition.backLinks[0].name, 'IN', selectFromParent)
      .where(keyOfComposition, 'NOT IN', selectFromDraft)
    )

    if (composition.compositionElements.length > 0) {
      deletes.push(..._createDeleteStatements(context, composition, draftUUID, selectFromParent, csnEntitiesOfDrafts))
    }
  }

  return deletes
}

const _deleteWhereDraftNotExists = (context, tree, draftUUID, rootKeys, csnEntitiesOfDrafts) =>
  _createDeleteStatements(context, tree, draftUUID, rootKeys, csnEntitiesOfDrafts)
    .reverse()
    .reduce((res, stmt) => {
      return res
        .then(() => context.run(stmt)
          .catch(Promise.reject)
        )
    }, Promise.resolve())

const _setStatusCodeAndHeader = (response, keys) => {
  response.setStatusCode(201)

  const keysString = Object.keys(keys).map(key => `${key}=${keys[key]}`).join(',')
  response.setHeader('location', `EntitySet(${keysString},IsActiveEntity=true)`)
}

const _adaptResult = (result) => {
  result.IsActiveEntity = true
  delete result.DraftAdministrativeData_DraftUUID

  return result
}

/**
 * Generic Handler for ActivationAction requests.
 * In case of success it returns the prepared draft entry.
 *
 * @param context - operation object, that provides error, continuation and other functions as well as information
 * regarding the current operation.
 * @alias module:handlers.onDraftActivate
 */
const onDraftActivate = ({localClient, definitions}) => (context) => {
  if (!context.run) {
    context.log.warn(DB_CONNECTION_MISSING)
    return Promise.reject(notFound(context))
  }

  // TODO path length is currently fetched from okra
  if (context.data['IsActiveEntity'] !== 'false' || context._.odataReq.getUriInfo().getPathSegments().length > 2 || _hasParentEntity(definitions, context.target.source)) {
    return Promise.reject(getError(400))
  }

  const keysOfRootEntity = _keysOfEntity(context.target, context.data)

  return context.run(_selectCQNForBaseDraft(context, keysOfRootEntity))
    .then((entityResult) => {
      if (entityResult.length === 0) {
        throw notFound(context)
      }

      const draftUUID = entityResult[0].DraftAdministrativeData_DraftUUID

      return context.run(_selectFromDraftAdminTable(context, draftUUID))
        .then((draftAdminResult) => {
          // Potential timeout scenario supported
          if (draftAdminResult[0].InProcessByUser && draftAdminResult[0].InProcessByUser !== context.user.id) {
            throw getError(403)
          }

          const draftNames = draftNamesForCompositionSet(getCompositionSet(definitions, context.target.source), definitions, context)
          const csnEntitiesOfDrafts = draftNames.map(name => definitions[name.replace('_drafts', '')])

          return Promise.all(_selectCQNsForDraft(context, draftNames, draftUUID))
            .then((draftResults) => Promise.all(_insertOrUpdateWithLocalClient(localClient, context, csnEntitiesOfDrafts, draftResults)))
            .then(() => {
              const tree = getCompositionTree(definitions, context.target.source)
              // delete active documents that were deleted in draft
              if (entityResult[0].HasActiveEntity) {
                return _deleteWhereDraftNotExists(context, tree, draftUUID, keysOfRootEntity, csnEntitiesOfDrafts)
              }
            })
            .then(() => Promise.all(_deleteCQNsForDraftAndAdminTable(context, draftNames, draftUUID)))
            .then(() => {
              _setStatusCodeAndHeader(context._.odataRes, keysOfRootEntity)
              return _adaptResult(entityResult[0])
            })
        })
    })
}

module.exports = onDraftActivate
