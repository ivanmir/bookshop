const {AuditLogNotWritten} = require('../../errors')

const _getCredentials = (auditlog) => {
  return require('./xsenv')('auditlog', auditlog) || {logToConsole: true}
}

const _getFromRow = (entity, relevantColumns, row) => {
  const dataSubject = {keys: {}}
  const attributes = {}
  const keys = {}
  const properties = Object.keys(row)

  for (const property of properties) {
    if (relevantColumns.keys[property]) {
      keys[property] = row[property].toString()
    }

    if (relevantColumns.personal[property]) {
      attributes[property] = row[property]
    }
  }

  if (entity['@PersonalData.EntitySemantics'] === 'DataSubject') {
    dataSubject.type = entity.name
    dataSubject.keys = keys
  } else {
    dataSubject.type = row[relevantColumns.fieldSemantics.type.name]
    dataSubject.role = row[relevantColumns.fieldSemantics.role.name]

    const fieldSemanticsKeys = Object.keys(relevantColumns.fieldSemantics.keys)

    for (const key of fieldSemanticsKeys) {
      dataSubject.keys[key] = row[key].toString()
    }
  }

  return {attributes, dataSubject, keys}
}

const _keysToString = (keys) => {
  const strings = []
  for (const key in keys) {
    strings.push(`${key}: ${keys[key]}`)
  }

  return strings.join(', ')
}

const _logAttributes = (log, attributes) => {
  for (const attribute in attributes) {
    log = log.attribute({name: attribute})
  }
}

const _logTenant = (log, tenant) => {
  log = tenant ? log.tenant(tenant) : log
}

/**
 * Logs securityMessage that user is not authorized.
 *
 * @param auditLogger - the audit logger
 * @param credentials - credentials for audit log instance
 * @param logger - logger object
 * @param user - user if provided via basic auth, if not  => ip address
 * @param ip - ip address of the user
 * @private
 */
const _logUnauthorized = (auditLogger, credentials, logger, {user, ip}) => {
  auditLogger.v2(credentials, function (err, auditlog) {
    if (err) {
      // TODO: Decide for a more meaningful error message
      return logger.error(`Error occurred while writing audit log: ${err}`)
    }

    let log = auditlog.securityMessage('Unsuccessful login attempt').by(user)

    log = ip ? log.externalIP(ip) : log

    log.log(function (err) {
      if (err) {
        return logger.error(`Error occurred while writing audit log: ${err}`)
      }
    })
  })
}

/**
 * Logs securityMessage that user does not have sufficient permissions.
 *
 * @param auditLogger - the audit logger
 * @param credentials - credentials for audit log instance
 * @param logger - logger object
 * @param user - user that has not sufficient privileges
 * @param ip - ip address of the user
 * @param tenant - tenant of the user
 * @private
 */
const _logMissingPermissions = (auditLogger, credentials, logger, {user, ip, tenant}) => {
  auditLogger.v2(credentials, function (err, auditlog) {
    if (err) {
      return logger.error(`Error occurred while writing audit log: ${err}`)
    }

    let log = auditlog.securityMessage('User does not have required permissions').by(user)

    log = ip ? log.externalIP(ip) : log

    log = tenant ? log.tenant(tenant) : log

    log.log(function (err) {
      if (err) {
        return logger.error(`Error occurred while writing audit log: ${err}`)
      }
    })
  })
}

/**
 *
 * Logs data read access.
 *
 * @param auditLogger - the audit logger
 * @param credentials - credentials for audit log instance
 * @param context - the context object
 * @param relevantColumns - columns, that are marked as @PersonalData.*
 * @param tenant - tenant of the user
 * @param user - user that has not sufficient privileges
 * @returns {Promise}
 * @private
 */
const _logReadAccess = (auditLogger, credentials, {context, relevantColumns, tenant, user}) => {
  const {result, target} = context
  const promises = []
  for (const row of result) {
    const promise = new Promise((resolve, reject) => {
      auditLogger.v2(credentials, function (err, auditlog) {
        if (err) {
          return reject(new AuditLogNotWritten(err, 'before commit', 'READ'))
        }

        const {dataSubject, attributes, keys} = _getFromRow(target, relevantColumns, row)

        try {
          let log = auditlog.read({type: target.name, id: {key: _keysToString(keys)}})

          _logAttributes(log, attributes)

          log = log.dataSubject({type: dataSubject.type, id: dataSubject.keys, role: dataSubject.role})

          _logTenant(log, tenant)

          log = log.by(user)

          log.log(function (err) {
            if (err) {
              return reject(new AuditLogNotWritten(err, 'before commit', 'READ'))
            }
            resolve()
          })
        } catch (err) {
          return reject(new AuditLogNotWritten(err, 'before commit', 'READ'))
        }
      })
    })

    promises.push(promise)
  }

  return Promise.all(promises)
}

/**
 *
 * Logs diff of a data manipulation event.
 *
 * @param auditLogger - the audit logger
 * @param credentials - credentials for audit log instance
 * @param context - the context object
 * @param relevantColumns - columns, that are marked as @PersonalData.*
 * @param tenant - tenant of the user
 * @param user - the current user
 * @param phase - the phase the logDataChange handler was triggered in
 * @returns {Promise}
 * @private
 */
const _logDataChange = (auditLogger, credentials, {context, relevantColumns, tenant, user, phase}) => {
  const {data, diff, target, oldData} = context
  return new Promise((resolve, reject) => {
    auditLogger.v2(credentials, function (err, auditlog) {
      if (err) {
        return reject(new AuditLogNotWritten(err, phase))
      }

      const {dataSubject, attributes, keys} = _getFromRow(target, relevantColumns, oldData || data)

      try {
        let log = auditlog.update({type: target.name, id: {key: _keysToString(keys)}})

        for (const difference of diff) {
          if (attributes[difference.name]) {
            log = log.attribute(Object.assign({new: '', old: ''}, difference))
          }
        }

        log = log.dataSubject({type: dataSubject.type, id: dataSubject.keys, role: dataSubject.role})

        log = tenant ? log.tenant(tenant) : log

        log = log.by(user)

        log.logPrepare(function (err) {
          if (err) {
            return reject(new AuditLogNotWritten(err, phase))
          }
          context._.auditLogContinuation = log
          resolve()
        })
      } catch (err) {
        return reject(new AuditLogNotWritten(err, phase))
      }
    })
  })
}

/**
 * Initializes the audit log object.
 * If options.auditlog provided, it looks via xsenv for a configured audit log instance.
 * If not, logs the audit events to the logger object (if provided via options, if not to console).
 * @param {Object} auditlog - the service options
 * @param {Object} logger - the logger object
 * @returns {Object} - with convenience methods logUnauthorized and logMissingPermissions to write audit logs
 */
const initialize = (auditlog, logger) => {
  try {
    const credentials = _getCredentials(auditlog)
    const auditLogger = require('@sap/audit-logging')

    return {
      logDataChange: (info) => {
        return _logDataChange(auditLogger, credentials, info)
      },
      logReadAccess: (info) => {
        return _logReadAccess(auditLogger, credentials, info)
      },
      logUnauthorized: (info) => {
        return _logUnauthorized(auditLogger, credentials, logger, info)
      },
      logMissingPermissions: (info) => {
        return _logMissingPermissions(auditLogger, credentials, logger, info)
      }
    }
  } catch (err) {
    if (process.env.NODE_ENV === 'production') {
      throw err
    }

    return {
      logDataChange: (info) => {
        logger.log(info)
        return Promise.resolve()
      },
      logReadAccess: (info) => {
        logger.log(info)
        return Promise.resolve()
      },
      logUnauthorized: logger.warn,
      logMissingPermissions: logger.warn
    }
  }
}

module.exports = initialize
