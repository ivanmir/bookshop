const cds = require('../../cds')

const IS_BATCH = Symbol.for('IS_BATCH')
const OPEN_REQUESTS = Symbol.for('OPEN_REQUESTS')

/**
 * Local service client.
 */
class Client {
  /**
   * @param {Service} cdsService
   * @throws ModelNotDefined - in case no or an invalid csn model is provided.
   */
  constructor (cdsService) {
    if (!(cdsService instanceof require('../../services/Service'))) {
      const {NoServiceFound} = require('../../errors')
      throw new NoServiceFound()
    }

    this._cdsService = cdsService
    this.entities = cdsService.entities
    this._addCustomEvents(require('../../cds').reflect(cdsService.definition))
  }

  /**
   * Lookup CSN for any kind of non standard actions and functions.
   * Add them as static functions to this instance.
   * @param reflectedModel {Object}
   * @private
   */
  _addCustomEvents (reflectedModel) {
    this._addBoundEvents(reflectedModel)
    this._addUnboundEvents(reflectedModel)
  }

  /**
   * Find all bound actions and functions.
   * Add them as static functions to this instance.
   * @param reflectedModel
   * @private
   */
  _addBoundEvents (reflectedModel) {
    const entities = reflectedModel.all((element) => {
      return (element.kind === 'entity' && element.actions)
    })

    for (const entity of entities) {
      for (const name of Object.keys(entity.actions)) {
        this._createFunctionsAndActions(name, entity.actions[name], entity)
      }
    }
  }

  /**
   * Find all unbound actions and functions.
   * Add them as static functions to this instance.
   * @param reflectedModel {Object}
   * @private
   */
  _addUnboundEvents (reflectedModel) {
    const elements = reflectedModel.all((element) => {
      return (element.kind === 'action' || element.kind === 'function')
    })

    for (const element of elements) {
      const [, name] = element.name.match(/^(?:.*\.)?([^.]+)$/)
      this._createFunctionsAndActions(name, element)
    }
  }

  /**
   * Create handlers for functions and actions and add them to the instance of the client.
   * @param name {string}
   * @param element {Object}
   * @param [entity] {Object}
   * @private
   */
  _createFunctionsAndActions (name, element, entity) {
    const argsParser = require('./handlers/arguments')(element, entity)
    const postProcess = require('./handlers/post-process')(element)

    this[name] = (...args) => {
      let _context

      const promise = new Promise((resolve, reject) => {
        Promise.resolve().then(() => {
          this._eventToService(name, entity, undefined, argsParser(args), _context)
            .then(postProcess)
            .then(result => {
              resolve(result)
            })
            .catch(err => {
              this._eventToService(name, entity, undefined, argsParser(args), _context)
              reject(err)
            })
        })
      })

      promise.with = context => {
        _context = this._startTransactionProperty(context)
        return promise
      }

      return promise
    }
  }

  /**
   * Read an entity and use any prototype function the SELECT API offers.
   * @param entity {Object}
   * @param [columns] {Array}
   * @returns {Promise}
   */
  read (entity, columns) {
    return this._promised('READ', entity, columns)
  }

  /**
   * Insert an entity and use any prototype function the INSERT API offers.
   * @param entity {Object}
   * @returns {Promise}
   */
  insert (entity) {
    return this._promised('CREATE', entity)
  }

  /**
   * Update an entity and use any prototype function the UPDATE API offers.
   * @param entity {Object}
   * @returns {Promise}
   */
  update (entity) {
    return this._promised('UPDATE', entity)
  }

  /**
   * Delete an entity and use any prototype function the DELETE API offers.
   * @param entity {Object}
   * @returns {Promise}
   */
  delete (entity) {
    return this._promised('DELETE', entity)
  }

  /**
   * Run any type of query against the service
   * @param query
   */
  run (query) {
    if (typeof query === 'string') {
      query = cds.parse.cql(query)
    }

    return this._runCqnByService(query)
  }

  _runCqnByService (query) {
    if (!query) {
      return Promise.reject(new this._errors.FeatureNotSupported())
    }

    if (query.SELECT) {
      return this._cqnToService('READ', this._getEntity(query.SELECT.from), query)
    }

    if (query.INSERT) {
      return this._cqnToService('CREATE', query.INSERT.into, query)
    }

    if (query.UPDATE) {
      return this._cqnToService('UPDATE', query.UPDATE.entity, query)
    }

    if (query.DELETE) {
      return this._cqnToService('DELETE', query.DELETE.from, query)
    }

    return Promise.reject(new this._errors.FeatureNotSupported())
  }

  _getEntity (from) {
    if (from.hasOwnProperty('join')) {
      from = (from.args[0].ref) ? from.args[0] : from.args[from.args.length - 1]
    }

    return from.ref[from.ref.length - 1]
  }

  _runCqnAtService (event, entity, query, context) {
    const normalizedEntity = this._validateEntity(entity)

    if (!normalizedEntity) {
      return Promise.reject(new this._errors.NotInModel(entity))
    }

    return this._eventToService(event, normalizedEntity, query, undefined, context)
  }

  _cqnToService (event, entity, query) {
    let _context

    const promise = new Promise((resolve, reject) => {
      Promise.resolve().then(() => {
        this._runCqnAtService(event, entity, query, _context)
          .then(result => {
            resolve(result)
          })
          .catch(err => {
            reject(err)
          })
      })
    })

    promise.with = context => {
      _context = this._startTransactionProperty(context)
      return promise
    }

    return promise
  }

  /**
   * Lazy loading and decoration of QL API.
   * @returns {Object}
   * @private
   */
  get _statements () {
    const {statements: {SELECT, INSERT, UPDATE, DELETE}} = require('@sap/cds-ql')
    const statements = {
      SELECT: {
        from: (entity, columns) => {
          return SELECT.from(entity, columns, this._cdsService.reflected)
        },
        one: (entity, columns) => {
          return SELECT.one(entity, columns, this._cdsService.reflected)
        }
      },
      INSERT: INSERT,
      UPDATE: UPDATE,
      DELETE: DELETE
    }

    Object.defineProperty(this, '_statements', {value: statements})

    return statements
  }

  /**
   * Lazy loading of errors.
   * @returns {Object}
   * @private
   */
  get _errors () {
    const errors = require('../../errors')

    Object.defineProperty(this, '_errors', {value: errors})

    return errors
  }

  // TODO: Remove this dirty hack
  _generateProperties (obj, properties) {
    properties.push(...Object.getOwnPropertyNames(obj))
    const prototype = Object.getPrototypeOf(obj)
    if (prototype === null || prototype.hasOwnProperty('__defineSetter__')) {
      return
    }
    this._generateProperties(prototype, properties)
  }

  _startTransactionProperty (context) {
    if (!context._) {
      context._ = {}
    }

    // Batch request request
    if (context._.doNotFinishTransaction) {
      if (!context._[OPEN_REQUESTS]) {
        context._[IS_BATCH] = true
      } else {
        context._[OPEN_REQUESTS]++
      }
    } else {
      context._.doNotFinishTransaction = true
      context._[OPEN_REQUESTS] = 1
    }

    return context
  }

  /**
   * Extend an QL API object instance to be a promise.
   * If then or catch are used, the query is run against the data source.
   * @param event {String}
   * @param entity {Object}
   * @param [columns] {Array}
   * @returns {Promise}
   * @private
   */
  _promised (event, entity, columns) {
    const normalizedEntity = this._validateEntity(entity)
    let _context

    const _enrichPromise = (promise, cqn) => {
      if (cqn) {
        const properties = []

        this._generateProperties(cqn, properties)

        for (const property of properties) {
          if (!promise.hasOwnProperty(property)) {
            promise[property] = cqn[property]
          }
        }
      }

      promise.with = context => {
        _context = this._startTransactionProperty(context)
        return promise
      }
    }

    if (!normalizedEntity) {
      const result = Promise.resolve().then(() => {
        throw new this._errors.NotInModel((typeof entity === 'object') ? entity.name : entity)
      })
      _enrichPromise(result)
      return result
    }

    const cqn = this._getCQN(event, normalizedEntity, columns)

    const promise = new Promise((resolve, reject) => {
      Promise.resolve().then(() => {
        this._eventToService(event, normalizedEntity, cqn, undefined, _context)
          .then(result => {
            resolve(result)
          })
          .catch(err => {
            reject(err)
          })
      })
    })

    _enrichPromise(promise, cqn)
    return promise
  }

  /**
   * Try to find the entity or identify the entity given as string.
   * @param entity {Object}
   * @returns {Object|Boolean}
   * @private
   */
  _validateEntity (entity) {
    if (!entity) {
      return false
    }

    const name = (typeof entity === 'object') ? entity.name : entity

    if (this._cdsService.definition.definitions[name]) {
      return this._cdsService.definition.definitions[name]
    }

    if (this._cdsService.definition.definitions[`${this._cdsService._options.service}.${name}`]) {
      return this._cdsService.definition.definitions[`${this._cdsService._options.service}.${name}`]
    }

    const parts = name.split('_')

    return (parts.length === 1) ? false : this._validateEntity(parts.pop())
  }

  /**
   * The default events for actions and functions are well known.
   * Translate them into constructing calls against the QL API.
   * @param event {String}
   * @param entity {Object}
   * @param [columns] {Array}
   * @returns {Object}
   * @private
   */
  _getCQN (event, entity, columns) {
    switch (event) {
      case 'READ':
        return this._statements.SELECT.from(entity, columns, this._cdsService.reflected)
      case 'CREATE':
        return this._statements.INSERT.into(entity)
      case 'UPDATE':
        return this._statements.UPDATE(entity)
      case 'DELETE':
        return this._statements.DELETE.from(entity)
    }
  }

  /**
   * Create a context object for the service call.
   * @param [entity] {Object}
   * @param [cqn] {Object}
   * @param [data] {Object}
   * @param [sharedContext] {Object}
   * @returns {*}
   * @private
   */
  _createContextObject (entity, cqn, data, sharedContext) {
    const cqnToData = require('./handlers/cqn-to-data')
    const context = {
      get data () {
        const parsed = data || cqnToData(cqn)
        Object.defineProperty(context, 'data', {value: parsed})
        return parsed
      },
      statements: this._statements,
      _: (sharedContext) ? sharedContext._ : {}
    }

    if (entity) {
      context.target = entity
    }

    if (cqn) {
      context.query = cqn
    }

    if (sharedContext && sharedContext.run) {
      context.run = sharedContext.run
    }

    return context
  }

  _endTransactionProperty (_) {
    if (_[IS_BATCH]) {
      return
    }

    _[OPEN_REQUESTS]--

    if (_[OPEN_REQUESTS] === 0) {
      delete _.doNotFinishTransaction
    }
  }

  /**
   * Dispatch the API call to the underlying service.
   * @param event {String}
   * @param entity {Object}
   * @param cqn {Object}
   * @param [data] {Object}
   * @param [sharedContext] {Object}
   * @returns {Promise<Array>}
   * @private
   */
  _eventToService (event, entity, cqn, data, sharedContext) {
    return new Promise((resolve, reject) => {
      let context

      Promise.resolve().then(() => {
        try {
          context = this._createContextObject(entity, cqn, data, sharedContext)
        } catch (error) {
          return reject(error)
        }
      }).then(() => {
        this._cdsService.processEvent(event, context)
          .then((result) => {
            this._endTransactionProperty(context._)

            resolve(result)
          })
          .catch((err) => {
            this._endTransactionProperty(context._)

            reject(err)
          })
      })
    })
  }
}

module.exports = Client
