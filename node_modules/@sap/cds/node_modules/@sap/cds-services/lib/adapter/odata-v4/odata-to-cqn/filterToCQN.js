const odata = require('@sap/odata-v4')
const ExpressionKind = odata.uri.Expression.ExpressionKind
const BinaryOperatorKind = odata.uri.BinaryExpression.OperatorKind
const UnaryOperatorKind = odata.uri.UnaryExpression.OperatorKind
const MethodKind = odata.uri.MethodExpression.MethodKind
const ResourceKind = odata.uri.UriResource.ResourceKind
const EdmPrimitiveTypeKind = odata.edm.EdmPrimitiveTypeKind
const {FeatureNotSupported} = require('../../../errors')

const _binaryOperatorToCQN = new Map()
_binaryOperatorToCQN.set(BinaryOperatorKind.EQ, '=')
_binaryOperatorToCQN.set(BinaryOperatorKind.NE, '!=')
_binaryOperatorToCQN.set(BinaryOperatorKind.GE, '>=')
_binaryOperatorToCQN.set(BinaryOperatorKind.GT, '>')
_binaryOperatorToCQN.set(BinaryOperatorKind.LE, '<=')
_binaryOperatorToCQN.set(BinaryOperatorKind.LT, '<')

const _convert = (expression) => {
  const type = expression.getType()

  if (!type) {
    return null
  }

  const value = expression.getText()

  switch (type) {
    case EdmPrimitiveTypeKind.Boolean:
      return (value === true || value === 'true')
    case EdmPrimitiveTypeKind.Byte:
    case EdmPrimitiveTypeKind.SByte:
    case EdmPrimitiveTypeKind.Int16:
    case EdmPrimitiveTypeKind.Int32:
      return parseInt(value)
    case EdmPrimitiveTypeKind.Decimal:
    case EdmPrimitiveTypeKind.Single:
    case EdmPrimitiveTypeKind.Double:
      return parseFloat(value)
    default:
      return value
  }
}

const _segmentFromMember = (segment) => {
  switch (segment.getKind()) {
    case ResourceKind.PRIMITIVE_PROPERTY:
    case ResourceKind.COMPLEX_PROPERTY:
    case ResourceKind.PRIMITIVE_COLLECTION_PROPERTY:
    case ResourceKind.COMPLEX_COLLECTION_PROPERTY:
      return segment.getProperty().getName()
    case ResourceKind.NAVIGATION_TO_ONE:
      return segment.getNavigationProperty().getName()
    default:
      throw new FeatureNotSupported(`ResourceKind ${segment.getKind()} is not supported`)
  }
}

const _getMemberRecursively = (pathSegments) => {
  const [segment, ...nextSegments] = pathSegments

  if (segment.getKind() === ResourceKind.NAVIGATION_TO_ONE) {
    return `${_segmentFromMember(segment)}.{${_getMemberRecursively(nextSegments)}}`
  }

  return _segmentFromMember(segment)
}

const _member = (expression) => {
  return _getMemberRecursively(expression.getPathSegments())
}

const _getParameters = (expression) => {
  return expression.getParameters().map((parameter) => {
    return filterToCQN(parameter)
  })
}

const _like = (column, value, operator) => {
  const like = (operator) ? 'not like' : 'like'

  return {
    [column]: {
      [like]: value
    }
  }
}

/**
 * Evaluate an method expression, which in SQL would be 'column condition value'.
 * Can also be nested.
 * @param {Object} expression
 * @param {string} [operator] - Operator, that might be used to invert a method or similar
 * @private
 */
const _method = (expression, operator) => {
  const parameters = _getParameters(expression)

  switch (expression.getMethod()) {
    case MethodKind.CONTAINS:
      return _like(parameters[0], `%${parameters[1]}%`, operator)
    case MethodKind.STARTSWITH:
      return _like(parameters[0], `${parameters[1]}%`, operator)
    case MethodKind.ENDSWITH:
      return _like(parameters[0], `%${parameters[1]}`, operator)
    default:
      throw new FeatureNotSupported(`Method ${expression.getMethod()} is not supported`)
  }
}

const _compare = (operator, left, right) => {
  return {
    [left]: {
      [_binaryOperatorToCQN.get(operator)]: right
    }
  }
}

const _binary = (expression) => {
  const operator = expression.getOperator()
  const left = filterToCQN(expression.getLeftOperand())
  const right = filterToCQN(expression.getRightOperand())

  switch (operator) {
    case BinaryOperatorKind.AND:
      // TODO: implement as adding to the and array so far the where assembly task done
      return left.and ? Object.assign(right, {and: left}) : Object.assign(left, {and: right})
    case BinaryOperatorKind.OR:
      return Object.assign(left, {or: right})
    case BinaryOperatorKind.EQ:
    case BinaryOperatorKind.NE:
    case BinaryOperatorKind.GE:
    case BinaryOperatorKind.GT:
    case BinaryOperatorKind.LE:
    case BinaryOperatorKind.LT:
      return _compare(operator, left, right)
    default:
      throw new FeatureNotSupported(`BinaryOperator ${expression.getOperator()} is not supported`)
  }
}

const _unary = (expression) => {
  if (expression.getOperator() !== UnaryOperatorKind.NOT) {
    throw new FeatureNotSupported(`UnaryOperator ${expression.getOperator()} is not supported`)
  }

  return filterToCQN(expression.getOperand(), UnaryOperatorKind.NOT)
}

/**
 * Convert a odata-v4 filter expression object into a CQN object.
 *
 * @param {Object} expression - odata filter expression
 * @param {string} [operator] - Operator, that might be used to invert a method or similar
 * @private
 */
const filterToCQN = (expression, operator) => {
  switch (expression.getKind()) {
    case ExpressionKind.ALIAS:
      return filterToCQN(expression.getExpression())
    case ExpressionKind.BINARY:
      return _binary(expression)
    case ExpressionKind.LITERAL:
      return _convert(expression)
    case ExpressionKind.MEMBER:
      return _member(expression)
    case ExpressionKind.METHOD:
      return _method(expression, operator)
    case ExpressionKind.UNARY:
      return _unary(expression)
    default:
      throw new FeatureNotSupported(`Expression ${expression.getKind()} is not supported`)
  }
}

module.exports = filterToCQN
