const {AuditLogNotWritten} = require('../../errors')
const getColumns = require('../../services/utils/columns')
const eventMap = new Map([
  ['CREATE', '@AuditLog.Operation.Insert'],
  ['READ', '@AuditLog.Operation.Read'],
  ['UPDATE', '@AuditLog.Operation.Update'],
  ['DELETE', '@AuditLog.Operation.Delete']
])
const _isRelevant = (event, entity) => {
  return entity[eventMap.get(event)]
}

const _relevantColumns = (reflected, entity) => {
  const columns = getColumns(reflected, entity)
  const relevantColumns = {
    keys: {},
    personal: {},
    fieldSemantics: {
      keys: {}
    }
  }

  for (const column of columns) {
    if (column.key) {
      relevantColumns.keys[column.name] = column
    }

    const properties = Object.keys(column)
    for (const property of properties) {
      if (property.startsWith('@PersonalData')) {
        relevantColumns.personal[column.name] = column

        switch (column['@PersonalData.FieldSemantics']) {
          case 'DataSubjectRole' :
            relevantColumns.fieldSemantics.role = column
            break
          case 'DataSubjectType' :
            relevantColumns.fieldSemantics.type = column
            break
          case 'DataSubjectId' :
            relevantColumns.fieldSemantics.keys[column.name] = column
            break
        }
      }
    }
  }

  return relevantColumns
}

module.exports = (reflected, auditLogger) => {
  return {
    /**
     * Starts the audit logging in case of a data change event or writes the log immediately for data read access.
     *
     * @param context - the context object
     * @returns {*|Promise} - promise if relevant for audit logging, otherwise undefined
     */
    personalDataBeforeCommitHandler: (context) => {
      if (_isRelevant(context.event, context.target)) {
        const relevantColumns = _relevantColumns(reflected, context.target)
        const user = context._.req.user.id
        const tenant = context._.req.authInfo.identityZone

        if (context.event === 'READ') {
          return auditLogger.logReadAccess({user, tenant, context, relevantColumns})
        }

        return auditLogger.logDataChange({user, tenant, context, relevantColumns, phase: 'before commit'})
      }
    },

    /**
     * Finishes the audit logging in case of a data change event and commit.
     *
     * @param result - the result of the event
     * @param context - the context object
     * @returns {Promise}
     */
    personalDataAfterCommitHandler: (result, context) => {
      if (_isRelevant(context.event, context.target) && context.event !== 'READ') {
        return new Promise((resolve, reject) => {
          context._.auditLogContinuation[context.success ? 'logSuccess' : 'logFailure']((err) => {
            if (err) {
              return reject(new AuditLogNotWritten(err, 'after commit'))
            }

            resolve()
          })
        })
      }
    },

    /**
     * In case of failed commit: finishes the audit logging in case of a data change event and rollback.
     * In case of failed on handler: starts audit logging
     *
     * @param context - the context object
     * @returns {Promise}
     */
    personalDataBeforeRollbackHandler: (context) => {
      if (_isRelevant(context.event, context.target) && context.event !== 'READ') {
        if (context._.auditLogContinuation) {
          return new Promise((resolve, reject) => {
            context._.auditLogContinuation.logFailure((err) => {
              if (err) {
                return reject(new AuditLogNotWritten(err, 'before rollback'))
              }
              resolve()
            })
          })
        }

        const relevantColumns = _relevantColumns(reflected, context.target)
        const user = context._.req.user.id
        const tenant = context._.req.authInfo.identityZone

        return auditLogger.logDataChange({user, tenant, context, relevantColumns, phase: 'before rollback'})
      }
    },

    /**
     * Finishes the audit logging in case of a data change event and rollback.
     *
     * @param result - the result of the event
     * @param context - the context object
     * @returns {Promise}
     */
    personalDataAfterRollbackHandler: (result, context) => {
      if (_isRelevant(context.event, context.target) && context.event !== 'READ') {
        return new Promise((resolve, reject) => {
          context._.auditLogContinuation.logFailure((err) => {
            if (err) {
              return reject(new AuditLogNotWritten(err, 'after rollback'))
            }

            resolve()
          })
        })
      }
    }
  }
}
