const {statements} = require('@sap/cds-ql')
const getColumns = require('../../../services/utils/columns')

const {
  Components: {
    DATA_DELETE_HANDLER,
    DATA_READ_HANDLER,
    DATA_CREATE_HANDLER,
    DATA_UPDATE_HANDLER
  }
} = require('@sap/odata-v4')
const {isCustomOperation} = require('./request')
const odataToCQN = require('../odata-to-cqn/odataToCQN')

/**
 * The key predicates will contain the keys and values for this request.
 * Combine all key value pairs into one object.
 * @param keyPredicates
 * @returns {Object}
 * @private
 */
const _getKeyValues = keyPredicates => {
  const keyValues = {}

  for (const keyPredicate of keyPredicates) {
    const edmRef = keyPredicate.getEdmRef()
    const typeName = edmRef.getProperty().getType().getName()

    // Convert any integer type into numeric values.
    keyValues[edmRef.getName()] = typeName.startsWith('Int')
      ? Number(keyPredicate.getText())
      : keyPredicate.getText()
  }

  return keyValues
}

/**
 * Get data from odata-v4.
 * READ and DELETE work are retrieved from URL; CREATE and UPDATE from body.
 * For CREATE and UPDATE annotated columns can be mixed in.
 *
 * @param {string} component - odata-v4 component which processes this request.
 * @param req
 * @param annotatedColumns - in case of insert and update we might have annotated columns for user/now
 * @returns {Object}
 * @private
 */
const _getData = (component, req, annotatedColumns) => {
  const keyValues = _getKeyValues(
    req.getUriInfo().getPathSegments()[0].getKeyPredicates()
  )

  if (component === DATA_DELETE_HANDLER || component === DATA_READ_HANDLER) {
    return keyValues
  }

  // Use identifier from URL instead of body
  const data = req.getBody() || {}

  for (const key of Object.keys(keyValues)) {
    data[key] = keyValues[key]
  }
  for (const column of annotatedColumns) {
    data[column.name] = column.value
  }
  return data
}

/**
 * This methods finds all annotated columns of the entity.
 * If it is annotated with user, the logged in user is set as value.
 * For all other cases we assume it is annotated as now and the current timestamp is set as value.
 *
 * @param modification - insert or update
 * @param reflected
 * @param target
 * @param user
 * @returns {Array}
 * @private
 */
const _setValuesForAnnotatedColumns = (modification, reflected, target, user = {id: 'anonymous'}) => {
  const cdsAnnotation = `@cds.on.${modification}`
  const odataAnnotation = `@odata.on.${modification}`
  const columns = getColumns(reflected, target).filter(
    column => column[cdsAnnotation] || column[odataAnnotation]
  )

  for (const column of columns) {
    if (column[cdsAnnotation]) {
      column.value = column[cdsAnnotation]['='] === '$user'
        ? user.id
        : new Date().toISOString()
      continue
    }

    if (column[odataAnnotation]) {
      column.value = column[odataAnnotation]['#'] === 'user'
        ? user.id
        : new Date().toISOString()
    }
  }

  return columns
}

const _getAnnotatedColumns = (component, reflected, {target, user}) => {
  switch (component) {
    case DATA_CREATE_HANDLER:
      return _setValuesForAnnotatedColumns('insert', reflected, target, user)
    case DATA_UPDATE_HANDLER:
      return _setValuesForAnnotatedColumns('update', reflected, target, user)
    default:
      return []
  }
}

/**
 * In case of batch request use the applicationData object as base,
 * else create a new object.
 * @param {Object} req - odata-v4 request object.
 * @return {Object}
 * @private
 */
const _getUnderscore = (req, res) => {
  let _ = req.getBatchApplicationData()

  // If batched, and first event of the batch, add indicator, to reuse the same db client.
  if (_ && _.doNotFinishTransaction === undefined) {
    _.doNotFinishTransaction = true
  }

  // Not batched, create object, that can be shared later on and will hold channel specifc details in any case.
  if (!_) {
    _ = {}
  }

  _.odataReq = req
  _.odataRes = res

  // Give the app developer access to the original (express) request object
  if (!_.req) {
    _.req = req.getIncomingRequest()
  }

  return _
}

/**
 * Try to find the name of the source entity at the services CSN.
 * @param {Object} service
 * @param {string} name
 * @returns {string}
 * @private
 */
const _findSourceEntityNameAtService = (service, name) => {
  const serviceEntity = service.reflected.find(element => {
    return element.source === name
  })

  return serviceEntity ? serviceEntity.name : name
}

/**
 * Gets the name of the service entity targeted by the given navigation path.
 * Undefined in case of a function or action import.
 * @param {Service} service
 * @param {Array} pathSegments - The path segments of a uri.
 * @returns {string} - The name of the navigation target entity.
 * @private
 */
const _getTargetEntityName = (service, pathSegments) => {
  if (isCustomOperation(pathSegments, false)) {
    return undefined
  }

  /*
   * The cds.deploy does not create views in case of SQLite.
   * We need to go to the sources in case of projections.
   * TODO: Use the entity directly, once views are deployed.
   */
  let navSegmentName
  let entityName = `${service.service}.${pathSegments[0]
    .getEntitySet()
    .getName()}`

  for (const navSegment of pathSegments.filter(
    segment => segment.getNavigationProperty() !== null
  )) {
    navSegmentName = navSegment.getNavigationProperty().getName()
    entityName = (navSegmentName === 'DraftAdministrativeData')
      ? 'DRAFT.DraftAdministrativeData'
      : service.reflected.definitions[entityName].elements[navSegmentName].target
  }

  return _findSourceEntityNameAtService(service, entityName)
}

const getContextObject = (component, service, req, res) => {
  const pathSegments = req.getUriInfo().getPathSegments()

  const context = {
    get data () {
      const annotatedColumns = _getAnnotatedColumns(
        component,
        service.reflected,
        this
      )
      const data = _getData(component, req, annotatedColumns)
      Object.defineProperty(context, 'data', {value: data})
      return data
    },
    get query () {
      let query

      if (!isCustomOperation(pathSegments)) {
        query = odataToCQN(component, service, context, req)
      }

      Object.defineProperty(context, 'query', {value: query})

      return query
    },
    get target () {
      const pathSegments = req.getUriInfo().getPathSegments()
      const definitions = service.reflected.definitions
      const target = definitions[_getTargetEntityName(service, pathSegments)]

      Object.defineProperty(context, 'target', {value: target})

      return target
    },
    get statements () {
      const {SELECT, INSERT, UPDATE, DELETE} = statements
      const wrappedStatements = {
        SELECT: {
          from: (entity, columns) => {
            return SELECT.from(entity, columns, service.reflected)
          },
          one: (entity, columns) => {
            return SELECT.one(entity, columns, service.reflected)
          }
        },
        INSERT: INSERT,
        UPDATE: UPDATE,
        DELETE: DELETE
      }

      Object.defineProperty(context, 'statements', {value: wrappedStatements})

      return wrappedStatements
    },
    _: _getUnderscore(req, res)
  }

  return context
}

module.exports = getContextObject
