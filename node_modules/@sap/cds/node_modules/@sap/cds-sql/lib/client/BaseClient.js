const cds = require('../cds')

/**
 * BaseClient is to be extended by any SQL client. It allows to convert db results according to the CSN.
 */
class BaseClient {
  /**
   * Creates a basic SQL Client
   * @param {Array|Map} toService - Definition of how to convert a value according to cds.DataType
   */
  constructor (toService = []) {
    this._toService = (toService instanceof Map) ? toService : new Map(toService)
    this._initializeDefaultDataTypeMap()
  }

  /**
   * Set the entities in reflected CSN format, relevant for the service the queries are run for.
   * @param csn
   */
  setCSN (csn) {
    this._csn = csn
  }

  /**
   * Default sql type conversion. Database specific data types need to be overwritten in db client impl.
   * @private
   */
  _initializeDefaultDataTypeMap () {
    this._typeConversionMap = require('../util/dataTypes').typeConversionMap
  }

  /**
   * Returns validity of the client.
   *
   * @returns {boolean} true if client is still valid, false if not
   */
  isValid () {
    return !this._toBeDestroyed && this.isConnected()
  }

  /**
   * Runs simple SQL statements.
   * In contrast to .execute, it also takes care of executing the statement in a transactional block.
   *
   * @param {String|Object} query - SQL query as string or CQN object.
   * @param {Array} [values] - values for prepared stmt in case of SQL query string.
   * @returns {Promise} - resolves with result or rejects with error.
   */
  run (query, values) {
    // Client broke in a not reparable way before
    if (this._toBeDestroyed) {
      const {errors: {InconsistentClientError}} = require('../')
      return Promise.reject(new InconsistentClientError())
    }

    // In case of run block the transaction mode is provided by the block pragmas.
    if (typeof query === 'function' && this._runBlock) {
      return this._addThenableToRun(this._runBlock(query))
    }

    // Execute in case of statements
    return this._addThenableToRun(this.execute(query, values))
  }

  _addThenableToRun (promise) {
    const then = (fn) => {
      return promise.then(fn)
    }

    then.run = (...args) => {
      return promise
        .then(() => {
          return this.run(...args)
        })
    }

    return {
      then: then,
      catch: (fn) => {
        return promise.catch(fn)
      }
    }
  }

  /**
   * Executes the statement and processes the result set one by one.
   * Should be used if huge result sets are expected to process it in a streaming-like fashion instead of
   * materializing the full set in memory before.
   *
   * @param {String|Object} query - SQL query as string or CQN object or entity name as specified in csn
   * (entity name is treated as: SELECT * FROM <entity name>).
   * @param {Array} [values] - values for prepared stmt in case of SQL query string.
   * @param {Function} callback - synchronous function to process each row of the result set.
   * @returns {Promise} - resolves to undefined if successful, rejects with error if not
   */
  foreach (query, values, callback) {
    const cb = callback || values

    return this.run(this._queryForForeach(query), this._valuesForForeach(values))
      .then((res) => {
        if (Array.isArray(res)) {
          res.forEach((row) => {
            cb(row)
          })
        }
      })
  }

  /**
   * Drops all tables/views and creates them again
   * @param {Object|Promise} csn - the unreflected CSN or promise that will resolve into csn.
   * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
   */
  deploy (csn) {
    if (csn.then) {
      return csn.then((csn) => {
        return this._deploy(csn)
      })
    }

    return this._deploy(csn)
  }

  _deploy (csn, dialect = 'sqlite') {
    let names = cds.config.data && cds.config.data.sql_mapping ? cds.config.data.sql_mapping : 'plain'
    names = (names === 'plain') ? 'flat' : 'deep'
    const creates = cds.compile.to.sql(csn, {toSql: {dialect: dialect, names: names}})
    const sqls = this._prepareSqls(creates)

    let execChain = Promise.resolve()

    for (const drop of sqls.drops) {
      execChain = this._addDropsToChain(execChain, drop)
    }

    for (const create of sqls.creates) {
      execChain = this._addCreateToChain(execChain, create)
    }

    return execChain
  }

  _prepareSqls (creates) {
    const res = {}
    res.creates = []
    res.drops = []
    for (const create of creates) {
      const [, type, name] = create.match(/^\s*\w+\s+(table|view)\s+"?([^\s(]+?)"?[\s(]/im) || []

      if (type.toLowerCase() === 'view') {
        res.drops.unshift({DROP: {view: name}})
        res.creates.push(create)
      } else if (type.toLowerCase() === 'table') {
        res.drops.push({DROP: {entity: name}})
        res.creates.unshift(create)
      }
    }

    return res
  }

  /**
   * Hana does not support drop if exists so we need to handle this differently in hana.
   * The hana client needs to overwrite this to handle error in case the table does not exist.
   * @private
   */
  _addDropsToChain (chain, drop) {
    return chain.then(() => {
      return this.run(drop)
    })
  }

  _addCreateToChain (chain, drop) {
    return chain.then(() => {
      return this.run(drop)
    })
  }

  _valuesForForeach (values) {
    if (typeof values === 'function') {
      return
    }

    return values
  }

  _queryForForeach (query) {
    if (this._csn && this._csn.definitions[query]) {
      const entityName = this._csn.definitions[query].source || this._csn.definitions[query].name

      return {
        SELECT: {
          from: {ref: [entityName]}
        }
      }
    }

    return query
  }
}

module.exports = BaseClient
