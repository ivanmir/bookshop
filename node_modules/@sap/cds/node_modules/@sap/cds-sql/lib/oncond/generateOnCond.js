const _onCondfromForeignKey = (csnElement, associationName) => {
  const on = []

  for (const key of Object.keys(csnElement.foreignKeys)) {
    on.push(csnElement.foreignKeys[key].path)
    on.push('=')
    on.push(`${associationName}_${csnElement.foreignKeys[key].path}`)
  }

  return on
}

const _indexOfTargetForBacklink = (arr) => {
  return (arr[0] === '$self') ? 2 : 0
}

const _onCond = (csnElement, associationName, csn) => {
  if (csnElement.foreignKeys) {
    return _onCondfromForeignKey(csnElement, associationName)
  }

  const elements = [
    csnElement.onCond.args[0][csnElement.onCond.op],
    csnElement.onCond.op,
    csnElement.onCond.args[1][csnElement.onCond.op]
  ]

  if (elements.includes('$self')) {
    return _resolveSelfOnCond(csnElement, elements, csn)
  }

  if (elements[2].includes(`${associationName}.`)) {
    elements.revertIdentifier = true
  }

  return elements
}

const _getElementName = (entity, string) => {
  const parts = string.split('.').reverse()
  const elementName = []

  for (const part of parts) {
    elementName.unshift(part)

    const name = elementName.join('.')

    if (entity.elements[name]) {
      return name
    }
  }
}

const _resolveComposition = (csnElement, elements, csn) => {
  const targetEntity = csn.definitions[csnElement.target]
  const targetElementName = _getElementName(targetEntity, elements[_indexOfTargetForBacklink(elements)])

  return _onCondfromForeignKey(targetEntity.elements[targetElementName], targetElementName).reverse()
}

const _resolveAssociation = (csnElement, elements, csn) => {
  const targetEntity = csnElement.target
  const targetAssociation = elements[_indexOfTargetForBacklink(elements)].replace(`${csnElement.name}.`, '')

  const onCondForBacklink = _onCond(csn.definitions[targetEntity].elements[targetAssociation], targetAssociation, csn)

  if (elements[0].includes(`.${targetAssociation}`)) {
    elements[0] = onCondForBacklink[2]
    elements[2] = onCondForBacklink[0]
  } else {
    elements = onCondForBacklink
    elements.revertIdentifier = true
  }

  return elements
}

const _resolveSelfOnCond = (csnElement, elements, csn) => {
  if (csnElement.type === 'cds.Composition') {
    return _resolveComposition(csnElement, elements, csn)
  }

  return _resolveAssociation(csnElement, elements, csn)
}

/**
 * Separate table and column names.
 * @param columnName
 * @param associationName
 * @param alias
 * @returns {Object}
 * @private
 */
const _addAliasToCondition = (columnName, associationName, alias) => {
  const res = []
  if (alias) {
    res.push(alias)
  }
  if (columnName.startsWith(`${associationName}.`)) {
    res.push(columnName.replace(new RegExp(`^${associationName}\\.`), ''))
  } else {
    res.push(columnName)
  }
  return {ref: res}
}

/**
 * Get the ON conditions in CQN format based on the CSN.
 * @param {Object} csnElement
 * @param {String} associationName
 * @param {string} selectAlias
 * @param {string} joinAlias
 * @returns {Array}
 * @private
 */
const getOnCond = (csnElement, associationName, csn, selectAlias, joinAlias) => {
  const cond = _onCond(csnElement, associationName, csn)
  const [column, operand, joinColumn] = cond

  return [
    _addAliasToCondition(column, associationName, cond.revertIdentifier ? joinAlias : selectAlias),
    operand,
    _addAliasToCondition(joinColumn, associationName, cond.revertIdentifier ? selectAlias : joinAlias)
  ]
}

module.exports = {
  getOnCond
}
