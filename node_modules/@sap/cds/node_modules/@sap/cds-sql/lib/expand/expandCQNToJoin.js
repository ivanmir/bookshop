const crypto = require('crypto')

const cds = require('../cds')
const {getOnCond} = require('../oncond/generateOnCond')

// Symbols are used to add extra information in response structure
const GET_KEY_VALUE = Symbol.for('getKeyValue')
const TO_MANY = Symbol.for('toMany')
const TO_MANY_KEYS = Symbol.for('toManyKeys')
const SKIP_MAPPING = Symbol.for('skipMapping')
const IDENTIFIER = Symbol.for('identifier')
const IS_DRAFT = Symbol.for('isDraft')
const IS_UNION_DRAFT = Symbol.for('isUnionDraft')
const DRAFT_COLUMNS = ['IsActiveEntity', 'HasActiveEntity', 'HasDraftEntity', 'DraftAdministrativeData_DraftUUID']

// TODO: Remove workaround, once provided by CSN
const draftAdministrativeData = require('../util/administrativeData')

class JoinCQNFromExpanded {
  constructor (cqn, csn, useWindow) {
    this._useWindow = useWindow
    this._SELECT = Object.assign({}, cqn.SELECT)
    this._csn = cqn[Symbol.for('cds.ql.model')] || csn
    this.queries = []
    this.mappings = {}
  }

  /**
   * Build one to N queries and construct the post processing configs.
   * Each expand with a to many target will result in an extra query and config.
   * @returns {Array}
   */
  buildJoinQueries () {
    // Update elements at WHERE, so there are no issues with ambiguity
    this._adaptWhereOrderBy(this._SELECT, this._getTableAlias(this._SELECT, [], this._getUnionTable(this._SELECT)))

    // Get first level of expanding regarding to many and all to one if not part of a nested to many expand.
    this._createJoinCQNFromExpanded(this._SELECT, [])

    return this
  }

  _getUnionTable (SELECT) {
    if (!SELECT.from.SET) {
      return
    }

    // Ensure the draft table is picked, no matter, which position
    for (const arg of SELECT.from.SET.args) {
      const {table} = this._getRef(arg.SELECT)
      // Do not handle non draft cases, as it will be unclear, which entity to pick from
      if (table.endsWith('_drafts')) {
        return table
      }
    }
  }

  _isDraftExpand (table) {
    if (this._csn.definitions[table]) {
      return false
    }

    if (this._csn.definitions[table.replace(/_drafts$/i, '')]) {
      // Workaround, as associations are not redirected at service yet
      this._draftService = table.replace(/\.\w+$/i, '')

      return true
    }
  }

  /**
   * Build first level of expanding regarding to many and all to one if not part of a nested to many expand.
   * @param {Object} SELECT - SELECT part of a CQN.
   * @param {Array} toManyTree - Holds information how deeply nested the expand is and where the result is added in the tree.
   * @private
   */
  _createJoinCQNFromExpanded (SELECT, toManyTree) {
    const unionTable = this._getUnionTable(SELECT)
    const tableAlias = this._getTableAlias(SELECT, toManyTree, unionTable)
    const readToOneCQN = this._getReadToOneCQN(SELECT, tableAlias)
    const table = unionTable || this._getRef(SELECT).table

    if (unionTable) {
      readToOneCQN[IS_UNION_DRAFT] = true
    }
    if (this._isDraftExpand(table)) {
      readToOneCQN[IS_DRAFT] = true
    }

    this._expandedToFlat({
      entity: this._getEntityForTable(table, readToOneCQN[IS_DRAFT]),
      givenColumns: SELECT.columns,
      readToOneCQN: readToOneCQN,
      tableAlias: tableAlias,
      toManyTree: toManyTree
    })

    // Add at start, so that the deepest level is post processed first
    this.queries.push({
      SELECT: readToOneCQN,
      _toManyTree: toManyTree
    })
  }

  /**
   * Self referencing associations, two expanded entities based on same table, ...
   * Requires an abstract name to prevent ambiguity issues.
   * Use hash to prevent names longer than support by DB.
   * @returns {string}
   * @private
   */
  _getTableAlias (SELECT, toManyTree, unionTable) {
    return this._createHash((toManyTree.length === 0) ? (unionTable || this._getRef(SELECT).table) : toManyTree.join(':'))
  }

  _getRef (SELECT) {
    const table = (SELECT.from.hasOwnProperty('join')) ? this._getRefFromJoin(SELECT.from.args) : SELECT.from

    return {
      table: (table.SELECT) ? this._getRef(table.SELECT).table : table.ref[0],
      as: table.as
    }
  }

  _getRefFromJoin (args) {
    if (args[0].ref) {
      return args[0]
    }

    // Order is reversed
    return args[args.length - 1]
  }

  /**
   * Create (md5) hash from value. Used for abstraction and not for security.
   * @returns {string}
   * @private
   */
  _createHash (value) {
    // Prefixed as an alias cannot start with a number at SQL.
    return `t${crypto.createHash('md5').update(value).digest('hex')}`
  }

  _getEntityForTable (table, isDraft) {
    if (table === 'DraftAdministrativeData') {
      return cds.reflect(draftAdministrativeData)
    }

    if (isDraft) {
      return cds.reflect(this._csn.definitions[table.replace(/_drafts/i, '')])
    }

    return cds.reflect(this._csn.definitions[table])
  }

  /**
   * Get base CQN, with the same filters as origin.
   * @param {Object} SELECT
   * @param {string} tableAlias
   * @returns {Object}
   * @private
   */
  _getReadToOneCQN (SELECT, tableAlias) {
    const cqn = Object.assign({}, SELECT, {columns: []})

    if (cqn.from.hasOwnProperty('join')) {
      this._adaptJoin(tableAlias, cqn.from)
    } else {
      if (cqn.from.SET) {
        this._adaptUnionArgs(cqn.from.SET.args)
      }

      cqn.from.as = tableAlias
    }

    return cqn
  }

  _adaptJoin (tableAlias, from) {
    const target = (from.args[0].ref) ? from.args[0] : from.args[from.args.length - 1]
    const originalIdentifier = target.as || target.ref[0]
    target.as = tableAlias

    for (const column of from.on) {
      if (column.ref && column.ref[0] === originalIdentifier) {
        column.ref[0] = tableAlias
      }
    }
  }

  _adaptUnionArgs (args) {
    for (const arg of args) {
      if (arg.SELECT.columns) {
        // remove the expands from the sub selects, as they are joined against the unioned result
        arg.SELECT.columns = arg.SELECT.columns.filter((element) => {
          return (!element.expand)
        })
      }
    }
  }

  /**
   * Ensure that columns are accesed in combination with table alias.
   * Prevents ambiquity issues.
   * @param {Object} cqn
   * @param {string} tableAlias
   * @returns {Object}
   * @private
   */
  _adaptWhereOrderBy (cqn, tableAlias) {
    if (cqn.where) {
      cqn.where = cqn.where.map((element) => {
        return this._checkOrderByWhereElementRecursive(cqn, element, tableAlias)
      })
    }

    if (cqn.orderBy) {
      cqn.orderBy = cqn.orderBy.map((element) => {
        return this._checkOrderByWhereElementRecursive(cqn, element, tableAlias)
      })
    }

    return cqn
  }

  _checkOrderByWhereElementRecursive (cqn, element, tableAlias) {
    if (element.ref) {
      element = Object.assign({}, element)
      element.ref = element.ref.slice(0)

      if (element.ref.length === 1) {
        element.ref.unshift(tableAlias)
      } else if (this._elementAliasNeedsReplacement(element, this._getUnionTable(cqn) || this._getRef(cqn))) {
        element.ref[0] = tableAlias
      }

      this._functionNeedsReplacement(cqn, tableAlias, element)
    } else if (element.xpr) {
      element = Object.assign({}, element)
      element.xpr = element.xpr.map((nestedElement) => {
        return this._checkOrderByWhereElementRecursive(cqn, nestedElement, tableAlias)
      })
    } else if (element.SELECT) {
      this._adaptWhereSELECT(this._getUnionTable(cqn) || this._getRef(cqn), element.SELECT.where, tableAlias)
    }

    return element
  }

  /**
   * Change alias of most outer table query to md5 sum.
   * @param {Object} aliasedTable
   * @param {Array} args
   * @param {string} tableAlias
   * @private
   */
  _adaptWhereSELECT (aliasedTable, where, tableAlias) {
    if (!where) {
      return
    }

    for (const element of where) {
      if (this._elementAliasNeedsReplacement(element, aliasedTable)) {
        element.ref[0] = tableAlias
      }
    }
  }

  _elementAliasNeedsReplacement (element, {table, as}) {
    if (!element.ref || element.ref.length !== 2) {
      return false
    }

    switch (element.ref[0]) {
      case table:
      case as:
        return true
      default:
        return false
    }
  }

  _functionNeedsReplacement (cqn, tableAlias, element) {
    if (typeof element.ref[0] !== 'string' ||
      typeof element.ref[1] !== 'object' ||
      !Array.isArray(element.ref[1].args)) {
      return
    }

    element.ref[1].args = element.ref[1].args.map((arg) => {
      if (Array.isArray(arg.list)) {
        arg.list = arg.list.map((item) => {
          return this._checkOrderByWhereElementRecursive(cqn, item, tableAlias)
        })

        return arg
      }

      return this._checkOrderByWhereElementRecursive(cqn, arg, tableAlias)
    })
  }

  /**
   * Build CQN(s) with JOINs for expanding. In case of expanding with to many an additional CQN will be pushed to toManyCQN.
   * @param {Object} arg - Avoiding many arguments and issues that come with it by using an object.
   * @param {Object} arg.entity - Entity that is taken from CSN.
   * @param {Array} arg.givenColumns - List of read columns taken from CQN.
   * @param {Object} arg.readToOneCQN - Build CQN the JOIN(s) should be added to or it will be used to filter an expanded to many entity.
   * @param {string} arg.tableAlias - Table alias
   * @param {Array} arg.toManyCQN - List of build CQNs which are used to read expands with to many target.
   * @param {Array} arg.toManyTree - Information, where the expand array is located in the result array.
   * @returns {Object}
   * @private
   */
  _expandedToFlat ({entity, givenColumns, readToOneCQN, tableAlias, toManyTree}) {
    const toManyColumns = []
    const mappings = this._getMappingObject(toManyTree)

    for (const column of givenColumns) {
      // To many can only be build, once all other columns have been processed.
      if (this._isExpandToMany(column, entity, readToOneCQN[IS_DRAFT])) {
        mappings[column.ref[0]] = {[TO_MANY]: true}
        toManyColumns.push(column)

        // Expands with to one target can be processed directly
      } else if (column.expand) {
        this._addJoinAndElements({
          column,
          entity,
          readToOneCQN,
          toManyTree,
          parentAlias: tableAlias
        })

        // No expand, directly add the column and its mapping.
      } else {
        readToOneCQN.columns.push(this._addAliasToColumn(column, entity, tableAlias, mappings))
      }
    }

    // only as second step handle expand to many, or else keys might still be unknown
    this._toMany({entity, readToOneCQN, tableAlias, toManyColumns, toManyTree, mappings})
  }

  /**
   * Follow the tree to get to the relevant config object.
   * @param {Array} toManyTree
   * @returns {Object}
   * @private
   */
  _getMappingObject (toManyTree) {
    let mappings = this.mappings

    for (const element of toManyTree) {
      if (!mappings[element]) {
        mappings[element] = {}
      }

      mappings = mappings[element]
    }

    return mappings
  }

  _isExpandToMany (column, entity, isDraft) {
    // TODO: remove once the targets are service entity to service entity and DraftAdministrativeData is included
    if (column.expand && column.ref[0] === 'DraftAdministrativeData') {
      return false
    }

    return column.expand && cds.reflect(entity.def.elements[column.ref[0]]).is2many
  }

  /**
   * Adds JOIN instructions to CQN for expands with 1:1 target and returns config how to map it back.
   * @param column
   * @param entity
   * @param readToOneCQN
   * @param toManyCQN
   * @param toManyTree
   * @returns {Object}
   * @private
   */
  _addJoinAndElements ({column, entity, readToOneCQN, toManyTree, parentAlias}) {
    const extendedToManyTree = toManyTree.concat(column.ref)
    const tableAlias = this._createHash(extendedToManyTree.join(':'))
    const target = (entity.def.elements[column.ref[0]]) ? entity.def.elements[column.ref[0]].target : column.ref[0]

    readToOneCQN.from = {
      args: [
        (readToOneCQN.from.SET) ? this._unionToSubQuery(readToOneCQN) : readToOneCQN.from,
        {ref: [this._refFromRefByExpand(column.ref[0], entity.def.elements)], as: tableAlias}
      ],
      join: (column.ref[0] === 'DraftAdministrativeData' || !entity.def.elements[column.ref[0]].notNull) ? 'left' : 'inner',
      on: this._getOnCond(entity.def.elements, column.ref[0], tableAlias, parentAlias, readToOneCQN[IS_DRAFT])
    }

    this._expandedToFlat({
      entity: this._getEntityForTable(target, readToOneCQN[IS_DRAFT]),
      givenColumns: column.expand,
      readToOneCQN: readToOneCQN,
      tableAlias: tableAlias,
      toManyTree: extendedToManyTree
    })
  }

  _unionToSubQuery (readToOneCQN) {
    return {
      SELECT: {
        columns: Array.from(readToOneCQN.columns),
        from: readToOneCQN.from,
        as: readToOneCQN.from.as
      }
    }
  }

  _refFromRefByExpand (column, elements) {
    return (column === 'DraftAdministrativeData') ? 'DRAFT.DraftAdministrativeData' : elements[column].target
  }

  _getOnCond (elements, column, tableAlias, parentAlias, isDraft) {
    if (column === 'DraftAdministrativeData') {
      if (isDraft) {
        return [{ref: [tableAlias, 'DraftUUID']}, '=', {ref: [parentAlias, 'DraftAdministrativeData_DraftUUID']}]
      }

      return [{ref: [tableAlias, 'DraftUUID']}, '=', {val: null}]
    }

    return getOnCond(elements[column], column, this._csn, tableAlias, parentAlias)
  }

  /**
   * Add an unique alias to each column, to avoid ambiguity.
   * Add this information to the post process config.
   * @param column
   * @param entity
   * @param tableAlias
   * @returns {Object}
   * @private
   */
  _addAliasToColumn (column, entity, tableAlias, mappings) {
    // No identifier for this row entry or technical column
    if (this._isAliasNotNeeded(column)) {
      return column
    }

    return this._buildNewAliasColumn(column, entity, tableAlias, mappings)
  }

  /**
   * Technical or a value without a casted name, or some other not yet supported combinations should not be refactored.
   * @param {Object} column
   * @returns {boolean}
   * @private
   */
  _isAliasNotNeeded (column) {
    // functions, direct values, ...
    if (!column.ref && !column.as) {
      return true
    }

    // No column name specified means false
    return (column.ref && typeof column.ref[column.ref.length - 1] !== 'string')
  }

  _buildNewAliasColumn (column, entity, tableAlias, mappings) {
    // Casted name, vs column name
    const identifier = this._getIdentifier(column, tableAlias)
    const as = column.as || `${tableAlias}_${identifier}`
    const aliasedElement = Object.assign({}, column)
    aliasedElement.as = as

    // Add table alias or name to handle cases, where joined tables have same column names
    if (this._isElement(column.ref, entity.def)) {
      const alias = tableAlias || entity.def.name
      aliasedElement.ref = (alias) ? [alias, column.ref[0]] : [column.ref[0]]
    }

    if (!column[SKIP_MAPPING]) {
      mappings[column[IDENTIFIER] || identifier] = as
    }

    return aliasedElement
  }

  _getIdentifier (column, tableAlias) {
    if (column.as) {
      return (column.as.startsWith(`${tableAlias}_`)) ? column.ref[column.ref.length - 1] : column.as
    }

    return column.ref[column.ref.length - 1]
  }

  _isElement (ref, def) {
    if (!ref || ref.length !== 1) {
      return false
    }

    // Normal element
    if (def.elements[ref[0]]) {
      return true
    }

    // Auto gen column from managed association
    if (this._isAutoGenColumn(ref[0], def.elements)) {
      return true
    }

    // Draft column
    if (DRAFT_COLUMNS.includes(ref[0])) {
      return true
    }

    return this._isComplexType(ref[0].split('_'), def)
  }

  _isAutoGenColumn (columnName, elements) {
    for (const key of Object.keys(elements)) {
      const element = elements[key]
      if (columnName.startsWith(key) && element.type === 'cds.Association' && element.foreignKeys) {
        // works only for single keys
        if (columnName === `${key}_${Object.getOwnPropertyNames(element.foreignKeys)[0]}`) {
          return true
        }
      }
    }

    return false
  }

  _isComplexType (parts, def) {
    const removed = []

    // Remove from the end until there is no more left
    while (parts.length !== 0) {
      const element = def.elements[parts.join('_')]

      if (element) {
        // If nothing has been removed, we are at the end of the nesting
        return (removed.length === 0) ? true : this._isComplexType(removed, element)
      }

      removed.unshift(parts.pop())
    }

    return false
  }

  _getKeyNames (entity, includeForeign = false) {
    const keys = entity.keys

    if (!keys) {
      return
    }

    const keyNames = []

    for (const key of Object.keys(keys)) {
      if (!keys[key].foreignKeys) {
        keyNames.push(key)
      } else {
        for (const foreign of Object.keys(keys[key].foreignKeys)) {
          keyNames.push(`${key}_${foreign}`)
        }
      }
    }

    return keyNames
  }

  _toMany ({entity, readToOneCQN, tableAlias, toManyColumns, toManyTree, mappings}) {
    if (toManyColumns.length === 0) {
      return
    }

    this._addKeysIfNeeded({entity, readToOneCQN, tableAlias})

    for (const column of toManyColumns) {
      this._createJoinCQNFromExpanded(this._buildExpandedCQN({
        column,
        entity,
        readToOneCQN,
        toManyTree,
        mappings
      }), toManyTree.concat([column.ref[0]]))
    }
  }

  /**
   * In case of to many relations, a key is needed for post processing.
   * @private
   */
  _addKeysIfNeeded ({entity, readToOneCQN, tableAlias}) {
    for (const name of this._getMissingKeys({entity, readToOneCQN, tableAlias})) {
      readToOneCQN.columns.push({
        as: `${tableAlias}_${name}`,
        ref: [tableAlias, name]
      })
    }
  }

  /**
   * Compare the list of available keys with keys listed already listed at CQN and return missing.
   * @param entity
   * @param readToOneCQN
   * @param tableAlias
   * @returns {Array}
   * @private
   */
  _getMissingKeys ({entity, readToOneCQN, tableAlias}) {
    const keyNames = this._getKeyNames(entity)

    if (!keyNames) {
      return
    }

    return keyNames.filter((name) => {
      let missing = true

      for (const column of readToOneCQN.columns) {
        if (column.as === `${tableAlias}_${name}`) {
          missing = false
        }
      }

      return missing
    })
  }

  /**
   * Construct the base CQN for a to many expands.
   * @returns {Object}
   * @private
   */
  _buildExpandedCQN ({column, entity, readToOneCQN, toManyTree, mappings}) {
    const ref = this._getJoinRef(entity.def.elements, column.ref[0], readToOneCQN[IS_DRAFT])
    const tableAlias = this._createHash(toManyTree.concat(column.ref).join(':'))
    const on = getOnCond(entity.def.elements[column.ref[0]], column.ref[0], this._csn, tableAlias, 'filterExpand')
    const filterExpand = this._getFilterExpandCQN(readToOneCQN, on)
    const joinColumns = this._getJoinColumnsFromOnAddToMapping(mappings[column.ref[0]], readToOneCQN, on)
    const expandedEntity = cds.reflect(this._csn.definitions[entity.def.elements[column.ref[0]].target])

    const cqn = {
      from: {
        join: 'inner',
        args: [
          {ref: [ref], as: tableAlias},
          filterExpand
        ],
        on: on
      },
      columns: this._getColumnsForExpand({tableAlias, columnList: column, entity: expandedEntity, joinColumns})
    }

    if (readToOneCQN[IS_DRAFT] && ref.endsWith('_drafts')) {
      cqn[IS_DRAFT] = true
    }

    if (column.where) {
      cqn.where = this._copyWhere(column.where)
    }

    if (column.orderBy) {
      cqn.orderBy = this._copyOrderBy(column.orderBy, tableAlias)
    }

    if (column.limit && !this._useWindow) {
      this._addLimitToCqn(cqn, column, tableAlias, expandedEntity)
    }

    return this._adaptWhereOrderBy(this._addWindowIfNeeded(cqn, column, tableAlias), tableAlias)
  }

  _getJoinRef (elements, column, isDraft) {
    if (!isDraft || elements[column].type !== 'cds.Composition') {
      return elements[column].target
    }

    return `${this._draftService}.${elements[column].target.split('.').pop()}_drafts`
  }

  /**
   * Solve limit by group with a sub select at the join clause.
   * @private
   */
  _addLimitToCqn (cqn, column, tableAlias, expandedEntity) {
    const columns = this._getKeyColumnForTarget(tableAlias, expandedEntity)
    const inSelect = this._getLimitInSelect(cqn, columns, column.limit, column.orderBy)

    cqn.from.on.push('and')
    cqn.from.on.push({
      list: columns
    })
    cqn.from.on.push('IN', inSelect)
  }

  /**
   * Get the list of key columns in ref format.
   * Add the table alias to avoid ambiquity issues.
   * @return {Array}
   * @private
   */
  _getKeyColumnForTarget (tableAlias, expandedEntity) {
    return this._getKeyNames(expandedEntity).map((column) => {
      return {ref: [tableAlias, column]}
    })
  }

  _getLimitInSelect (cqn, columns, limit, orderBy) {
    const select = {
      SELECT: {
        columns: this._copyColumns(columns, 'limitFilter'),
        from: {ref: [cqn.from.args[0].ref[0]], as: 'limitFilter'},
        where: this._convertOnToWhere(cqn.from.on, cqn.from.args[0].as, 'limitFilter'),
        limit: limit
      }
    }

    if (orderBy) {
      select.SELECT.orderBy = this._copyOrderBy(orderBy, 'limitFilter')
    }

    return select
  }

  _copyOrderBy (orderBy, alias) {
    return orderBy.map((element) => {
      return {ref: (element.ref.length === 1) ? [alias, element.ref[0]] : [alias, element.ref[1]], sort: element.sort}
    })
  }

  _addWindowIfNeeded (cqn, column, tableAlias) {
    if (!this._useWindow || (!column.orderBy && !column.limit)) return cqn

    cqn.columns.push(
      this._getWindowXpr(
        cqn.from.on.filter((element) => element.ref && element.ref[0] !== 'filterExpand'),
        this._copyOrderBy(column.orderBy || [], tableAlias)
      )
    )

    const windowCQN = {
      columns: cqn.columns.filter((entry) => !entry.xpr).map((entry) => {
        return Object.assign({}, entry, {[IDENTIFIER]: entry.ref[1], ref: [entry.ref[0], entry.as]})
      }),
      from: {
        SELECT: cqn
      }
    }

    if (column.limit) {
      windowCQN.where = [
        {ref: ['rowNumber']}, '>', {val: column.limit.offset.val},
        'and', {ref: ['rowNumber']}, '<', {val: (column.limit.offset.val + column.limit.rows.val + 1)}
      ]
    }

    return windowCQN
  }

  _getWindowXpr (columns, orderBy) {
    const xpr = [{func: 'ROW_NUMBER', args: []}, 'OVER', '(', 'PARTITION BY', ...columns]
    if (orderBy.length !== 0) {
      xpr.push('ORDER BY', ...orderBy)
    }
    xpr.push(')')

    return {xpr: xpr, as: 'rowNumber'}
  }

  _copyColumns (columns, alias) {
    return columns.map((element) => {
      const column = {
        ref: [alias, element.ref[element.ref.length - 1]]
      }

      if (element.as) {
        column.as = element.as
      }

      return column
    })
  }

  _convertOnToWhere (on, currentAlias, newAlias) {
    return on.map((element) => {
      if (typeof element === 'object') {
        return {
          ref: [(element.ref[0] === currentAlias) ? newAlias : element.ref[0], element.ref[1]]
        }
      }

      return element
    })
  }

  _copyWhere (list) {
    return list.map((entry) => {
      return (typeof entry === 'object') ? this._copyObject(entry) : entry
    })
  }

  _copyObject (obj) {
    const newObj = {}

    for (const key of Object.keys(obj)) {
      if (Array.isArray(obj[key])) {
        newObj[key] = Array.from(obj[key])
      } else {
        newObj[key] = obj[key]
      }
    }

    return newObj
  }

  /**
   * Reduce column list to column(s) needed to merge the result into one.
   * @returns {Object}
   * @private
   */
  _getFilterExpandCQN (readToOneCQN, on) {
    const columns = []

    for (const entry of on) {
      if (typeof entry === 'object' && entry.ref[0] === 'filterExpand') {
        columns.push({
          ref: [this._getAlias(readToOneCQN), entry.ref[1]],
          as: entry.ref[1]
        })
      }
    }

    return {
      SELECT: Object.assign({}, readToOneCQN, {columns: columns}),
      as: 'filterExpand'
    }
  }

  _getAlias (SELECT) {
    const {as, table} = this._getRef(SELECT)
    return as || table
  }

  /**
   * In case a column is used at a JOIN, it needs to be added to the list of selected columns.
   * @returns {Array}
   * @private
   */
  _getJoinColumnsFromOnAddToMapping (mapping, readToOneCQN, on) {
    const columns = []
    const columnNames = []
    mapping[TO_MANY_KEYS] = []

    for (const entry of on) {
      if (typeof entry === 'object' && entry.ref[0] !== 'filterExpand') {
        const as = entry.ref.join('_')

        mapping[TO_MANY_KEYS].push(as)

        columns.push({
          ref: entry.ref,
          as: as,
          [SKIP_MAPPING]: true
        })
      } else if (typeof entry === 'object') {
        columnNames.push(`${this._getAlias(readToOneCQN)}_${entry.ref[1]}`)
      }
    }

    // Function will be used a post processing to create unique keys for cache and lookup the same
    mapping[GET_KEY_VALUE] = (atExpanded, entry) => {
      const keyValue = []
      const keyList = (atExpanded) ? mapping[TO_MANY_KEYS] : columnNames

      for (const key of keyList) {
        keyValue.push(entry[key] || entry[key.toUpperCase()])
      }

      return keyValue.join(':')
    }

    return columns
  }

  /**
   * Get the explicitly named columns for expand and add ID columns, so the result can be added to the correct part at merged result.
   * @returns {Object}
   * @private
   */
  _getColumnsForExpand ({tableAlias, columnList, entity, joinColumns}) {
    const columns = []
    const keys = this._getKeyNames(entity)

    for (const column of columnList.expand) {
      if (column.expand || !column.ref) {
        columns.push(column)
      } else {
        this._addToColumnList(columns, keys, tableAlias, column)
      }
    }

    this._addMissingJoinColumns(columns, joinColumns, keys)
    this._addMissingKeyColumns(columns, tableAlias, keys)

    return columns
  }

  _addToColumnList (columns, keys, tableAlias, column) {
    const columnName = column.ref[column.ref.length - 1]

    this._removeExistingKeyFromList(keys, columnName)

    columns.push({
      ref: [tableAlias, columnName],
      as: column.as || `${tableAlias}_${columnName}`
    })

    return columnName
  }

  _removeExistingKeyFromList (keys, columnName) {
    const index = keys.indexOf(columnName)

    if (index === -1) {
      return false
    }

    keys.splice(index, 1)

    return true
  }

  _addMissingJoinColumns (columns, joinColumns, keys) {
    for (const joinColumn of joinColumns) {
      if (!this._columnIncluded(joinColumn, columns)) {
        this._removeExistingKeyFromList(keys, joinColumn[1])
        columns.push(joinColumn)
      }
    }
  }

  _columnIncluded (column, columns) {
    for (const entry of columns) {
      if (column.ref[1] === entry[1]) {
        return true
      }
    }

    return false
  }

  /**
   * Add key columns if they are not already existing in the list.
   * @private
   */
  _addMissingKeyColumns (columns, tableAlias, keys) {
    for (const key of keys) {
      columns.push({
        ref: [tableAlias, key],
        as: `${tableAlias}_${key}`
      })
    }
  }
}

/**
 * Creates CQN(s) by using JOIN for all expanded entries, as expanding is not supported by SQL.
 * @param {Object} cqn - CQN with expanded columns
 * @param {Object} csn - Services CSN
 * @param {Boolean} useWindow - If sub select or window function should be used for top/skip at expand
 * @returns {Object}
 * @private
 */
const createJoinCQNFromExpanded = (cqn, csn, useWindow) => {
  return new JoinCQNFromExpanded(cqn, csn, useWindow).buildJoinQueries()
}

/**
 * Check if the given CQN is of type select and contains expand.
 * @param {Object} cqn
 * @returns {boolean}
 * @private
 */
const hasExpand = (cqn) => {
  if (cqn && cqn.SELECT && Array.isArray(cqn.SELECT.columns)) {
    return cqn.SELECT.columns.some(column => column.expand)
  }

  return false
}

module.exports = {
  createJoinCQNFromExpanded,
  hasExpand
}
