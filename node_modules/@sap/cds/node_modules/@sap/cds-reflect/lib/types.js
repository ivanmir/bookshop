//
//  Type system root classes
//

class any {
	is (kind) { return kind === this.kind }
	own (key) {
		return this.hasOwnProperty(key) && this[key]
	}
	set (key, value) {
		Object.defineProperty (this, key, { value, writable:1, configurable:1 })
        return value
	}
	static mixin (methods) {
		for (let each of Reflect.ownKeys (methods)) {
			Object.defineProperty (this.prototype, each,
				Object.getOwnPropertyDescriptor (methods, each)
			)
		}
		return this
	}
}

Object.defineProperty (any.prototype, 'isLinked', {value:true})
any._cds = true

class context extends any {}
class service extends context {}

class type extends any {}
class scalar extends type {}
class string extends scalar {}
class number extends scalar {}
class boolean extends scalar {}
class date extends scalar {}
class struct extends type {}
class array extends type {}

class entity extends struct {
	get keys(){
		if (this === entity.prototype)  return undefined
		let ee=this.elements, keys, dict={}
		for (let e in ee)  if (ee[e].key)  (keys=dict)[e] = ee[e]
        return this.set ('keys',keys)
	}
}

class Association extends type {
	is (kind) { return kind === 'Association' || super.is(kind) }
	get keys(){
		const d = this, keys = this.own('keys')
		if (keys)  return this.set ('keys', keys)
		if (d.foreignKeys) {
			const fks=d.foreignKeys, keys = []
			for (let k in fks)  keys.push = {ref: [fks[k].path], as:fks[k].as}
			return this.set ('keys', keys)
		}
		if (!this.on && this.is2one && this._target) {
			const tks=d._target.keys, keys = []
			for (let k in tks)  keys[k] = { ref: [tks[k].name] }
			return this.set ('keys', keys)
		}
		return  this.set ('keys', undefined)
	}
	get foreignkeys(){ return this.set ('foreignkeys', (
        this.own('keys') ? this.keys.reduce ((fks,x) => {
            let {ref,as} = x.ref  ?  x  :  { ref:x, as:x.match(/[^.]+$/)[0] }
            try { var fk = ref.reduce ((p,n) => p.elements[n], this._target) }
			catch(e){ fk = {__proto__:any.prototype, isUnresolved:1} }
            fks[as] = {__proto__:fk, name:as, ref }
            return fks
        },{})
        // :  this.target.kind == 'any' ? Object.assign ({ $target: {__proto__:string.prototype, name:'$target'} }, this._target.elements)
        :  !this.on && this.is2one  && this._target  ?  this._target.keys
        :  undefined
     ))}
	get is2one(){ return !this.cardinality || this.cardinality.max === 1 || this.cardinality.targetMax === 1 }
    get is2many(){ return !this.is2one }
}

class Composition extends Association {
	is (kind) { return kind === 'Composition' || super.is(kind) }
}


//
//  Built-in types
//

const classes = {
    any, type, scalar, boolean, number, string, date, array, struct,
    entity, view:entity, Association, Composition, context, service,
}

const builtin = {
	UUID: { type:'string', length:36 },
	Boolean: {type:'boolean'},
	Integer: {type:'number'},
	Integer16: {type:'Integer'},
	Integer32: {type:'Integer'},
	Integer64: {type:'Integer'},
	Decimal: {type:'number'},
	DecFloat: { type:'number' },
	Float: {type:'number'},
	Double: {type:'number'},
	DateTime: {type:'date'},
	Date: {type:'date'},
	Time: {type:'date'},
	Timestamp: {type:'date'},
	String: {type:'string'},
	Binary: {type:'string'},
	LargeString: {type:'string'},
	LargeBinary: {type:'string'},
}

const types = {__proto__:builtin}
for (let n in builtin) {
	const b = types['cds.'+n] = builtin[n],  t = b.type
	b.__proto__ = types[t] || classes[t].prototype
}
for (let n in classes)  builtin[n] = classes[n].prototype
types['cds.Association'] = Association.prototype
types['cds.Composition'] = Composition.prototype

Object.defineProperty (classes, 'mixin', {value: (aspects) => {
	for (let each in aspects) {
		for (let kind of Reflect.ownKeys (aspects[each])) {
			Object.defineProperty (types[kind], each,
				Object.getOwnPropertyDescriptor (aspects[each], kind)
			)
		}
	}
}})

module.exports = { types, classes }