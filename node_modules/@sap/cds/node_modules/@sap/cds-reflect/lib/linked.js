const { types, classes, classes: {any,array,struct} } = require ('./types')
const kinds = {}; for (let c in classes)  if (c !== 'type')  kinds[c] = classes[c].prototype
const reflect = require ('./reflect')
const _linked = Symbol('linked')
const _set = (o,p,value) => Object.defineProperty (o,p,{value})

module.exports = function linked (model) {

    if (model[_linked])  return model[_linked]
    if (typeof model === 'string')  model = this.parse (model)

    const m = reflect(model), defs = m.definitions
    Object.defineProperty (model, _linked, {value:m})
    return m.foreach ((d,_) => { //eslint-disable-line no-unused-vars
        let proto = (
            d.type ? defs[d.type] || types[d.type] || unresolved(d.type)  :
            d.kind && kinds[d.kind]  ||
            d.elements && struct.prototype  ||
            d.items && array.prototype  ||
            any.prototype
        )
        try { Object.setPrototypeOf (d,proto) }
        catch(e){ throw new cyclic (d,proto) }
        if (d.target)  _set (d, '_target', defs [d.target] || d.target)
        if (d.via)  _set (d, '_via', defs [d.via] || d.via)
    })

    function unresolved (name) {
        let missing = {name, isUnresolved:true, __proto__:any}
        _set (defs, name, missing)
        return missing
    }
}

class cyclic extends Error {
    constructor (...chain) { super (
        'circular dependency: ' + chain.map(p => p.name).join(' -> '), chain[0]
    )}
}