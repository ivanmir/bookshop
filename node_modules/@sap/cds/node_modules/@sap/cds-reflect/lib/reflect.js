const _reflected = Symbol('reflected')

module.exports = function cds_reflect (x) {

	let reflected = x[_reflected]      //  is there a cached one from a prior call?
	if (reflected)  return reflected   //  yes > done

    if (typeof x === 'string')  x = this.parse(x)
	reflected = (
		is.Model(x) ? new ReflectedModel(x) :
		is.Association(x) ? {__proto__:x, is, def:x,
			get is2one(){ const c = this.cardinality; return !c || c.max === 1 || c.targetMax === 1 },
			get is2many(){ return !this.is2one },
		} :
		is.entity(x) ? {__proto__:x, is, def:x,
			get keys(){
				let ee = this.elements, keys, dict={}
				for (let e in ee)  if (ee[e].key)  (keys=dict)[e] = ee[e]
				return set (this, 'keys', keys)
			}
		} :
		/* else: */ {__proto__:x, is, def:x}
	)
	Object.defineProperty (x, _reflected, {value:reflected})  //> cache it for next time
	return reflected
}

class ReflectedModel {

	constructor (parsed) {
		Object.assign (this, parsed)  //> copy all properties from parsed
		.foreach ((def, parents, name) => { //> fill in all name and kind
			if (!def.name)  set (def, 'name', name)
			if (!def.kind)  set (def, 'kind', parents.length ? 'element' : 'type')
		})
		Object.defineProperties (this, { //> for cdsv...
			_parsed: { value: parsed, configurable:1, writable:1 },
		})
	}

	*each (x, defs=this.definitions) {
		const filter = filter4(x)
		for (let name in defs)  if (filter(defs[name]))  yield defs[name]
	}

	all (x, defs=this.definitions) {
		return [...this.each(x,defs)]
	}

	find (x, defs=this.definitions) {
		for (let d of this.each(x,defs))  return d
	}

	foreach (x, visitor, defs=this.definitions) {

		// filter is optional --> default: any
		if (!visitor) [x,visitor] = [is.any,x]

		// if visitor has only one parameter --> iterate definitions only
		if (visitor.length == 1) {
			for (let d of this.each(x,defs))  visitor(d)
			return this
		}

		// if visitor has two parameters --> recursive iteration
		const filter = filter4(x);  /*run:*/ _recurse (defs,[])
		function _recurse (_defs, parents) {
			for (let name in _defs) {
				let def = _defs[name]
				let d = filter(def) && visitor (def, parents, name) || def
				if (d.elements)  _recurse (d.elements, [...parents, d])
				if (d.target && d.target.elements)  _recurse (d.target.elements, [...parents, d.target])
				if (d.via && d.via.elements)  _recurse (d.via.elements, [...parents, d.via])
			}
		}
		return this
	}

	childrenOf (parent, depth=0, filter=()=>true) {
		let children={}, defs=this.definitions
		let ns = parent.name || parent;  if (ns)  ns += '.'
		for (let fqn in defs) if (fqn.startsWith(ns) && filter(defs[fqn])) {
			let name = fqn.slice (ns.length)
			if (name.indexOf('.') >= depth)  continue
			children[name] = defs[fqn]
		}
		return children
	}

	get exports() {
		return set (this, 'exports', this.childrenOf (this.namespace||''))
	}

	get entities() {
		const _all = this.childrenOf ('', Infinity, is.entity)
		const _for = (namespace) => {
			if (!namespace)  return _all
			const ns = namespace+'.', children={}
			for (let n in _all) if (n.startsWith(ns))  children [n.slice(ns.length)] = _all[n]
			return children
		}
		return set (this, 'entities', Object.assign (_for, _for (this.namespace)))
	}

	get services() {
		const _all = this.childrenOf ('', Infinity, is.service)
		const _for = (namespace) => {
			if (!namespace)  return _all
			const ns = namespace+'.', children={}
			for (let n in _all) if (n.startsWith(ns))  children [n.slice(ns.length)] = _all[n]
			return children
		}
		return set (this, 'services', Object.assign (_for, _for (this.namespace)))
	}

}

function set (o,p,value) {
	Object.defineProperty(o,p,{value, configurable:true, writable:true})
	return value
}


const is = Object.assign (function is (kind) { // this is the instance method for reflected definitions
	return filter4(kind) (this)
}, { //> specialized filters
	Model: d => d.definitions !== undefined || d.extensions !== undefined || d.version !== undefined,
	entity: d => d.kind === 'entity'  ||  d.kind === 'view',
	struct: d => d.elements !== undefined || d.query !== undefined,
	service: d => d.kind === 'service',
	Association: d => d.type === 'cds.Association' || d.type === 'cds.Composition',
	Composition: d => d.type === 'cds.Composition',
	any: ()=>true,
})

function filter4 (x) {
	if (!x) throw new Error ('missing filter for model reflection: '+ x)
	if (x === 'entity' || x.kind === 'entity')  return  is.entity
	if (x._cds)  return  d => d instanceof x  || d.kind == x.name
	if (x.type)  return  d => d.type === x.type
	if (x.kind)  return  filter4 (x.kind)
	if (typeof x === 'string')  return  is[x] || (d => d.kind === x)
	if (typeof x === 'function')  return x
	throw new Error ('invalid filter for model reflection: '+ x)
}
