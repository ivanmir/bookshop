# Getting Started

Welcome to your new project. It contains a few files and folders following our **recommended project layout**:


File / Folder | Purpose
---------|----------
`app/` | your UI app content goes here
`db/` | your database content goes here
`srv/` | your service content goes here
`package.json` | project metadata and configuration
`readme.md` | this readme


The following sections are a quick walkthrough of essential tasks:

<!-- TOC depthFrom:2 depthTo:2 -->

- [Define Services](#define-services)
- [Add Data Models](#add-data-models)
- [Add Databases](#add-databases)
- [Add Initial Data](#add-initial-data)
- [Add Custom Logic](#add-custom-logic)
- [More...](#more)

<!-- /TOC -->

## Define Services

Create a file [srv/cat-service.cds](srv/cat-service.cds) and define a service in there as follows:

```swift
service CatalogService {

  entity Books {
    key ID : Integer;
    title  : localized String;
    author : Association to Authors;
    stock  : Integer;
    origin : String(3);
  }

  entity Authors {
    key ID : Integer;
    name   : String;
    books  : Composition of many Books on books.author=$self;
  }

}
```

### &rarr; Run it

Run that in a terminal to start a server with that definition:
```sh
cds run
```
... which should give you an output like this:

```
[cds] - loaded service definitions from

  srv/cat-service.cds

[cds] - serving CatalogService at /catalog
[cds] - server listens at http://localhost:4004
```

_[Cmd/Ctrl] + double-click_ on <http://localhost:4004> in there to open a browser and send requests to your service using the provided links.



## Add Data Models

In the example above we used an 'all-in-one' service definition with entities declared inline to the service.
Now, we want to add another service for administrators to enter and maintain Books and Authors, that is,
it would expose the same entities just with unrestricted access and additional data.
So we better extract the entity definitions into a shared data model.

Create a file named [db/data-model.cds](db/data-model.cds) and fill it with that:

```swift
namespace my.bookshop;
using { Country, managed } from '@sap/cds/common';

entity Books : managed {
  key ID : Integer;
  title  : localized String;
  author : Association to Authors;
  stock  : Integer;
  origin : Country;
}

entity Authors : managed {
  key ID : Integer;
  name   : String;
  books  : Composition of many Books on books.author=$self;
}
```

> The model reuses common aspect from `@sap/cds/common`, e.g. to equip the entities with
additional fields to track changes.


### Services expose entities from your Data Model


With this, we can add the admin service [srv/admin-service.cds](srv/admin-service.cds) as follows:

```swift
using my.bookshop as my from '../db/data-model';

service AdminService @(requires:'admin') {
  entity Books as projection on my.Books;
  entity Authors as projection on my.Authors;
}
```

And we can adapt our [srv/cat-service.cds](srv/cat-service.cds) similarly, now exposing tailored views for the read-only browsing use case:

```swift
using my.bookshop as my from '../db/data-model';

service CatalogService {

  @readonly entity Books as projection on my.Books {
    *, author.name as author_name
  } excluding {
    createdBy, modifiedBy
  };

  @readonly entity Authors as projection on my.Authors excluding {
    createdBy, modifiedBy
  };

}
```

As we modified our data model, we have to update our database accordingly:

```bash
cds deploy
```

Now re-run with these new services:

```bash
cds run
```


## Add Databases

The `cds.services` runtime ships with built-in generic handlers that serve all CRUD requests automatically to a connected SQL database. The only thing we need to do is provide such a database in the given environment.

```bash
cds deploy srv -2 sqlite:db/bookshop.db
```

Simply re-run the app with `DEBUG=sql cds run` to see it reading from the database.

> `cds.deploy` also records the given configuration in your `package.json`, so that you can re-deploy subsequently by running `cds deploy` without any arguments.





## Add Initial Data

You can hook into the deployment process by adding a [db/init.js](db/init.js) file to your project. For example, we can use that to fill in initial data:

```js
const { Books, Authors } = cds.entities ('my.bookshop')
cds.run (()=>{"serialized"

  // SQL-style columns + values
  INSERT.into (Books) .columns (
    'ID', 'title', 'author_id', 'stock', 'origin'
  ) .values (
    [ 201, 'Wuthering Heights', 101, 12, 'UK' ],
    [ 207, 'Jane Eyre', 107, 11, 'UK' ],
    [ 251, 'The Raven', 150, 333, 'UK' ],
    [ 252, 'Eleonora', 150, 555, 'US' ],
    [ 271, 'Catweazle', 170, 222, 'DE' ]
  )

  // Object-record style values
  INSERT.into (Authors) .entries (
    { ID:101, name:'Emily Brontë' },
    { ID:107, name:'Charlote Brontë' },
    { ID:150, name:'Edgar Allen Poe' },
    { ID:170, name:'Richard Carpenter' }
  )

})
```


## Add Custom Logic

So far, all requests were automatically served by built-in generic service providers which are setup dynamically based on the CDS definitions.

You can hook in to these providers to add your domain-specific logic adding aan equally named `.js` file next to your service definition. E.g. add a file [srv/cat-service.js](srv/cat-service.js) and fill this in:

```js
module.exports = cds.service.impl (function({
  Books, Authors
}){

  // Validate references to Authors
  this.before ('CREATE', Books, (cds) => {
    SELECT (1) .from (Authors) .where ({ ID: cds.data.author_ID })
    .then (rows => rows.length == 1 || cds.error (
      'Specified author does not exist'
    ))
  })

  // Log all changes
  this.after ([ 'CREATE', 'UPDATE', 'DELETE' ], cds => {
    console.log (`${cds.method} entity ${cds.target.name}`)
  })

})
```

## More...

* TODO
