const fs = require('../../lib/utils/fs'), {path}=fs
const _cds = require ('../../lib')

module.exports = Object.assign ( build, {
    options: ['--project', '--module', '--dest', '--dest', '--lang' ], flags: ['--clean', '--incremental', '--dry' ],
    shortcuts: ['-p', '-m', '-o', '-d', '-l', 0, '-c', '-i', '-d' ],
  help: `
# SYNOPSIS

    *cds build* [<modules>] [<options>]

    Builds the modules by compiling contained cds sources according to the
    module types. The modules are folders in the project root; if omitted all
    well known modules or those configured in _package.json_ are built.


# OPTIONS

    *-in* | *--project* <folder>

        use the specified folder as the project root.
        default = current working directory ./

    *-c*  | *--clean*

        deletes target folders before building modules.
        default = _true_

    *-i*  | *--incremental*

        do not delete target folders before building modules.

    *-l*  | *--lang* <languages> | all

        localize the models with given <languages>, a comma-separated list
        of language/locale codes or _all_.

    *-o*  | *--dest* <folder>

        writes output to the given folder.
        default = <project root>


# EXAMPLES

   *cds* build
   *cds* build db,srv srv -o _out

`})


function build (folders=[], o={}, /* for unit tests only: */ _conf) {

    if (typeof folders === 'string')  folders = [folders]
    else if (!Array.isArray(folders))  [folders,o] = [[],folders]

    const console = o.logger || global.console
    const {sql} = o
    const cwd = path.resolve(o.project||'.'), sep = path.sep
    const cds = _cds.in (cwd);  if (_conf)  cds.env = cds.env.for(_conf)
    const dest = path.resolve (cwd, o.dest || cds.env.build.dest || '.')
    const _local = filename => filename.replace (cwd+sep,'')

    const info = require('../version').get()
    console.log(`\n   cds ${info['@sap/cds']}, compiler ${info['@sap/cds-compiler']}, home: ${info.home}\n`)
    console.time('\x1b[0m[cds] - time')

    // prepare build, resolving modules to build...
    const build = {__proto__:cds, all:_prepare(), modules4:_fetch,
        find (...p) { return fs.find (cwd, ...p) },
        dest, written:[]
    }
    if (!build.all) {
        // Do not throw an error in case no modules are found that need to be build.
        // If cf push is executed on some on the service module folder its contents will be deployed to target root
        // without enclosing service module folder - postinstall would fail in such a scenario.
        console.log("No modules to build found in '" + cwd + "'.  Nothing to be done.");
        return Promise.resolve();
    }

    // prebuild phase
    for (let each of build.all) {
        if (each.prebuild)  each.prebuild.call (build, each)
    }

    // build phase
    return Promise.all (build.all.map (_build)) .then (
        ()=> Promise.all (build.written) .then (_done)
    )

    function _prepare(){
        const _modules = []
        if (folders.length) {   // ... from types of specified modules
            for (let folder of folders)
                _modules.push (_determine (folder))
        } else {   // ... by fetching folders for all known module types
            for (let mt of ModuleTypes)
                for (let each of _fetch (mt))
                    _modules.push (each)
        }
        return _modules.length > 0 && _modules
    }

    function _determine (/* module type for */ folder) {
        let mt = ModuleTypes.categories [_local(folder).split('/')[0]]
        if (!mt)  throw new Error (`Couldn't resolve module type for ${folder}`)
        return _found (mt, folder)
    }

    function* _fetch (type) {

        const mt = type.name ? type : ModuleTypes.find (mt => mt.name === type)
        const _conf = cds.env [mt.conf]

        if (_conf && _conf.model) {  // configured...

            let {model} = _conf;  if (model == '--')  return //> skip
            let m = model; model = cds.resolve(m)
            if (!model)  throw new Error(
                `No models found for ${m} as configured in '${cds.env._source || JSON.stringify(cds.env)}'`
            )
            const folder = fs.isdir(Array.isArray(m) ?  m = m[0] : m) || path.dirname(m)
            yield _found (mt, folder, model)

        } else {  // fetch for module patterns


            let {folders,models} = mt, found
            for (let each of (models || folders)) {
                for (let entry of fs.find (cwd, each)) {
                    if (mt.map)  entry = mt.map (entry)
                    if (models && !(models = cds.resolve (entry)))  continue
                    let folder = fs.isdir(entry) || path.dirname(entry)
                    yield found = _found (mt, folder, models)
                }
                if (found)  return
            }

        }
    }

    function _found (mt, folder, models) {
        let o = Object.assign ({__proto__:mt}, cds.env[mt.conf], {
            models, folder,  sql,
        })
        o.dest = path.resolve (dest, o.dest.replace (
            '${folder}', folder === '.' || folder === cwd ? mt.category : _local(folder) //NOSONAR
        ))
        return o
    }

    function _build (options) {

        const {name, models, folder, dest} = options
        console.log (`[cds] - building ${name} module: ${_local(folder)} > ${_local(dest)}`)
        if (models) console.log ('\x1b[2m  ', models.map(_local).join('  '), '\x1b[0m')

        if (o.dry)  return

        const self = {__proto__:build,
            write (x) {return{ to:(...etc) => this.written.push (cds.write(x).to (options.dest, ...etc)) }},
        }

        const clean = () => {
            if (options.clean === false || o.incremental) {
                return Promise.resolve();
            }
            if (fs.existsSync(dest)) {
                fs.rimrafSync(dest);
            }
        };
        const clone = ()=>{
            const src = path.resolve (cwd, folder)
            const dst = path.join (build.dest,_local(folder))
            if (folder === '.' || folder === cwd || src.startsWith(build.dest) || build.dest.startsWith(src)) ; else {
                return fs.copy (folder,dst, true)
                .then (()=>build.written.push (dst+'/**'))
            }
        }
        return options.built = Promise.resolve() .then(clean) .then (clone) .then (()=>
            options.build.call (self,options)
        )
    }

    function _done (files) {
        console.log ('[cds] - done > wrote output to:\x1b[2m')
        const _cwd = process.cwd()
        for (let each of files)  console.log ('  ', path.relative(_cwd,each))
        console.timeEnd ('\x1b[0m[cds] - time');  console.log()
        if (process.env.GENERATION_LOG) {
            fs.writeFile (process.env.GENERATION_LOG, files.map(_local).sort().join('\n'), ()=>{})
            for (let each of files)  console.log ('  ', each.replace(process.cwd(),'').slice(1))
        }
    }


}


const ModuleTypes = function(){
    const all = Object.defineProperty([],'categories',{value:{}})
    for (let each of fs.readdirSync (path.join(__dirname,'modules'))) {
        if (!each.endsWith('.js'))  continue
        let mt = require ('./modules/'+each)
        if (!mt.category)  mt.category = (mt.folders || mt.models)[0]
        mt.name = each.slice(0,-3)
        mt.conf = {app:'apps',srv:'service',db:'data'}[mt.category]
        all.categories [mt.category] = mt
        all.push (mt)
    }
    return all
}()
/* eslint no-console:0 no-extend-native:0 */